<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5.2. Background on the NetShark architecture &mdash; steelscript  documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="steelscript  documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">steelscript  documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="background-on-the-netshark-architecture">
<h1>5.2. Background on the NetShark architecture<a class="headerlink" href="#background-on-the-netshark-architecture" title="Permalink to this headline">¶</a></h1>
<p>This document is a brief introduction to the capabilities and
organization of the <a class="reference internal" href="glossary.html#term-netshark"><em class="xref std std-term">NetShark</em></a> appliance.  No background or
previous experience with NetShark or <a class="reference internal" href="glossary.html#term-packet-analyzer"><em class="xref std std-term">Packet Analyzer</em></a> (formerly
<a class="reference internal" href="glossary.html#term-pilot"><em class="xref std std-term">Pilot</em></a>) is assumed, but you are encouraged to watch the <a class="reference external" href="http://www.riverbed.com/about/document-repository/?isSearch=true&amp;14871=1079001&amp;14941=0&amp;14951=0#">Packet
Analyzer with NetShark - An Introduction</a>
and/or spend some time using Packet Analyzer to familiarize yourself
with the platform and its capabilities.</p>
<div class="section" id="views">
<h2>5.2.1. Views<a class="headerlink" href="#views" title="Permalink to this headline">¶</a></h2>
<p>All analysis and reporting from a NetShark appliance revolves around the
concept of a <a class="reference internal" href="glossary.html#term-view"><em class="xref std std-term">view</em></a>.  Views are extremely flexible and can be
used for many different things but at the core, a view consists simply
of a source of packets to analyze and a set of statistics to be
computed on those packets.  The power of the NetShark platform derives
from the number of statistics that can be exported and the number of
ways those statistics can be combined and organized.</p>
<p>An example of a simple view is &#8220;Bandwidth over Time&#8221;.  In this view,
the <em>length</em> statistic is summed across all packets for fixed small
time intervals (e.g., 1 second).  By plotting the sums for a series of
consecutive time intervals, we get a graph of how the traffic load on
a specific network link has varied over time.</p>
<p>A more complex example is the Packet Analyzer &#8220;Served Web Pages by
Client IP&#8221; view.  In Packet Analyzer, this view presents a table with
three columns: ip address, URL, and count.  There is a separate row in
the table for each unique (client ip address, URL) pair, showing the
number of times the given URL has been fetched from the given client
ip address.  This view could additionally be filtered, for example
showing only URLs fetched using the Chrome web browser or showing only
URLs with mime type <tt class="docutils literal"><span class="pre">image/jpeg</span></tt>.  In this case, the statistics
extracted are more complex &#8211; extracting the URL (or browser or
content type) from an HTTP session requires reassembling the
underlying TCP connection from individual packets.  And the
organization of the statistics is a little more complex, the NetShark
internally constructs and updates a table much like the one presented
in the Packet Analyzer user interface.</p>
<p>These examples are just meant to help illustrate what views are at a
high level.  The details about exactly how views are contstructed and
accessed are later in this document and elsewhere in the FlyScript
documentation.</p>
</div>
<div class="section" id="packet-sources">
<h2>5.2.2. Packet Sources<a class="headerlink" href="#packet-sources" title="Permalink to this headline">¶</a></h2>
<p>This section describes the abstractions provided by a NetShark appliance
for organizing and identifying the packets that can be used as the basis
for creating a view.</p>
<div class="section" id="interfaces">
<h3>5.2.2.1. Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h3>
<p>Perhaps the simplest packet source is a raw network interface, also
called a <a class="reference internal" href="glossary.html#term-capture-port"><em class="xref std std-term">capture port</em></a>.  A capture port on a NetShark appliance is
typically connected to a switch port that mirrors live traffic to the
NetShark for monitoring and analysis (often called a SPAN port).  When a
view is applied to an interface, every packet that arrives on the
interface is available to the view for processing.  A view applied to
an interface is also a <em>live</em> view, meaning that as new packets
arrive, they are immediately processed by the view and show up in the
view outputs.</p>
</div>
<div class="section" id="capture-jobs">
<h3>5.2.2.2. Capture Jobs<a class="headerlink" href="#capture-jobs" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="glossary.html#term-capture-job"><em class="xref std std-term">capture job</em></a> is a long-running task on a NetShark appliance that
captures, stores, and indexes live traffic.  It logically consists of
a physical network interface and an optional filter to limit which
packets should be captured.  The actual packets and associated
indexing information are all stored locally on the NetShark appliance,
using a custom filesystem tailored to the task of capturing traffic at
a high rate and indexing the capture traffic for efficient queries.
The capabilities of capture jobs are accessed from Python code using
<a class="reference internal" href="netshark.html#capture-job-objects"><em>Capture Job Objects</em></a>.</p>
<p>There are actually two different logical packets source associated
with a capture job.  The job itself refers to all the packets stored
on disk that have been previously captured as part of the job.  A view
created with a capture job as the packet source is applied to all
packets that are available on disk, but is <em>not</em> applied to new
packets as they arrive.  Instead, each capture job has an associated
<em>virtual device</em> that is used for ongoing live traffic.  The virtual
device corresponding to a capture job appears like an interface, as
described above.</p>
<p>The virtual device associated with a capture job may appear redundant
with just applying a view with a filter to an interface.
The filters associated with capture jobs are generally more efficient
than view filters, so on an appliance handling a high sustained
rate of packet capture, using a capture job is preferrable.
A full description of the tradeoffs is beyond the scope of this
document, for more details see the NetShark manual.</p>
</div>
<div class="section" id="trace-clips">
<h3>5.2.2.3. Trace Clips<a class="headerlink" href="#trace-clips" title="Permalink to this headline">¶</a></h3>
<p>The packets captured as part of a capture job are kept in a
first-in-first-out (FIFO) structured store.  For cases when some
packets need to be retained for longer, a <a class="reference internal" href="glossary.html#term-trace-clip"><em class="xref std std-term">trace clip</em></a> is used.
A trace clip identifies some subset of the packets stored as part of a
capture job and optionally locks them, meaning that those packets will
be kept on disk until the trace clip is deleted.  Note that locking
packets on disk as part of a trace clip effectively reduces the size
of the FIFO store available for other ongoing capture jobs.</p>
<p>The exact set of packets that should go into a trace clip is
identified using filters.  Filters are described more fully below.
But trace clips typically include at least a time filter to select
packets from a specific time interval, and may include filters to
select just traffic to/from a specific IP address and/or a specific
TCP or UDP port number.  Trace clips are accessed in SteelScript via the
methods <a class="reference internal" href="netshark.html#steelscript.netshark.core.NetShark.get_clips" title="steelscript.netshark.core.NetShark.get_clips"><tt class="xref py py-meth docutils literal"><span class="pre">NetShark.get_clips()</span></tt></a> and <a class="reference internal" href="netshark-api4.html#steelscript.netshark.core.Job4.add_clip" title="steelscript.netshark.core.Job4.add_clip"><tt class="xref py py-meth docutils literal"><span class="pre">Job4.add_clip()</span></tt></a>.</p>
</div>
</div>
<div class="section" id="extractors">
<h2>5.2.3. Extractors<a class="headerlink" href="#extractors" title="Permalink to this headline">¶</a></h2>
<p>Now that we have established how packets are directed into views, we
turn to the topic of how information is extracted from packets.  The
central concept in this section is <a class="reference internal" href="glossary.html#term-extractor-field"><em class="xref std std-term">extractor fields</em></a>.  An extractor field is an individual piece of information.
Simple extractor fields are computed from a single packet, typical
examples are the packet length in bytes, or the IP source address of
an IP packet.  More complex extractor fields work on a stream of
packets to compute higher level statistics.  Examples of more
compliated extractor fields are the jitter in a VOIP call or the
number of retransmissions on a TCP connection &#8211; these statistics can
only be derived by looking at the relationship between multiple
packets.</p>
<p>Every extractor field has a name of the form <tt class="docutils literal"><span class="pre">extractor.name</span></tt> used
to uniquely identify the field, as well as a human-readable
description that briefly explains what the field is.  <tt class="docutils literal"><span class="pre">Extractor</span></tt> is
a high-level category such as <tt class="docutils literal"><span class="pre">generic</span></tt> for fields that apply to any
type of packet, <tt class="docutils literal"><span class="pre">tcp</span></tt> for fields that are specific to TCP, <tt class="docutils literal"><span class="pre">voip</span></tt>
for fields specific to voice-over-IP, etc.  The <tt class="docutils literal"><span class="pre">name</span></tt> is a unique
short descriptive name.  For example, <tt class="docutils literal"><span class="pre">generic.bits</span></tt> is the length
of a packet in bits, and <tt class="docutils literal"><span class="pre">tcp.src_port</span></tt> is the source port from the
TCP header of a TCP packet.  In addition, each field has a fixed type
(e.g., string, integer, IP address, etc.) and always yields values of
that type.</p>
<p>See <a class="reference internal" href="netshark.html#extractor-fields"><em>Extractor Fields</em></a> for details on using extractor fields from
SteelScript.</p>
<p>The next two sections explain how extractor fields are used
in packet filters and in views.</p>
</div>
<div class="section" id="filters">
<h2>5.2.4. Filters<a class="headerlink" href="#filters" title="Permalink to this headline">¶</a></h2>
<p>Packet filters were mentioned above as part of creating views and
trace clips.  As the name suggests, a filter is applied to a packet
source to select some subset of the original packets for view
processing or for inclusion in a trace clip.  NetShark implements two
types of filters: native filters and Wireshark filters.  A native
filter is simply a test applied to an <a class="reference internal" href="glossary.html#term-extractor-field"><em class="xref std std-term">extractor field</em></a>.  For
example, <tt class="docutils literal"><span class="pre">ip.src=&quot;10.1.2.3&quot;</span></tt> matches all packets with source IP
address 10.1.2.3, or <tt class="docutils literal"><span class="pre">generic.bytes</span> <span class="pre">&gt;=</span> <span class="pre">100</span></tt> matches all packets at
least 100 bytes long.</p>
<p>NetShark includes an extensive set of built-in extractor fields for
common protocols including IP, TCP, UDP, RTP, HTTP, and others.  Many
powerful filters can be built using these extractors, but the number
of applications that NetShark has built-in extractors for is modest
compared to the <a class="reference external" href="http://www.wireshark.org">Wireshark</a> network
analyzer.  Wireshark has well over 100,000 extractor fields &#8211; for
cases that are not covered by the shark built-in extractors, a
wireshark filter can be used instead.  A wireshark filter is specified
using the <a class="reference external" href="http://www.wireshark.org/docs/dfref/">Wireshark Display Filter syntax</a>.  Although wireshark filters
offer great flexibility, they are implemented by starting a separate
wireshark process and sending packets to that process for filtering,
so they are significantly slower than native filters and may not be
appropriate for applying to very large traces or high-rate live
traffic.</p>
<p>See <a class="reference internal" href="netshark.html#netshark-filters"><em>Filters</em></a> for details on working with filters from SteelScript.</p>
</div>
<div class="section" id="inside-a-view">
<h2>5.2.5. Inside a View<a class="headerlink" href="#inside-a-view" title="Permalink to this headline">¶</a></h2>
<p>We now have all the concepts needed to explain how NetShark views are
constructed.  A view consists of two major pieces: which packets
should be analyzed, and what analysis should be done on those packets.
The first piece (which packets should be analyzed) is specified as a
packet source and optionally, some filters.</p>
<p>The actual analysis is organized around extractor fields.  When a view
is created, a list of extractor fields is supplied, each of which is
designated as either a <em>key</em> or a <em>value</em>.  We begin with value
fields.  Each value field corresponds to a single output for the view,
but of course there can be many packets processed by the view, so the
field has an associated <em>calculation</em> that specifies how the
indvidiual samples are aggregated into a single statistic.  Possible
calculations include summing the individual samples, computing the
average, or finding the minimum or maximum value.</p>
<p>To make this concrete, consider a simple example of a view with just
one field: packet size.  If we use the averaging calculation, this
view computes the average size of all packets in the input.  By
choosing a different calculation we could easily compute the minimum
or maximum packet size, or the total number of bytes across all
packets.  This computation is automatically organized into a series of
discrete time intervals, at a frequency specified when the view is
created.  Using our example above, by using the addition operator to
aggregate packet sizes, we actually get a time series with the total
bandwidth used in each 1 second interval &#8211; effectively a view of
bandwidth over time.  Similarly, with any other extractor fields and
aggregation operators, the view output is a time series indicating how
the aggregated value field has changed over time.</p>
<p>Returning to <em>key</em> fields, a view is actually organized as a table
with a column for each extractor field.  If there are no key fields,
as in our examples above, the table simply has one default row where
all statistics are collected.  But when key fields are specified, a
tuple is created consisting of the values of all the key columns, and
a new row is added to the table for each unique tuple.  To make this
concrete, one could create a simple view to compute a list of all
TCP/IP connections by specifying four key columns: source IP address,
source TCP port, destination IP address, and destination TCP port.  In
this way, a new row would be created in the view table for each unique
connection 4-tuple, so reading the contents of the view table yields a
list of all connections.</p>
<p>Combining key and value columns, we can merge our examples above by
creating a view with key columns for the source and destination
addresses and ports and a value column for total packet size.  We now
get a table of all connections with the total number of bytes sent on
each connection.  If we sort this table by the total bytes sent, we
have a &#8220;top talkers&#8221; report!</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/rb-ss-logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="overview.html">SteelScript NetShark</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.2. Background on the NetShark architecture</a><ul>
<li><a class="reference internal" href="#views">5.2.1. Views</a></li>
<li><a class="reference internal" href="#packet-sources">5.2.2. Packet Sources</a><ul>
<li><a class="reference internal" href="#interfaces">5.2.2.1. Interfaces</a></li>
<li><a class="reference internal" href="#capture-jobs">5.2.2.2. Capture Jobs</a></li>
<li><a class="reference internal" href="#trace-clips">5.2.2.3. Trace Clips</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extractors">5.2.3. Extractors</a></li>
<li><a class="reference internal" href="#filters">5.2.4. Filters</a></li>
<li><a class="reference internal" href="#inside-a-view">5.2.5. Inside a View</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/netshark/background.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><h3>
<a href="../license.html">License</a>
</h3>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">steelscript  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014 Riverbed Technology, Inc..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>