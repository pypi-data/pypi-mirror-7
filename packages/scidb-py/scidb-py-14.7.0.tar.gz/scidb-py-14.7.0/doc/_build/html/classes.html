

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; SciDB-Py 14.7.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="SciDB-Py 14.7.0 documentation" href="index.html"/>
        <link rel="up" title="API Documentation" href="api.html"/>
        <link rel="prev" title="API Documentation" href="api.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> SciDB-Py</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="whats_new.html">Whats New</a><ul>
<li class="toctree-l2"><a class="reference internal" href="whats_new.html#released-august-1-2014">14.7 (Released August 1, 2014)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing SciDB-Py</a><ul>
<li class="toctree-l2"><a class="reference internal" href="install.html#software-prerequisites">Software prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#python-prerequisites">Python Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="install.html#scidb-py-package-installation">SciDB-Py Package Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Basic Use</a><ul>
<li class="toctree-l2"><a class="reference internal" href="connection.html">Introduction to SciDB arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="connection.html#loading-the-scidbpy-package-and-connecting-to-scidb">Loading the scidbpy package and connecting to SciDB</a></li>
<li class="toctree-l2"><a class="reference internal" href="creation.html">Creating arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="access.html">Accessing array data</a></li>
<li class="toctree-l2"><a class="reference internal" href="operations.html">Operations on SciDB array objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="comparison_and_filtering.html">Comparing and Filtering Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="query.html">The SciDB Query Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion.html">Downloading SciDBArrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="demos.html">Demos and Other Topics</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api.html">API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="">Class Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="afl.html">AFL Operator Reference</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">SciDB-Py</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="api.html">API Documentation</a> &raquo;</li>
      
    <li>API Reference</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/classes.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<p>This is the list of classes and functions available in SciDB-py.</p>
<span class="target" id="module-scidbpy"></span><div class="section" id="scidb-array-class">
<h2>SciDB Array Class<a class="headerlink" href="#scidb-array-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="scidbpy.SciDBArray">
<em class="property">class </em><tt class="descclassname">scidbpy.</tt><tt class="descname">SciDBArray</tt><big>(</big><em>datashape</em>, <em>interface</em>, <em>name</em>, <em>persistent=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray" title="Permalink to this definition">¶</a></dt>
<dd><p>SciDBArray class</p>
<p>It is not recommended to instantiate this class directly; use a
convenience routine from SciDBInterface.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.alias" title="scidbpy.SciDBArray.alias"><tt class="xref py py-obj docutils literal"><span class="pre">alias</span></tt></a>([name])</td>
<td>Return an alias of the array, optionally with a new name</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.approxdc" title="scidbpy.SciDBArray.approxdc"><tt class="xref py py-obj docutils literal"><span class="pre">approxdc</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the number of distinct values of the array or along an axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.att" title="scidbpy.SciDBArray.att"><tt class="xref py py-obj docutils literal"><span class="pre">att</span></tt></a>(a)</td>
<td>Return the attribute name of the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.attribute" title="scidbpy.SciDBArray.attribute"><tt class="xref py py-obj docutils literal"><span class="pre">attribute</span></tt></a>(a)</td>
<td>Return the attribute name of the array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.avg" title="scidbpy.SciDBArray.avg"><tt class="xref py py-obj docutils literal"><span class="pre">avg</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the average of the array or the average along an axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.compress" title="scidbpy.SciDBArray.compress"><tt class="xref py py-obj docutils literal"><span class="pre">compress</span></tt></a>(mask[,&nbsp;axis])</td>
<td>Extract a subset of entries along a given axis,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.contains_nulls" title="scidbpy.SciDBArray.contains_nulls"><tt class="xref py py-obj docutils literal"><span class="pre">contains_nulls</span></tt></a>([attr])</td>
<td>Return True if the array contains null values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.contents" title="scidbpy.SciDBArray.contents"><tt class="xref py py-obj docutils literal"><span class="pre">contents</span></tt></a>(**kwargs)</td>
<td>Return a string representation of the array contents</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.copy" title="scidbpy.SciDBArray.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>([new_name,&nbsp;persistent])</td>
<td>Make a copy of the array in the database</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.count" title="scidbpy.SciDBArray.count"><tt class="xref py py-obj docutils literal"><span class="pre">count</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the count of the array or the count along an axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.cumprod" title="scidbpy.SciDBArray.cumprod"><tt class="xref py py-obj docutils literal"><span class="pre">cumprod</span></tt></a>([axis])</td>
<td>Return the cumulative product over the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.cumsum" title="scidbpy.SciDBArray.cumsum"><tt class="xref py py-obj docutils literal"><span class="pre">cumsum</span></tt></a>([axis])</td>
<td>Return the cumulative sum over the array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.cumulate" title="scidbpy.SciDBArray.cumulate"><tt class="xref py py-obj docutils literal"><span class="pre">cumulate</span></tt></a>(expression[,&nbsp;dimension])</td>
<td>Compute running operations along data (e.g., cumulative sums)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.dimension" title="scidbpy.SciDBArray.dimension"><tt class="xref py py-obj docutils literal"><span class="pre">dimension</span></tt></a>(d)</td>
<td>Return the dimension name of the array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.eval" title="scidbpy.SciDBArray.eval"><tt class="xref py py-obj docutils literal"><span class="pre">eval</span></tt></a>([out,&nbsp;store])</td>
<td>If the array is backed by an unevaluated query,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.from_query" title="scidbpy.SciDBArray.from_query"><tt class="xref py py-obj docutils literal"><span class="pre">from_query</span></tt></a>(interface,&nbsp;query)</td>
<td>Build a lazily-evaulated SciDB array from a query string</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.groupby" title="scidbpy.SciDBArray.groupby"><tt class="xref py py-obj docutils literal"><span class="pre">groupby</span></tt></a>(by)</td>
<td>Build a groupby object from this array</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.head" title="scidbpy.SciDBArray.head"><tt class="xref py py-obj docutils literal"><span class="pre">head</span></tt></a>([n])</td>
<td>Extract and download the first few elements in the array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.issparse" title="scidbpy.SciDBArray.issparse"><tt class="xref py py-obj docutils literal"><span class="pre">issparse</span></tt></a>()</td>
<td>Check whether array is sparse.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.max" title="scidbpy.SciDBArray.max"><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the maximum of the array or the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.mean" title="scidbpy.SciDBArray.mean"><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the average of the array or the average along an axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.min" title="scidbpy.SciDBArray.min"><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the minimum of the array or the minimum along an axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.nonempty" title="scidbpy.SciDBArray.nonempty"><tt class="xref py py-obj docutils literal"><span class="pre">nonempty</span></tt></a>()</td>
<td>Return the number of nonempty elements in the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.nonnull" title="scidbpy.SciDBArray.nonnull"><tt class="xref py py-obj docutils literal"><span class="pre">nonnull</span></tt></a>([attr])</td>
<td>Return the number of non-empty and non-null values.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.reap" title="scidbpy.SciDBArray.reap"><tt class="xref py py-obj docutils literal"><span class="pre">reap</span></tt></a>([ignore])</td>
<td>Delete this object from the database if it isn&#8217;t persistent.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.regrid" title="scidbpy.SciDBArray.regrid"><tt class="xref py py-obj docutils literal"><span class="pre">regrid</span></tt></a>(size[,&nbsp;aggregate])</td>
<td>Regrid the array using the specified aggregate</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.rename" title="scidbpy.SciDBArray.rename"><tt class="xref py py-obj docutils literal"><span class="pre">rename</span></tt></a>(new_name[,&nbsp;persistent])</td>
<td>Rename the array in the database, optionally making the new array persistent.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.reshape" title="scidbpy.SciDBArray.reshape"><tt class="xref py py-obj docutils literal"><span class="pre">reshape</span></tt></a>(shape,&nbsp;**kwargs)</td>
<td>Reshape data into a new array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.std" title="scidbpy.SciDBArray.std"><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the standard deviation of the array or along an axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.stdev" title="scidbpy.SciDBArray.stdev"><tt class="xref py py-obj docutils literal"><span class="pre">stdev</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the standard deviation of the array or along an axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.substitute" title="scidbpy.SciDBArray.substitute"><tt class="xref py py-obj docutils literal"><span class="pre">substitute</span></tt></a>(value)</td>
<td>Reshape data into a new array, substituting a default for any nulls.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.sum" title="scidbpy.SciDBArray.sum"><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the sum of the array or the sum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">tail</span></tt>([n])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.toarray" title="scidbpy.SciDBArray.toarray"><tt class="xref py py-obj docutils literal"><span class="pre">toarray</span></tt></a>([transfer_bytes])</td>
<td>Transfer data from database and store in a numpy array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.todataframe" title="scidbpy.SciDBArray.todataframe"><tt class="xref py py-obj docutils literal"><span class="pre">todataframe</span></tt></a>([transfer_bytes])</td>
<td>Transfer array from database and store in a local Pandas dataframe</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.tosparse" title="scidbpy.SciDBArray.tosparse"><tt class="xref py py-obj docutils literal"><span class="pre">tosparse</span></tt></a>([sparse_fmt,&nbsp;transfer_bytes])</td>
<td>Transfer array from database and store in a local sparse array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.SciDBArray.transpose" title="scidbpy.SciDBArray.transpose"><tt class="xref py py-obj docutils literal"><span class="pre">transpose</span></tt></a>(*axes)</td>
<td>Permute the dimensions of an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.SciDBArray.var" title="scidbpy.SciDBArray.var"><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt></a>([index,&nbsp;scidb_syntax])</td>
<td>Return the variance of the array or the variance along an axis.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="scidbpy.SciDBArray.T">
<tt class="descname">T</tt><a class="headerlink" href="#scidbpy.SciDBArray.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute the dimensions of an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axes</strong> : None, tuple of ints, or <cite>n</cite> ints</p>
<blockquote>
<div><ul class="simple">
<li>None or no argument: reverses the order of the axes.</li>
<li>tuple of ints: <cite>i</cite> in the <cite>j</cite>-th place in the tuple means <cite>a</cite>&#8216;s
<cite>i</cite>-th axis becomes <cite>a.transpose()</cite>&#8216;s <cite>j</cite>-th axis.</li>
<li><cite>n</cite> ints: same as an n-tuple of the same ints (this form is
intended simply as a &#8220;convenience&#8221; alternative to the tuple form)</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>Copy of <cite>a</cite>, with axes suitably permuted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="scidbpy.SciDBArray.afl">
<tt class="descname">afl</tt><a class="headerlink" href="#scidbpy.SciDBArray.afl" title="Permalink to this definition">¶</a></dt>
<dd><p>An alias to the AFL namespace</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.alias">
<tt class="descname">alias</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an alias of the array, optionally with a new name</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.approxdc">
<tt class="descname">approxdc</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.approxdc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of distinct values of the array or along an axis.</p>
<p>The distinct count is an estimate only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.att">
<tt class="descname">att</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.att" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the attribute name of the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : int</p>
<blockquote class="last">
<div><p>Index of the attribute to lookup</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.attribute">
<tt class="descname">attribute</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the attribute name of the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : int</p>
<blockquote class="last">
<div><p>Index of the attribute to lookup</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.avg">
<tt class="descname">avg</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.avg" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average of the array or the average along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.compress">
<tt class="descname">compress</tt><big>(</big><em>mask</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a subset of entries along a given axis,
where an input mask array is non-null</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : SciDBArray</p>
<blockquote>
<div><p>The array to filter</p>
</div></blockquote>
<p><strong>mask</strong> : SciDBArray</p>
<blockquote>
<div><p>A 1-dimensional SciDBArray, whose non-null values indicate
the entries to retain</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>The axis of array along which to apply the mask. The shape
of array along this axis must be the length of mask</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.contains_nulls">
<tt class="descname">contains_nulls</tt><big>(</big><em>attr=None</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.contains_nulls" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the array contains null values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>attr</strong> : None, int, or array_like</p>
<blockquote>
<div><p>the attribute index/indices to check.  If None, then check all.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>contains_nulls</strong> : boolean</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.contents">
<tt class="descname">contents</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.contents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of the array contents</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.copy">
<tt class="descname">copy</tt><big>(</big><em>new_name=None</em>, <em>persistent=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the array in the database</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new_name</strong> : string (optional)</p>
<blockquote>
<div><p>if specifiedmust be a valid array name which does not already
exist in the database.</p>
</div></blockquote>
<p><strong>persistent</strong> : boolean (optional)</p>
<blockquote>
<div><p>specify whether the new array is persistent (default=False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>copy</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>return a copy of the original array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.count">
<tt class="descname">count</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the count of the array or the count along an axis.</p>
<p>The count is equal to the number of nonnull elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.cumprod">
<tt class="descname">cumprod</tt><big>(</big><em>axis=None</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product over the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : int, optional</p>
<blockquote>
<div><p>The axis to multiply over. The default multiplies over the
flattened array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>prods</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>A new array, with the same shape (but flattened if axis=None)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#scidbpy.SciDBArray.cumsum" title="scidbpy.SciDBArray.cumsum"><tt class="xref py py-obj docutils literal"><span class="pre">cumsum</span></tt></a>, <a class="reference internal" href="afldb.html#cumulate" title="cumulate"><tt class="xref py py-obj docutils literal"><span class="pre">cumulate</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.cumsum">
<tt class="descname">cumsum</tt><big>(</big><em>axis=None</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum over the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : int, optional</p>
<blockquote>
<div><p>The axis to sum over. The default sums over the
flattened array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sums</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>A new array, with the same shape (but flattened if axis=None)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#scidbpy.SciDBArray.cumprod" title="scidbpy.SciDBArray.cumprod"><tt class="xref py py-obj docutils literal"><span class="pre">cumprod</span></tt></a>, <a class="reference internal" href="afldb.html#cumulate" title="cumulate"><tt class="xref py py-obj docutils literal"><span class="pre">cumulate</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.cumulate">
<tt class="descname">cumulate</tt><big>(</big><em>expression</em>, <em>dimension=0</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.cumulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute running operations along data (e.g., cumulative sums)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>expression: str</strong> :</p>
<blockquote>
<div><p>A valid SciDB expression</p>
</div></blockquote>
<p><strong>dimension</strong> : int or str (optional, default=0)</p>
<blockquote>
<div><p>Which dimension to accumulate over</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>A new array of the same shape.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#scidbpy.SciDBArray.cumsum" title="scidbpy.SciDBArray.cumsum"><tt class="xref py py-obj docutils literal"><span class="pre">cumsum</span></tt></a>, <a class="reference internal" href="#scidbpy.SciDBArray.cumprod" title="scidbpy.SciDBArray.cumprod"><tt class="xref py py-obj docutils literal"><span class="pre">cumprod</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sdb</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">cumulate</span><span class="p">(</span><span class="s">&#39;sum(f0)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">      [ 4,  6,  8, 10],</span>
<span class="go">      [12, 15, 18, 21]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.dimension">
<tt class="descname">dimension</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension name of the array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>d</strong> : int</p>
<blockquote class="last">
<div><p>The index of the dimension to lookup</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.eval">
<tt class="descname">eval</tt><big>(</big><em>out=None</em>, <em>store=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>If the array is backed by an unevaluated query,
evaluate the query and store the result in the database</p>
<p>This changes array.name from a query string to a
stored array name. Calling eval() on an array
that is already backed by a stored array does nothing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>out</strong> : SciDBArray (optional)</p>
<blockquote class="last">
<div><p>An optional pre-existing array to store the evaluation into.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="scidbpy.SciDBArray.from_query">
<em class="property">classmethod </em><tt class="descname">from_query</tt><big>(</big><em>interface</em>, <em>query</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.from_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a lazily-evaulated SciDB array from a query string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>interface</strong> : SciDBInterface</p>
<blockquote>
<div><p>The database connection to use</p>
</div></blockquote>
<p><strong>query</strong> : str</p>
<blockquote>
<div><p>The query string to wrap</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> : SciDBArray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.groupby">
<tt class="descname">groupby</tt><big>(</big><em>by</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a groupby object from this array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>by</strong> : string or list of strings</p>
<blockquote>
<div><p>Names of attributes and dimensions to group by</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>groups</strong> : <a class="reference internal" href="#scidbpy.aggregation.GroupBy" title="scidbpy.aggregation.GroupBy"><tt class="xref py py-class docutils literal"><span class="pre">scidbpy.aggregation.GroupBy</span></tt></a> instance</p>
<blockquote class="last">
<div><p>An object that can be used, e.g., to perform
aggregations over each group. See <a class="reference internal" href="#scidbpy.aggregation.GroupBy" title="scidbpy.aggregation.GroupBy"><tt class="xref py py-class docutils literal"><span class="pre">scidbpy.aggregation.GroupBy</span></tt></a>
documentation for more information.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.head">
<tt class="descname">head</tt><big>(</big><em>n=5</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract and download the first few elements in the array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : int (optional, default=5)</p>
<blockquote>
<div><p>The number of elements to retrieve</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>head</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>The first N elements in the array, downloaded
as a Pandas dataframe (if pandas is installed) or a Numpy array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.issparse">
<tt class="descname">issparse</tt><big>(</big><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.issparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether array is sparse.</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.max">
<tt class="descname">max</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of the array or the maximum along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.mean">
<tt class="descname">mean</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average of the array or the average along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Identical to <a class="reference internal" href="#scidbpy.SciDBArray.avg" title="scidbpy.SciDBArray.avg"><tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.avg()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.min">
<tt class="descname">min</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of the array or the minimum along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.nonempty">
<tt class="descname">nonempty</tt><big>(</big><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.nonempty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nonempty elements in the array.</p>
<p>Nonempty refers to the sparsity of an array, and thus includes in the
count elements with values which are set to NULL.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#scidbpy.SciDBArray.nonnull" title="scidbpy.SciDBArray.nonnull"><tt class="xref py py-obj docutils literal"><span class="pre">nonnull</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.nonnull">
<tt class="descname">nonnull</tt><big>(</big><em>attr=0</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.nonnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of non-empty and non-null values.</p>
<p>This query must be done for each attribute: the default is the first
attribute.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>attr</strong> : None, int or array_like</p>
<blockquote>
<div><p>the attribute or attributes to query.  If None, then query all
attributes.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>nonnull</strong> : array_like</p>
<blockquote class="last">
<div><p>the nonnull count for each attribute.  The returned value is the
same shape as the input <tt class="docutils literal"><span class="pre">attr</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#scidbpy.SciDBArray.nonempty" title="scidbpy.SciDBArray.nonempty"><tt class="xref py py-obj docutils literal"><span class="pre">nonempty</span></tt></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="scidbpy.SciDBArray.persistent">
<tt class="descname">persistent</tt><a class="headerlink" href="#scidbpy.SciDBArray.persistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether the array is deleted when
the database is reaped</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.reap">
<tt class="descname">reap</tt><big>(</big><em>ignore=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.reap" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this object from the database if it isn&#8217;t persistent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ignore</strong> : bool (default False)</p>
<blockquote>
<div><p>If False and the array is persistent, then reap raises an error
If True and the array is persistent, reap does nothing</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>SciDBForbidden if ``persistent=True`` and ``ignore=False`</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.regrid">
<tt class="descname">regrid</tt><big>(</big><em>size</em>, <em>aggregate=u'avg'</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.regrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Regrid the array using the specified aggregate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : int or tuple of ints</p>
<blockquote>
<div><p>Specify the size of the regridding along each dimension.  If a
single integer, then use the same regridding along each dimension.</p>
</div></blockquote>
<p><strong>aggregate</strong> : string</p>
<blockquote>
<div><p>specify the aggregation function to use when creating the new
grid.  Default is &#8216;avg&#8217;.  Possible values are:
[&#8216;avg&#8217;, &#8216;sum&#8217;, &#8216;min&#8217;, &#8216;max&#8217;, &#8216;count&#8217;, &#8216;stdev&#8217;, &#8216;var&#8217;, &#8216;approxdc&#8217;]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A</strong> : scidbarray</p>
<blockquote class="last">
<div><p>The re-gridded version of the array.  The size of dimension i
is ceil(self.shape[i] / size[i])</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.rename">
<tt class="descname">rename</tt><big>(</big><em>new_name</em>, <em>persistent=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename the array in the database, optionally making the new
array persistent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new_name</strong> : string</p>
<blockquote>
<div><p>must be a valid array name which does not already
exist in the database.</p>
</div></blockquote>
<p><strong>persistent</strong> : boolean (optional)</p>
<blockquote>
<div><p>specify whether the new array is persistent (default=False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>return a pointer to self</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.reshape">
<tt class="descname">reshape</tt><big>(</big><em>shape</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape data into a new array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple or int</p>
<blockquote>
<div><p>The shape of the new array.  Must be compatible with the current
shape</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>additional keyword arguments will be passed to SciDBDatashape</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>new array of the specified shape</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="scidbpy.SciDBArray.schema">
<tt class="descname">schema</tt><a class="headerlink" href="#scidbpy.SciDBArray.schema" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the array schema</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.std">
<tt class="descname">std</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard deviation of the array or along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Identical to <a class="reference internal" href="#scidbpy.SciDBArray.stdev" title="scidbpy.SciDBArray.stdev"><tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.stdev()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.stdev">
<tt class="descname">stdev</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard deviation of the array or along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.substitute">
<tt class="descname">substitute</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape data into a new array, substituting a default for any nulls.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>value</strong> : value to replace nulls (required)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>new non-nullable array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is currently limited to single-attribute arrays.
Use the raw AFL substutute operator for multi-attribute arrays</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.sum">
<tt class="descname">sum</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the array or the sum along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.toarray">
<tt class="descname">toarray</tt><big>(</big><em>transfer_bytes=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.toarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer data from database and store in a numpy array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>transfer_bytes</strong> : DEPRECATED</p>
<blockquote>
<div><p>Unused</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The dense array containing the data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If the array is backed by a query, the query is evaluated and stored
in the database</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.todataframe">
<tt class="descname">todataframe</tt><big>(</big><em>transfer_bytes=True</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.todataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer array from database and store in a local Pandas dataframe</p>
<p>For multidimensional arrays, the dimension values are added
as additional columns in the dataframe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>transfer_bytes</strong> : boolean</p>
<blockquote>
<div><p>if True (default), then transfer data as bytes rather than as
ASCII.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : pd.DataFrame</p>
<blockquote class="last">
<div><p>The dataframe object containing the data in the array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.tosparse">
<tt class="descname">tosparse</tt><big>(</big><em>sparse_fmt=u'recarray'</em>, <em>transfer_bytes=True</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.tosparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer array from database and store in a local sparse array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>transfer_bytes</strong> : boolean</p>
<blockquote>
<div><p>if True (default), then transfer data as bytes rather than as
ASCII.  This is more accurate, but requires two passes over
the data (one for indices, one for values).</p>
</div></blockquote>
<p><strong>sparse_format</strong> : string or None</p>
<blockquote>
<div><p>Specify the sparse format to use.  Available formats are:
- &#8216;recarray&#8217; : a record array containing the indices and</p>
<blockquote>
<div><p>values for each data point.  This is valid for arrays of
any dimension and with any number of attributes.</p>
</div></blockquote>
<ul class="simple">
<li>[&#8216;coo&#8217;|&#8217;csc&#8217;|&#8217;csr&#8217;|&#8217;dok&#8217;|&#8217;lil&#8217;] : a scipy sparse matrix.
These are valid only for 2-dimensional arrays with a single
attribute.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : ndarray or sparse matrix</p>
<blockquote class="last">
<div><p>The sparse representation of the data</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.transpose">
<tt class="descname">transpose</tt><big>(</big><em>*axes</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute the dimensions of an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axes</strong> : None, tuple of ints, or <cite>n</cite> ints</p>
<blockquote>
<div><ul class="simple">
<li>None or no argument: reverses the order of the axes.</li>
<li>tuple of ints: <cite>i</cite> in the <cite>j</cite>-th place in the tuple means <cite>a</cite>&#8216;s
<cite>i</cite>-th axis becomes <cite>a.transpose()</cite>&#8216;s <cite>j</cite>-th axis.</li>
<li><cite>n</cite> ints: same as an n-tuple of the same ints (this form is
intended simply as a &#8220;convenience&#8221; alternative to the tuple form)</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>Copy of <cite>a</cite>, with axes suitably permuted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.SciDBArray.var">
<tt class="descname">var</tt><big>(</big><em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.SciDBArray.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the variance of the array or the variance along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int, optional</p>
<blockquote>
<div><p>Axis along which to operate. By default, flattened input is used.</p>
</div></blockquote>
<p><strong>scidb_syntax</strong> : bool, optional (default=False)</p>
<blockquote>
<div><p>If False, index follows the numpy convention
(i.e., the array is collapsed over the index&#8217;th axis).
If True, index follows the SciDB convention
(i.e., the array is collapsed over all axes <em>except</em> index)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A SciDB array</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="scidb-interface">
<h2>SciDB Interface<a class="headerlink" href="#scidb-interface" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="scidbpy.interface.connect">
<tt class="descclassname">scidbpy.interface.</tt><tt class="descname">connect</tt><big>(</big><em>url=None</em><big>)</big><a class="headerlink" href="#scidbpy.interface.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect to a SciDB instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>url</strong> : str (optional)</p>
<blockquote class="last">
<div><p>Connection URL. If not provided, will fall back to
the SCIDB_URL environment variable (if present),
or <a class="reference external" href="http://127.0.0.1:8080">http://127.0.0.1:8080</a></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="base-class">
<h3>Base Class<a class="headerlink" href="#base-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="scidbpy.interface.SciDBInterface">
<em class="property">class </em><tt class="descclassname">scidbpy.interface.</tt><tt class="descname">SciDBInterface</tt><a class="headerlink" href="#scidbpy.interface.SciDBInterface" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.acos" title="scidbpy.interface.SciDBInterface.acos"><tt class="xref py py-obj docutils literal"><span class="pre">acos</span></tt></a>(A)</td>
<td>Element-wise trigonometric inverse cosine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.approxdc" title="scidbpy.interface.SciDBInterface.approxdc"><tt class="xref py py-obj docutils literal"><span class="pre">approxdc</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis unique element estimate.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.arange" title="scidbpy.interface.SciDBInterface.arange"><tt class="xref py py-obj docutils literal"><span class="pre">arange</span></tt></a>([start,]&nbsp;stop[,&nbsp;step,][,&nbsp;dtype])</td>
<td>Return evenly spaced values within a given interval.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.asin" title="scidbpy.interface.SciDBInterface.asin"><tt class="xref py py-obj docutils literal"><span class="pre">asin</span></tt></a>(A)</td>
<td>Element-wise trigonometric inverse sine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.atan" title="scidbpy.interface.SciDBInterface.atan"><tt class="xref py py-obj docutils literal"><span class="pre">atan</span></tt></a>(A)</td>
<td>Element-wise trigonometric inverse tangent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.avg" title="scidbpy.interface.SciDBInterface.avg"><tt class="xref py py-obj docutils literal"><span class="pre">avg</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis average.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.ceil" title="scidbpy.interface.SciDBInterface.ceil"><tt class="xref py py-obj docutils literal"><span class="pre">ceil</span></tt></a>(A)</td>
<td>Element-wise ceiling function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.cos" title="scidbpy.interface.SciDBInterface.cos"><tt class="xref py py-obj docutils literal"><span class="pre">cos</span></tt></a>(A)</td>
<td>Element-wise trigonometric cosine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.count" title="scidbpy.interface.SciDBInterface.count"><tt class="xref py py-obj docutils literal"><span class="pre">count</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis count.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.cross_join" title="scidbpy.interface.SciDBInterface.cross_join"><tt class="xref py py-obj docutils literal"><span class="pre">cross_join</span></tt></a>(A,&nbsp;B,&nbsp;*dims)</td>
<td>Perform a cross-join on arrays A and B.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.dot" title="scidbpy.interface.SciDBInterface.dot"><tt class="xref py py-obj docutils literal"><span class="pre">dot</span></tt></a>(A,&nbsp;B)</td>
<td>Compute the matrix product of A and B</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.exp" title="scidbpy.interface.SciDBInterface.exp"><tt class="xref py py-obj docutils literal"><span class="pre">exp</span></tt></a>(A)</td>
<td>Element-wise natural exponent</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.floor" title="scidbpy.interface.SciDBInterface.floor"><tt class="xref py py-obj docutils literal"><span class="pre">floor</span></tt></a>(A)</td>
<td>Element-wise floor function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.from_array" title="scidbpy.interface.SciDBInterface.from_array"><tt class="xref py py-obj docutils literal"><span class="pre">from_array</span></tt></a>(A[,&nbsp;instance_id])</td>
<td>Initialize a scidb array from a numpy array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.from_dataframe" title="scidbpy.interface.SciDBInterface.from_dataframe"><tt class="xref py py-obj docutils literal"><span class="pre">from_dataframe</span></tt></a>(A[,&nbsp;instance_id])</td>
<td>Initialize a scidb array from a pandas dataframe</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.from_sparse" title="scidbpy.interface.SciDBInterface.from_sparse"><tt class="xref py py-obj docutils literal"><span class="pre">from_sparse</span></tt></a>(A[,&nbsp;instance_id])</td>
<td>Initialize a scidb array from a sparse array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.identity" title="scidbpy.interface.SciDBInterface.identity"><tt class="xref py py-obj docutils literal"><span class="pre">identity</span></tt></a>(n[,&nbsp;dtype,&nbsp;sparse])</td>
<td>Return a 2-dimensional square identity matrix of size n</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.isnan" title="scidbpy.interface.SciDBInterface.isnan"><tt class="xref py py-obj docutils literal"><span class="pre">isnan</span></tt></a>(A)</td>
<td>Element-wise nan test function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.join" title="scidbpy.interface.SciDBInterface.join"><tt class="xref py py-obj docutils literal"><span class="pre">join</span></tt></a>(*args)</td>
<td>Perform a series of array joins on the arguments and return the result.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.linspace" title="scidbpy.interface.SciDBInterface.linspace"><tt class="xref py py-obj docutils literal"><span class="pre">linspace</span></tt></a>(start,&nbsp;stop[,&nbsp;num,&nbsp;endpoint,&nbsp;retstep])</td>
<td>Return evenly spaced numbers over a specified interval.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.list_arrays" title="scidbpy.interface.SciDBInterface.list_arrays"><tt class="xref py py-obj docutils literal"><span class="pre">list_arrays</span></tt></a>([parsed,&nbsp;n])</td>
<td>List the arrays currently in the database</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.log" title="scidbpy.interface.SciDBInterface.log"><tt class="xref py py-obj docutils literal"><span class="pre">log</span></tt></a>(A)</td>
<td>Element-wise natural logarithm</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.log10" title="scidbpy.interface.SciDBInterface.log10"><tt class="xref py py-obj docutils literal"><span class="pre">log10</span></tt></a>(A)</td>
<td>Element-wise base-10 logarithm</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.max" title="scidbpy.interface.SciDBInterface.max"><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis maximum.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.mean" title="scidbpy.interface.SciDBInterface.mean"><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis mean.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.merge" title="scidbpy.interface.SciDBInterface.merge"><tt class="xref py py-obj docutils literal"><span class="pre">merge</span></tt></a>(A,&nbsp;B)</td>
<td>Merge two arrays</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.min" title="scidbpy.interface.SciDBInterface.min"><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis minimum.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.new_array" title="scidbpy.interface.SciDBInterface.new_array"><tt class="xref py py-obj docutils literal"><span class="pre">new_array</span></tt></a>([shape,&nbsp;dtype,&nbsp;persistent])</td>
<td>Create a new array, either instantiating it in SciDB or simply reserving the name for use in a later query.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.ones" title="scidbpy.interface.SciDBInterface.ones"><tt class="xref py py-obj docutils literal"><span class="pre">ones</span></tt></a>(shape[,&nbsp;dtype])</td>
<td>Return an array of ones</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.query" title="scidbpy.interface.SciDBInterface.query"><tt class="xref py py-obj docutils literal"><span class="pre">query</span></tt></a>(query,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Perform a query on the database.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.randint" title="scidbpy.interface.SciDBInterface.randint"><tt class="xref py py-obj docutils literal"><span class="pre">randint</span></tt></a>(shape[,&nbsp;dtype,&nbsp;lower,&nbsp;upper,&nbsp;persistent])</td>
<td>Return an array of random integers between lower and upper</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.random" title="scidbpy.interface.SciDBInterface.random"><tt class="xref py py-obj docutils literal"><span class="pre">random</span></tt></a>(shape[,&nbsp;dtype,&nbsp;lower,&nbsp;upper,&nbsp;persistent])</td>
<td>Return an array of random floats between lower and upper</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.reap" title="scidbpy.interface.SciDBInterface.reap"><tt class="xref py py-obj docutils literal"><span class="pre">reap</span></tt></a>()</td>
<td>Reap all arrays created via new_array</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.sin" title="scidbpy.interface.SciDBInterface.sin"><tt class="xref py py-obj docutils literal"><span class="pre">sin</span></tt></a>(A)</td>
<td>Element-wise trigonometric sine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.sqrt" title="scidbpy.interface.SciDBInterface.sqrt"><tt class="xref py py-obj docutils literal"><span class="pre">sqrt</span></tt></a>(A)</td>
<td>Element-wise square root</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.std" title="scidbpy.interface.SciDBInterface.std"><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis standard deviation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.stdev" title="scidbpy.interface.SciDBInterface.stdev"><tt class="xref py py-obj docutils literal"><span class="pre">stdev</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis standard deviation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.substitute" title="scidbpy.interface.SciDBInterface.substitute"><tt class="xref py py-obj docutils literal"><span class="pre">substitute</span></tt></a>(A,&nbsp;value)</td>
<td>Replace null values in an array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.sum" title="scidbpy.interface.SciDBInterface.sum"><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis sum.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.svd" title="scidbpy.interface.SciDBInterface.svd"><tt class="xref py py-obj docutils literal"><span class="pre">svd</span></tt></a>(A[,&nbsp;return_U,&nbsp;return_S,&nbsp;return_VT])</td>
<td>Compute the Singular Value Decomposition of the array A:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.tan" title="scidbpy.interface.SciDBInterface.tan"><tt class="xref py py-obj docutils literal"><span class="pre">tan</span></tt></a>(A)</td>
<td>Element-wise trigonometric tangent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.toarray" title="scidbpy.interface.SciDBInterface.toarray"><tt class="xref py py-obj docutils literal"><span class="pre">toarray</span></tt></a>(A[,&nbsp;transfer_bytes])</td>
<td>Convert a SciDB array to a numpy array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.todataframe" title="scidbpy.interface.SciDBInterface.todataframe"><tt class="xref py py-obj docutils literal"><span class="pre">todataframe</span></tt></a>(A[,&nbsp;transfer_bytes])</td>
<td>Convert a SciDB array to a pandas dataframe</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.tosparse" title="scidbpy.interface.SciDBInterface.tosparse"><tt class="xref py py-obj docutils literal"><span class="pre">tosparse</span></tt></a>(A[,&nbsp;sparse_fmt,&nbsp;transfer_bytes])</td>
<td>Convert a SciDB array to a sparse representation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.var" title="scidbpy.interface.SciDBInterface.var"><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis variance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.wrap_array" title="scidbpy.interface.SciDBInterface.wrap_array"><tt class="xref py py-obj docutils literal"><span class="pre">wrap_array</span></tt></a>(scidbname[,&nbsp;persistent])</td>
<td>Create a new SciDBArray object that references an existing SciDB</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBInterface.zeros" title="scidbpy.interface.SciDBInterface.zeros"><tt class="xref py py-obj docutils literal"><span class="pre">zeros</span></tt></a>(shape[,&nbsp;dtype])</td>
<td>Return an array of zeros</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.acos">
<tt class="descname">acos</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.acos" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric inverse cosine</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.approxdc">
<tt class="descname">approxdc</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.approxdc" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis unique element estimate.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.approxdc()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.arange">
<tt class="descname">arange</tt><big>(</big><span class="optional">[</span><em>start</em>, <span class="optional">]</span><em>stop</em>, <span class="optional">[</span><em>step</em>, <span class="optional">]</span><em>dtype=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced values within a given interval.</p>
<p>Values are generated within the half-open interval <tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop)</span></tt>
(in other words, the interval including <cite>start</cite> but excluding <cite>stop</cite>).
For integer arguments the behavior is equivalent to the Python
<a class="reference external" href="http://docs.python.org/lib/built-in-funcs.html">range</a> function,
but returns an ndarray rather than a list.</p>
<p>When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use <tt class="docutils literal"><span class="pre">linspace</span></tt> for these cases.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>start</strong> : number, optional</p>
<blockquote>
<div><p>Start of interval.  The interval includes this value.  The default
start value is 0.</p>
</div></blockquote>
<p><strong>stop</strong> : number</p>
<blockquote>
<div><p>End of interval.  The interval does not include this value, except
in some cases where <cite>step</cite> is not an integer and floating point
round-off affects the length of <cite>out</cite>.</p>
</div></blockquote>
<p><strong>step</strong> : number, optional</p>
<blockquote>
<div><p>Spacing between values.  For any output <cite>out</cite>, this is the distance
between two adjacent values, <tt class="docutils literal"><span class="pre">out[i+1]</span> <span class="pre">-</span> <span class="pre">out[i]</span></tt>.  The default
step size is 1.  If <cite>step</cite> is specified, <cite>start</cite> must also be
given.</p>
</div></blockquote>
<p><strong>dtype</strong> : dtype</p>
<blockquote>
<div><p>The type of the output array.  If <cite>dtype</cite> is not given, it is
inferred from the type of the input arguments.</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional arguments are passed to SciDBDatashape when creating
the output array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arange</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>Array of evenly spaced values.</p>
<p>For floating point arguments, the length of the result is
<tt class="docutils literal"><span class="pre">ceil((stop</span> <span class="pre">-</span> <span class="pre">start)/step)</span></tt>.  Because of floating point overflow,
this rule may result in the last element of <cite>out</cite> being greater
than <cite>stop</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.asin">
<tt class="descname">asin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric inverse sine</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.atan">
<tt class="descname">atan</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.atan" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric inverse tangent</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.avg">
<tt class="descname">avg</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.avg" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis average.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.avg()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.ceil">
<tt class="descname">ceil</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise ceiling function</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.cos">
<tt class="descname">cos</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric cosine</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.count">
<tt class="descname">count</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis count.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.count()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.cross_join">
<tt class="descname">cross_join</tt><big>(</big><em>A</em>, <em>B</em>, <em>*dims</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.cross_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a cross-join on arrays A and B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A, B</strong> : SciDBArray</p>
<p><strong>*dims</strong> : tuples</p>
<blockquote class="last">
<div><p>The remaining arguments are tuples of dimension indices which
should be joined.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.dot">
<tt class="descname">dot</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix product of A and B</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : SciDBArray</p>
<blockquote>
<div><p>A must be a two-dimensional matrix of shape (n, p)</p>
</div></blockquote>
<p><strong>B</strong> : SciDBArray</p>
<blockquote>
<div><p>B must be a two-dimensional matrix of shape (p, m)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>The wrapper of the SciDB Array, of shape (n, m), consisting of the
matrix product of A and B</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.exp">
<tt class="descname">exp</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise natural exponent</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.floor">
<tt class="descname">floor</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise floor function</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.from_array">
<tt class="descname">from_array</tt><big>(</big><em>A</em>, <em>instance_id=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.from_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a scidb array from a numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : array_like (numpy array or sparse array)</p>
<blockquote>
<div><p>input array from which the scidb array will be created</p>
</div></blockquote>
<p><strong>instance_id</strong> : integer</p>
<blockquote>
<div><p>the instance ID used in loading
(default=0; see SciDB documentation)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to new_array()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>SciDB Array object built from the input array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.from_dataframe">
<tt class="descname">from_dataframe</tt><big>(</big><em>A</em>, <em>instance_id=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.from_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a scidb array from a pandas dataframe</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : pandas dataframe</p>
<blockquote>
<div><p>data from which the scidb array will be created.</p>
</div></blockquote>
<p><strong>instance_id</strong> : integer</p>
<blockquote>
<div><p>the instance ID used in loading
(default=0; see SciDB documentation)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to new_array()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>SciDB Array object built from the input array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.from_sparse">
<tt class="descname">from_sparse</tt><big>(</big><em>A</em>, <em>instance_id=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.from_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a scidb array from a sparse array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : sparse array</p>
<blockquote>
<div><p>sparse input array from which the scidb array will be created.
Note that this array will internally be converted to COO format.</p>
</div></blockquote>
<p><strong>instance_id</strong> : integer</p>
<blockquote>
<div><p>the instance ID used in loading
(default=0; see SciDB documentation)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to new_array()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>SciDB Array object built from the input array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.identity">
<tt class="descname">identity</tt><big>(</big><em>n</em>, <em>dtype=u'double'</em>, <em>sparse=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2-dimensional square identity matrix of size n</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : integer</p>
<blockquote>
<div><p>the number of rows and columns in the matrix</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>sparse</strong> : boolean</p>
<blockquote>
<div><p>specify whether to create a sparse array (default=False)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>A SciDBArray containint an [n x n] identity matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.isnan">
<tt class="descname">isnan</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.isnan" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise nan test function</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.join">
<tt class="descname">join</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a series of array joins on the arguments
and return the result.</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.linspace">
<tt class="descname">linspace</tt><big>(</big><em>start</em>, <em>stop</em>, <em>num=50</em>, <em>endpoint=True</em>, <em>retstep=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced numbers over a specified interval.</p>
<p>Returns <cite>num</cite> evenly spaced samples, calculated over the
interval [<cite>start</cite>, <cite>stop</cite> ].</p>
<p>The endpoint of the interval can optionally be excluded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>start</strong> : scalar</p>
<blockquote>
<div><p>The starting value of the sequence.</p>
</div></blockquote>
<p><strong>stop</strong> : scalar</p>
<blockquote>
<div><p>The end value of the sequence, unless <cite>endpoint</cite> is set to False.
In that case, the sequence consists of all but the last of
<tt class="docutils literal"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></tt> evenly spaced samples, so that <cite>stop</cite> is excluded.
Note that the step size changes when <cite>endpoint</cite> is False.</p>
</div></blockquote>
<p><strong>num</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to generate. Default is 50.</p>
</div></blockquote>
<p><strong>endpoint</strong> : bool, optional</p>
<blockquote>
<div><p>If True, <cite>stop</cite> is the last sample. Otherwise, it is not included.
Default is True.</p>
</div></blockquote>
<p><strong>retstep</strong> : bool, optional</p>
<blockquote>
<div><p>If True, return (<cite>samples</cite>, <cite>step</cite>), where <cite>step</cite> is the spacing
between samples.</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>additional keyword arguments are passed to SciDBDataShape</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>samples</strong> : SciDBArray</p>
<blockquote>
<div><p>There are <cite>num</cite> equally spaced samples in the closed interval
<tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop]</span></tt> or the half-open interval <tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop)</span></tt>
(depending on whether <cite>endpoint</cite> is True or False).</p>
</div></blockquote>
<p><strong>step</strong> : float (only if <cite>retstep</cite> is True)</p>
<blockquote class="last">
<div><p>Size of spacing between samples.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.list_arrays">
<tt class="descname">list_arrays</tt><big>(</big><em>parsed=True</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.list_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>List the arrays currently in the database</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parsed</strong> : boolean</p>
<blockquote>
<div><p>If True (default), then parse the results into a dictionary of
array names as keys, schema as values</p>
</div></blockquote>
<p><strong>n</strong> : integer</p>
<blockquote>
<div><p>the maximum number of arrays to list.  If n=0, then list all</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>array_list</strong> : string or dictionary</p>
<blockquote class="last">
<div><p>The list of arrays.  If parsed=True, then the result is returned
as a dictionary.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.log">
<tt class="descname">log</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise natural logarithm</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.log10">
<tt class="descname">log10</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise base-10 logarithm</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.max">
<tt class="descname">max</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis maximum.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.max()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.mean">
<tt class="descname">mean</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis mean.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.mean()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.merge">
<tt class="descname">merge</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge two arrays</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.min">
<tt class="descname">min</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis minimum.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.min()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.new_array">
<tt class="descname">new_array</tt><big>(</big><em>shape=None</em>, <em>dtype=u'double'</em>, <em>persistent=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.new_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new array, either instantiating it in SciDB or simply
reserving the name for use in a later query.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : int or tuple (optional)</p>
<blockquote>
<div><p>The shape of the array to create.  If not specified, no array
will be created and a name will simply be reserved for later use.
WARNING: if shape=None and persistent=False, an error will result
when the array goes out of scope, unless the name is used to
create an array on the server.</p>
</div></blockquote>
<p><strong>dtype</strong> : string (optional)</p>
<blockquote>
<div><p>the datatype of the array.  This is only referenced if <cite>shape</cite>
is specified.  Default is &#8216;double&#8217;.</p>
</div></blockquote>
<p><strong>persistent</strong> : boolean (optional)</p>
<blockquote>
<div><p>whether the created array should be persistent, i.e. survive
in SciDB past when the object wrapper goes out of scope.  Default
is False.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : (optional)</p>
<blockquote>
<div><p>If <cite>shape</cite> is specified, additional keyword arguments are passed
to SciDBDataShape.  Otherwise, these will not be referenced.</p>
</div></blockquote>
<p><strong>Returns</strong> :</p>
<p><strong>&#8212;&#8212;-</strong> :</p>
<p><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>wrapper of the new SciDB array instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.ones">
<tt class="descname">ones</tt><big>(</big><em>shape</em>, <em>dtype=u'double'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of ones</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple or int</p>
<blockquote>
<div><p>The shape of the array</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr: SciDBArray</strong> :</p>
<blockquote class="last">
<div><p>A SciDBArray consisting of all ones.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.query">
<tt class="descname">query</tt><big>(</big><em>query</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a query on the database.</p>
<p>This wraps a query constructor which allows the creation of
sophisticated SciDB queries which act on arrays wrapped by SciDBArray
objects.  See Notes below for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>query</strong> : string</p>
<blockquote>
<div><p>The query string, with curly-braces to indicate insertions</p>
</div></blockquote>
<p><strong>*args, **kwargs :</strong> :</p>
<blockquote class="last">
<div><p>Values to be inserted (see below).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.randint">
<tt class="descname">randint</tt><big>(</big><em>shape</em>, <em>dtype=u'uint32'</em>, <em>lower=0</em>, <em>upper=2147483647</em>, <em>persistent=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.randint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of random integers between lower and upper</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple or int</p>
<blockquote>
<div><p>The shape of the array</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>lower</strong> : float</p>
<blockquote>
<div><p>The lower bound of the random sample (default=0)</p>
</div></blockquote>
<p><strong>upper</strong> : float</p>
<blockquote>
<div><p>The upper bound of the random sample (default=2147483647)</p>
</div></blockquote>
<p><strong>persistent</strong> : bool</p>
<blockquote>
<div><p>Whether the array is persistent (default=False)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr: SciDBArray</strong> :</p>
<blockquote class="last">
<div><p>A SciDBArray consisting of random integers, uniformly distributed
between <cite>lower</cite> and <cite>upper</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.random">
<tt class="descname">random</tt><big>(</big><em>shape</em>, <em>dtype=u'double'</em>, <em>lower=0</em>, <em>upper=1</em>, <em>persistent=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of random floats between lower and upper</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple or int</p>
<blockquote>
<div><p>The shape of the array</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>lower</strong> : float</p>
<blockquote>
<div><p>The lower bound of the random sample (default=0)</p>
</div></blockquote>
<p><strong>upper</strong> : float</p>
<blockquote>
<div><p>The upper bound of the random sample (default=1)</p>
</div></blockquote>
<p><strong>persistent</strong> : bool</p>
<blockquote>
<div><p>Whether the new array is persistent (default=False)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr: SciDBArray</strong> :</p>
<blockquote class="last">
<div><p>A SciDBArray consisting of random floating point numbers,
uniformly distributed between <cite>lower</cite> and <cite>upper</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.reap">
<tt class="descname">reap</tt><big>(</big><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.reap" title="Permalink to this definition">¶</a></dt>
<dd><p>Reap all arrays created via new_array</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.sin">
<tt class="descname">sin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric sine</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.sqrt">
<tt class="descname">sqrt</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise square root</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.std">
<tt class="descname">std</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis standard deviation.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.std()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.stdev">
<tt class="descname">stdev</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis standard deviation.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.stdev()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.substitute">
<tt class="descname">substitute</tt><big>(</big><em>A</em>, <em>value</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace null values in an array</p>
<p>See <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.substitute()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.sum">
<tt class="descname">sum</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis sum.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.sum()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.svd">
<tt class="descname">svd</tt><big>(</big><em>A</em>, <em>return_U=True</em>, <em>return_S=True</em>, <em>return_VT=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Singular Value Decomposition of the array A:</p>
<p>A = U.S.V^T</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : SciDBArray</p>
<blockquote>
<div><p>The array for which the SVD will be computed.  It should be a
2-dimensional array with a single value per cell.  Currently, the
svd routine requires non-overlapping chunks of size 32.</p>
</div></blockquote>
<p><strong>return_U, return_S, return_VT</strong> : boolean</p>
<blockquote>
<div><p>if any is True, then return the associated array.  All are True
by default</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>[U], [S], [VT]</strong> : SciDBArrays</p>
<blockquote class="last">
<div><p>Arrays storing the singular values and vectors of A.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.tan">
<tt class="descname">tan</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric tangent</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.toarray">
<tt class="descname">toarray</tt><big>(</big><em>A</em>, <em>transfer_bytes=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.toarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a SciDB array to a numpy array</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.todataframe">
<tt class="descname">todataframe</tt><big>(</big><em>A</em>, <em>transfer_bytes=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.todataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a SciDB array to a pandas dataframe</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.tosparse">
<tt class="descname">tosparse</tt><big>(</big><em>A</em>, <em>sparse_fmt=u'recarray'</em>, <em>transfer_bytes=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.tosparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a SciDB array to a sparse representation</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.var">
<tt class="descname">var</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis variance.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.var()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.wrap_array">
<tt class="descname">wrap_array</tt><big>(</big><em>scidbname</em>, <em>persistent=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.wrap_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new SciDBArray object that references an existing SciDB
array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scidbname</strong> : string</p>
<blockquote>
<div><p>Wrap an existing scidb array referred to by <cite>scidbname</cite>. The
SciDB array object persistent value will be set to True, and
the object shape, datashape and data type values will be
determined by the SciDB array.</p>
</div></blockquote>
<p><strong>persistent</strong> : boolean</p>
<blockquote class="last">
<div><p>If True (default) then array will not be deleted when this
variable goes out of scope. Warning: if persistent is set to
False, data could be lost!</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBInterface.zeros">
<tt class="descname">zeros</tt><big>(</big><em>shape</em>, <em>dtype=u'double'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBInterface.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple or int</p>
<blockquote>
<div><p>The shape of the array</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr: SciDBArray</strong> :</p>
<blockquote class="last">
<div><p>A SciDBArray consisting of all zeros.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="shim-interface">
<h3>Shim Interface<a class="headerlink" href="#shim-interface" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="scidbpy.interface.SciDBShimInterface">
<em class="property">class </em><tt class="descclassname">scidbpy.interface.</tt><tt class="descname">SciDBShimInterface</tt><big>(</big><em>hostname</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface" title="Permalink to this definition">¶</a></dt>
<dd><p>HTTP interface to SciDB via shim <a href="#id3"><span class="problematic" id="id4"><span id="id1"></span>[1]_</span></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>hostname</strong> : string</p>
<blockquote>
<div><p>A URL pointing to a running shim/SciDB session</p>
</div></blockquote>
<p class="last"><strong>[1] https://github.com/Paradigm4/shim</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.acos" title="scidbpy.interface.SciDBShimInterface.acos"><tt class="xref py py-obj docutils literal"><span class="pre">acos</span></tt></a>(A)</td>
<td>Element-wise trigonometric inverse cosine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.approxdc" title="scidbpy.interface.SciDBShimInterface.approxdc"><tt class="xref py py-obj docutils literal"><span class="pre">approxdc</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis unique element estimate.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.arange" title="scidbpy.interface.SciDBShimInterface.arange"><tt class="xref py py-obj docutils literal"><span class="pre">arange</span></tt></a>([start,]&nbsp;stop[,&nbsp;step,][,&nbsp;dtype])</td>
<td>Return evenly spaced values within a given interval.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.asin" title="scidbpy.interface.SciDBShimInterface.asin"><tt class="xref py py-obj docutils literal"><span class="pre">asin</span></tt></a>(A)</td>
<td>Element-wise trigonometric inverse sine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.atan" title="scidbpy.interface.SciDBShimInterface.atan"><tt class="xref py py-obj docutils literal"><span class="pre">atan</span></tt></a>(A)</td>
<td>Element-wise trigonometric inverse tangent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.avg" title="scidbpy.interface.SciDBShimInterface.avg"><tt class="xref py py-obj docutils literal"><span class="pre">avg</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis average.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.ceil" title="scidbpy.interface.SciDBShimInterface.ceil"><tt class="xref py py-obj docutils literal"><span class="pre">ceil</span></tt></a>(A)</td>
<td>Element-wise ceiling function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.cos" title="scidbpy.interface.SciDBShimInterface.cos"><tt class="xref py py-obj docutils literal"><span class="pre">cos</span></tt></a>(A)</td>
<td>Element-wise trigonometric cosine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.count" title="scidbpy.interface.SciDBShimInterface.count"><tt class="xref py py-obj docutils literal"><span class="pre">count</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis count.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.cross_join" title="scidbpy.interface.SciDBShimInterface.cross_join"><tt class="xref py py-obj docutils literal"><span class="pre">cross_join</span></tt></a>(A,&nbsp;B,&nbsp;*dims)</td>
<td>Perform a cross-join on arrays A and B.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.dot" title="scidbpy.interface.SciDBShimInterface.dot"><tt class="xref py py-obj docutils literal"><span class="pre">dot</span></tt></a>(A,&nbsp;B)</td>
<td>Compute the matrix product of A and B</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.exp" title="scidbpy.interface.SciDBShimInterface.exp"><tt class="xref py py-obj docutils literal"><span class="pre">exp</span></tt></a>(A)</td>
<td>Element-wise natural exponent</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.floor" title="scidbpy.interface.SciDBShimInterface.floor"><tt class="xref py py-obj docutils literal"><span class="pre">floor</span></tt></a>(A)</td>
<td>Element-wise floor function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.from_array" title="scidbpy.interface.SciDBShimInterface.from_array"><tt class="xref py py-obj docutils literal"><span class="pre">from_array</span></tt></a>(A[,&nbsp;instance_id])</td>
<td>Initialize a scidb array from a numpy array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.from_dataframe" title="scidbpy.interface.SciDBShimInterface.from_dataframe"><tt class="xref py py-obj docutils literal"><span class="pre">from_dataframe</span></tt></a>(A[,&nbsp;instance_id])</td>
<td>Initialize a scidb array from a pandas dataframe</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.from_sparse" title="scidbpy.interface.SciDBShimInterface.from_sparse"><tt class="xref py py-obj docutils literal"><span class="pre">from_sparse</span></tt></a>(A[,&nbsp;instance_id])</td>
<td>Initialize a scidb array from a sparse array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.identity" title="scidbpy.interface.SciDBShimInterface.identity"><tt class="xref py py-obj docutils literal"><span class="pre">identity</span></tt></a>(n[,&nbsp;dtype,&nbsp;sparse])</td>
<td>Return a 2-dimensional square identity matrix of size n</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.isnan" title="scidbpy.interface.SciDBShimInterface.isnan"><tt class="xref py py-obj docutils literal"><span class="pre">isnan</span></tt></a>(A)</td>
<td>Element-wise nan test function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.join" title="scidbpy.interface.SciDBShimInterface.join"><tt class="xref py py-obj docutils literal"><span class="pre">join</span></tt></a>(*args)</td>
<td>Perform a series of array joins on the arguments and return the result.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.linspace" title="scidbpy.interface.SciDBShimInterface.linspace"><tt class="xref py py-obj docutils literal"><span class="pre">linspace</span></tt></a>(start,&nbsp;stop[,&nbsp;num,&nbsp;endpoint,&nbsp;retstep])</td>
<td>Return evenly spaced numbers over a specified interval.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.list_arrays" title="scidbpy.interface.SciDBShimInterface.list_arrays"><tt class="xref py py-obj docutils literal"><span class="pre">list_arrays</span></tt></a>([parsed,&nbsp;n])</td>
<td>List the arrays currently in the database</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.log" title="scidbpy.interface.SciDBShimInterface.log"><tt class="xref py py-obj docutils literal"><span class="pre">log</span></tt></a>(A)</td>
<td>Element-wise natural logarithm</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.log10" title="scidbpy.interface.SciDBShimInterface.log10"><tt class="xref py py-obj docutils literal"><span class="pre">log10</span></tt></a>(A)</td>
<td>Element-wise base-10 logarithm</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.max" title="scidbpy.interface.SciDBShimInterface.max"><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis maximum.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.mean" title="scidbpy.interface.SciDBShimInterface.mean"><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis mean.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.merge" title="scidbpy.interface.SciDBShimInterface.merge"><tt class="xref py py-obj docutils literal"><span class="pre">merge</span></tt></a>(A,&nbsp;B)</td>
<td>Merge two arrays</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.min" title="scidbpy.interface.SciDBShimInterface.min"><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis minimum.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.new_array" title="scidbpy.interface.SciDBShimInterface.new_array"><tt class="xref py py-obj docutils literal"><span class="pre">new_array</span></tt></a>([shape,&nbsp;dtype,&nbsp;persistent])</td>
<td>Create a new array, either instantiating it in SciDB or simply reserving the name for use in a later query.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.ones" title="scidbpy.interface.SciDBShimInterface.ones"><tt class="xref py py-obj docutils literal"><span class="pre">ones</span></tt></a>(shape[,&nbsp;dtype])</td>
<td>Return an array of ones</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.query" title="scidbpy.interface.SciDBShimInterface.query"><tt class="xref py py-obj docutils literal"><span class="pre">query</span></tt></a>(query,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Perform a query on the database.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.randint" title="scidbpy.interface.SciDBShimInterface.randint"><tt class="xref py py-obj docutils literal"><span class="pre">randint</span></tt></a>(shape[,&nbsp;dtype,&nbsp;lower,&nbsp;upper,&nbsp;persistent])</td>
<td>Return an array of random integers between lower and upper</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.random" title="scidbpy.interface.SciDBShimInterface.random"><tt class="xref py py-obj docutils literal"><span class="pre">random</span></tt></a>(shape[,&nbsp;dtype,&nbsp;lower,&nbsp;upper,&nbsp;persistent])</td>
<td>Return an array of random floats between lower and upper</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.reap" title="scidbpy.interface.SciDBShimInterface.reap"><tt class="xref py py-obj docutils literal"><span class="pre">reap</span></tt></a>()</td>
<td>Reap all arrays created via new_array</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.sin" title="scidbpy.interface.SciDBShimInterface.sin"><tt class="xref py py-obj docutils literal"><span class="pre">sin</span></tt></a>(A)</td>
<td>Element-wise trigonometric sine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.sqrt" title="scidbpy.interface.SciDBShimInterface.sqrt"><tt class="xref py py-obj docutils literal"><span class="pre">sqrt</span></tt></a>(A)</td>
<td>Element-wise square root</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.std" title="scidbpy.interface.SciDBShimInterface.std"><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis standard deviation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.stdev" title="scidbpy.interface.SciDBShimInterface.stdev"><tt class="xref py py-obj docutils literal"><span class="pre">stdev</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis standard deviation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.substitute" title="scidbpy.interface.SciDBShimInterface.substitute"><tt class="xref py py-obj docutils literal"><span class="pre">substitute</span></tt></a>(A,&nbsp;value)</td>
<td>Replace null values in an array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.sum" title="scidbpy.interface.SciDBShimInterface.sum"><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis sum.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.svd" title="scidbpy.interface.SciDBShimInterface.svd"><tt class="xref py py-obj docutils literal"><span class="pre">svd</span></tt></a>(A[,&nbsp;return_U,&nbsp;return_S,&nbsp;return_VT])</td>
<td>Compute the Singular Value Decomposition of the array A:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.tan" title="scidbpy.interface.SciDBShimInterface.tan"><tt class="xref py py-obj docutils literal"><span class="pre">tan</span></tt></a>(A)</td>
<td>Element-wise trigonometric tangent</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.toarray" title="scidbpy.interface.SciDBShimInterface.toarray"><tt class="xref py py-obj docutils literal"><span class="pre">toarray</span></tt></a>(A[,&nbsp;transfer_bytes])</td>
<td>Convert a SciDB array to a numpy array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.todataframe" title="scidbpy.interface.SciDBShimInterface.todataframe"><tt class="xref py py-obj docutils literal"><span class="pre">todataframe</span></tt></a>(A[,&nbsp;transfer_bytes])</td>
<td>Convert a SciDB array to a pandas dataframe</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.tosparse" title="scidbpy.interface.SciDBShimInterface.tosparse"><tt class="xref py py-obj docutils literal"><span class="pre">tosparse</span></tt></a>(A[,&nbsp;sparse_fmt,&nbsp;transfer_bytes])</td>
<td>Convert a SciDB array to a sparse representation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.var" title="scidbpy.interface.SciDBShimInterface.var"><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt></a>(A[,&nbsp;index,&nbsp;scidb_syntax])</td>
<td>Array or axis variance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.wrap_array" title="scidbpy.interface.SciDBShimInterface.wrap_array"><tt class="xref py py-obj docutils literal"><span class="pre">wrap_array</span></tt></a>(scidbname[,&nbsp;persistent])</td>
<td>Create a new SciDBArray object that references an existing SciDB</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.interface.SciDBShimInterface.zeros" title="scidbpy.interface.SciDBShimInterface.zeros"><tt class="xref py py-obj docutils literal"><span class="pre">zeros</span></tt></a>(shape[,&nbsp;dtype])</td>
<td>Return an array of zeros</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.acos">
<tt class="descname">acos</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.acos" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric inverse cosine</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.approxdc">
<tt class="descname">approxdc</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.approxdc" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis unique element estimate.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.approxdc()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.arange">
<tt class="descname">arange</tt><big>(</big><span class="optional">[</span><em>start</em>, <span class="optional">]</span><em>stop</em>, <span class="optional">[</span><em>step</em>, <span class="optional">]</span><em>dtype=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced values within a given interval.</p>
<p>Values are generated within the half-open interval <tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop)</span></tt>
(in other words, the interval including <cite>start</cite> but excluding <cite>stop</cite>).
For integer arguments the behavior is equivalent to the Python
<a class="reference external" href="http://docs.python.org/lib/built-in-funcs.html">range</a> function,
but returns an ndarray rather than a list.</p>
<p>When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use <tt class="docutils literal"><span class="pre">linspace</span></tt> for these cases.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>start</strong> : number, optional</p>
<blockquote>
<div><p>Start of interval.  The interval includes this value.  The default
start value is 0.</p>
</div></blockquote>
<p><strong>stop</strong> : number</p>
<blockquote>
<div><p>End of interval.  The interval does not include this value, except
in some cases where <cite>step</cite> is not an integer and floating point
round-off affects the length of <cite>out</cite>.</p>
</div></blockquote>
<p><strong>step</strong> : number, optional</p>
<blockquote>
<div><p>Spacing between values.  For any output <cite>out</cite>, this is the distance
between two adjacent values, <tt class="docutils literal"><span class="pre">out[i+1]</span> <span class="pre">-</span> <span class="pre">out[i]</span></tt>.  The default
step size is 1.  If <cite>step</cite> is specified, <cite>start</cite> must also be
given.</p>
</div></blockquote>
<p><strong>dtype</strong> : dtype</p>
<blockquote>
<div><p>The type of the output array.  If <cite>dtype</cite> is not given, it is
inferred from the type of the input arguments.</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional arguments are passed to SciDBDatashape when creating
the output array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arange</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>Array of evenly spaced values.</p>
<p>For floating point arguments, the length of the result is
<tt class="docutils literal"><span class="pre">ceil((stop</span> <span class="pre">-</span> <span class="pre">start)/step)</span></tt>.  Because of floating point overflow,
this rule may result in the last element of <cite>out</cite> being greater
than <cite>stop</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.asin">
<tt class="descname">asin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric inverse sine</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.atan">
<tt class="descname">atan</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.atan" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric inverse tangent</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.avg">
<tt class="descname">avg</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.avg" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis average.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.avg()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.ceil">
<tt class="descname">ceil</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise ceiling function</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.cos">
<tt class="descname">cos</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric cosine</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.count">
<tt class="descname">count</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis count.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.count()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.cross_join">
<tt class="descname">cross_join</tt><big>(</big><em>A</em>, <em>B</em>, <em>*dims</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.cross_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a cross-join on arrays A and B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A, B</strong> : SciDBArray</p>
<p><strong>*dims</strong> : tuples</p>
<blockquote class="last">
<div><p>The remaining arguments are tuples of dimension indices which
should be joined.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.dot">
<tt class="descname">dot</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix product of A and B</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : SciDBArray</p>
<blockquote>
<div><p>A must be a two-dimensional matrix of shape (n, p)</p>
</div></blockquote>
<p><strong>B</strong> : SciDBArray</p>
<blockquote>
<div><p>B must be a two-dimensional matrix of shape (p, m)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>C</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>The wrapper of the SciDB Array, of shape (n, m), consisting of the
matrix product of A and B</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.exp">
<tt class="descname">exp</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise natural exponent</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.floor">
<tt class="descname">floor</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise floor function</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.from_array">
<tt class="descname">from_array</tt><big>(</big><em>A</em>, <em>instance_id=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.from_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a scidb array from a numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : array_like (numpy array or sparse array)</p>
<blockquote>
<div><p>input array from which the scidb array will be created</p>
</div></blockquote>
<p><strong>instance_id</strong> : integer</p>
<blockquote>
<div><p>the instance ID used in loading
(default=0; see SciDB documentation)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to new_array()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>SciDB Array object built from the input array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.from_dataframe">
<tt class="descname">from_dataframe</tt><big>(</big><em>A</em>, <em>instance_id=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.from_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a scidb array from a pandas dataframe</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : pandas dataframe</p>
<blockquote>
<div><p>data from which the scidb array will be created.</p>
</div></blockquote>
<p><strong>instance_id</strong> : integer</p>
<blockquote>
<div><p>the instance ID used in loading
(default=0; see SciDB documentation)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to new_array()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>SciDB Array object built from the input array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.from_sparse">
<tt class="descname">from_sparse</tt><big>(</big><em>A</em>, <em>instance_id=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.from_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a scidb array from a sparse array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : sparse array</p>
<blockquote>
<div><p>sparse input array from which the scidb array will be created.
Note that this array will internally be converted to COO format.</p>
</div></blockquote>
<p><strong>instance_id</strong> : integer</p>
<blockquote>
<div><p>the instance ID used in loading
(default=0; see SciDB documentation)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to new_array()</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>SciDB Array object built from the input array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.identity">
<tt class="descname">identity</tt><big>(</big><em>n</em>, <em>dtype=u'double'</em>, <em>sparse=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2-dimensional square identity matrix of size n</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : integer</p>
<blockquote>
<div><p>the number of rows and columns in the matrix</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>sparse</strong> : boolean</p>
<blockquote>
<div><p>specify whether to create a sparse array (default=False)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>A SciDBArray containint an [n x n] identity matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.isnan">
<tt class="descname">isnan</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.isnan" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise nan test function</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.join">
<tt class="descname">join</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a series of array joins on the arguments
and return the result.</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.linspace">
<tt class="descname">linspace</tt><big>(</big><em>start</em>, <em>stop</em>, <em>num=50</em>, <em>endpoint=True</em>, <em>retstep=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced numbers over a specified interval.</p>
<p>Returns <cite>num</cite> evenly spaced samples, calculated over the
interval [<cite>start</cite>, <cite>stop</cite> ].</p>
<p>The endpoint of the interval can optionally be excluded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>start</strong> : scalar</p>
<blockquote>
<div><p>The starting value of the sequence.</p>
</div></blockquote>
<p><strong>stop</strong> : scalar</p>
<blockquote>
<div><p>The end value of the sequence, unless <cite>endpoint</cite> is set to False.
In that case, the sequence consists of all but the last of
<tt class="docutils literal"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></tt> evenly spaced samples, so that <cite>stop</cite> is excluded.
Note that the step size changes when <cite>endpoint</cite> is False.</p>
</div></blockquote>
<p><strong>num</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to generate. Default is 50.</p>
</div></blockquote>
<p><strong>endpoint</strong> : bool, optional</p>
<blockquote>
<div><p>If True, <cite>stop</cite> is the last sample. Otherwise, it is not included.
Default is True.</p>
</div></blockquote>
<p><strong>retstep</strong> : bool, optional</p>
<blockquote>
<div><p>If True, return (<cite>samples</cite>, <cite>step</cite>), where <cite>step</cite> is the spacing
between samples.</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>additional keyword arguments are passed to SciDBDataShape</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>samples</strong> : SciDBArray</p>
<blockquote>
<div><p>There are <cite>num</cite> equally spaced samples in the closed interval
<tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop]</span></tt> or the half-open interval <tt class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop)</span></tt>
(depending on whether <cite>endpoint</cite> is True or False).</p>
</div></blockquote>
<p><strong>step</strong> : float (only if <cite>retstep</cite> is True)</p>
<blockquote class="last">
<div><p>Size of spacing between samples.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.list_arrays">
<tt class="descname">list_arrays</tt><big>(</big><em>parsed=True</em>, <em>n=0</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.list_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>List the arrays currently in the database</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parsed</strong> : boolean</p>
<blockquote>
<div><p>If True (default), then parse the results into a dictionary of
array names as keys, schema as values</p>
</div></blockquote>
<p><strong>n</strong> : integer</p>
<blockquote>
<div><p>the maximum number of arrays to list.  If n=0, then list all</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>array_list</strong> : string or dictionary</p>
<blockquote class="last">
<div><p>The list of arrays.  If parsed=True, then the result is returned
as a dictionary.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.log">
<tt class="descname">log</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise natural logarithm</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.log10">
<tt class="descname">log10</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise base-10 logarithm</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.max">
<tt class="descname">max</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis maximum.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.max()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.mean">
<tt class="descname">mean</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis mean.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.mean()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.merge">
<tt class="descname">merge</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge two arrays</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.min">
<tt class="descname">min</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis minimum.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.min()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.new_array">
<tt class="descname">new_array</tt><big>(</big><em>shape=None</em>, <em>dtype=u'double'</em>, <em>persistent=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.new_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new array, either instantiating it in SciDB or simply
reserving the name for use in a later query.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : int or tuple (optional)</p>
<blockquote>
<div><p>The shape of the array to create.  If not specified, no array
will be created and a name will simply be reserved for later use.
WARNING: if shape=None and persistent=False, an error will result
when the array goes out of scope, unless the name is used to
create an array on the server.</p>
</div></blockquote>
<p><strong>dtype</strong> : string (optional)</p>
<blockquote>
<div><p>the datatype of the array.  This is only referenced if <cite>shape</cite>
is specified.  Default is &#8216;double&#8217;.</p>
</div></blockquote>
<p><strong>persistent</strong> : boolean (optional)</p>
<blockquote>
<div><p>whether the created array should be persistent, i.e. survive
in SciDB past when the object wrapper goes out of scope.  Default
is False.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : (optional)</p>
<blockquote>
<div><p>If <cite>shape</cite> is specified, additional keyword arguments are passed
to SciDBDataShape.  Otherwise, these will not be referenced.</p>
</div></blockquote>
<p><strong>Returns</strong> :</p>
<p><strong>&#8212;&#8212;-</strong> :</p>
<p><strong>arr</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>wrapper of the new SciDB array instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.ones">
<tt class="descname">ones</tt><big>(</big><em>shape</em>, <em>dtype=u'double'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of ones</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple or int</p>
<blockquote>
<div><p>The shape of the array</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr: SciDBArray</strong> :</p>
<blockquote class="last">
<div><p>A SciDBArray consisting of all ones.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.query">
<tt class="descname">query</tt><big>(</big><em>query</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a query on the database.</p>
<p>This wraps a query constructor which allows the creation of
sophisticated SciDB queries which act on arrays wrapped by SciDBArray
objects.  See Notes below for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>query</strong> : string</p>
<blockquote>
<div><p>The query string, with curly-braces to indicate insertions</p>
</div></blockquote>
<p><strong>*args, **kwargs :</strong> :</p>
<blockquote class="last">
<div><p>Values to be inserted (see below).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.randint">
<tt class="descname">randint</tt><big>(</big><em>shape</em>, <em>dtype=u'uint32'</em>, <em>lower=0</em>, <em>upper=2147483647</em>, <em>persistent=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.randint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of random integers between lower and upper</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple or int</p>
<blockquote>
<div><p>The shape of the array</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>lower</strong> : float</p>
<blockquote>
<div><p>The lower bound of the random sample (default=0)</p>
</div></blockquote>
<p><strong>upper</strong> : float</p>
<blockquote>
<div><p>The upper bound of the random sample (default=2147483647)</p>
</div></blockquote>
<p><strong>persistent</strong> : bool</p>
<blockquote>
<div><p>Whether the array is persistent (default=False)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr: SciDBArray</strong> :</p>
<blockquote class="last">
<div><p>A SciDBArray consisting of random integers, uniformly distributed
between <cite>lower</cite> and <cite>upper</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.random">
<tt class="descname">random</tt><big>(</big><em>shape</em>, <em>dtype=u'double'</em>, <em>lower=0</em>, <em>upper=1</em>, <em>persistent=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of random floats between lower and upper</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple or int</p>
<blockquote>
<div><p>The shape of the array</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>lower</strong> : float</p>
<blockquote>
<div><p>The lower bound of the random sample (default=0)</p>
</div></blockquote>
<p><strong>upper</strong> : float</p>
<blockquote>
<div><p>The upper bound of the random sample (default=1)</p>
</div></blockquote>
<p><strong>persistent</strong> : bool</p>
<blockquote>
<div><p>Whether the new array is persistent (default=False)</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr: SciDBArray</strong> :</p>
<blockquote class="last">
<div><p>A SciDBArray consisting of random floating point numbers,
uniformly distributed between <cite>lower</cite> and <cite>upper</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.reap">
<tt class="descname">reap</tt><big>(</big><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.reap" title="Permalink to this definition">¶</a></dt>
<dd><p>Reap all arrays created via new_array</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.sin">
<tt class="descname">sin</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric sine</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.sqrt">
<tt class="descname">sqrt</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise square root</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.std">
<tt class="descname">std</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis standard deviation.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.std()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.stdev">
<tt class="descname">stdev</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis standard deviation.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.stdev()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.substitute">
<tt class="descname">substitute</tt><big>(</big><em>A</em>, <em>value</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace null values in an array</p>
<p>See <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.substitute()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.sum">
<tt class="descname">sum</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis sum.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.sum()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.svd">
<tt class="descname">svd</tt><big>(</big><em>A</em>, <em>return_U=True</em>, <em>return_S=True</em>, <em>return_VT=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Singular Value Decomposition of the array A:</p>
<p>A = U.S.V^T</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : SciDBArray</p>
<blockquote>
<div><p>The array for which the SVD will be computed.  It should be a
2-dimensional array with a single value per cell.  Currently, the
svd routine requires non-overlapping chunks of size 32.</p>
</div></blockquote>
<p><strong>return_U, return_S, return_VT</strong> : boolean</p>
<blockquote>
<div><p>if any is True, then return the associated array.  All are True
by default</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>[U], [S], [VT]</strong> : SciDBArrays</p>
<blockquote class="last">
<div><p>Arrays storing the singular values and vectors of A.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.tan">
<tt class="descname">tan</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise trigonometric tangent</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.toarray">
<tt class="descname">toarray</tt><big>(</big><em>A</em>, <em>transfer_bytes=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.toarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a SciDB array to a numpy array</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.todataframe">
<tt class="descname">todataframe</tt><big>(</big><em>A</em>, <em>transfer_bytes=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.todataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a SciDB array to a pandas dataframe</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.tosparse">
<tt class="descname">tosparse</tt><big>(</big><em>A</em>, <em>sparse_fmt=u'recarray'</em>, <em>transfer_bytes=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.tosparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a SciDB array to a sparse representation</p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.var">
<tt class="descname">var</tt><big>(</big><em>A</em>, <em>index=None</em>, <em>scidb_syntax=False</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Array or axis variance.</p>
<p>see <tt class="xref py py-meth docutils literal"><span class="pre">SciDBArray.var()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.wrap_array">
<tt class="descname">wrap_array</tt><big>(</big><em>scidbname</em>, <em>persistent=True</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.wrap_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new SciDBArray object that references an existing SciDB
array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scidbname</strong> : string</p>
<blockquote>
<div><p>Wrap an existing scidb array referred to by <cite>scidbname</cite>. The
SciDB array object persistent value will be set to True, and
the object shape, datashape and data type values will be
determined by the SciDB array.</p>
</div></blockquote>
<p><strong>persistent</strong> : boolean</p>
<blockquote class="last">
<div><p>If True (default) then array will not be deleted when this
variable goes out of scope. Warning: if persistent is set to
False, data could be lost!</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="scidbpy.interface.SciDBShimInterface.zeros">
<tt class="descname">zeros</tt><big>(</big><em>shape</em>, <em>dtype=u'double'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.interface.SciDBShimInterface.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shape</strong> : tuple or int</p>
<blockquote>
<div><p>The shape of the array</p>
</div></blockquote>
<p><strong>dtype</strong> : string or list</p>
<blockquote>
<div><p>The data type of the array</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments are passed to SciDBDataShape.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr: SciDBArray</strong> :</p>
<blockquote class="last">
<div><p>A SciDBArray consisting of all zeros.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="visualization-and-analysis">
<h2>Visualization and Analysis<a class="headerlink" href="#visualization-and-analysis" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="scidbpy.aggregation.GroupBy">
<em class="property">class </em><tt class="descclassname">scidbpy.aggregation.</tt><tt class="descname">GroupBy</tt><big>(</big><em>array</em>, <em>by</em><big>)</big><a class="headerlink" href="#scidbpy.aggregation.GroupBy" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a GroupBy operation on an array</p>
<p>The interface of this class mimics a subset of the functionality
of Pandas&#8217; groupby.</p>
<p class="rubric">Notes</p>
<p>GroupBy operations are currently restricted in the following ways:</p>
<ul class="simple">
<li>GroupBy items must be names of attributes or dimensions</li>
<li>Non-integer attributes cannot be used as a groupby item</li>
<li>Dimensions cannot be used in aggregate calls</li>
</ul>
<p>These limitations will be addressed in the 14.9 release of SciDB-Py</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sdb</span><span class="o">.</span><span class="n">afl</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;&lt;a:int32&gt;[i=0:100,1000,0]&#39;</span><span class="p">,</span> <span class="s">&#39;iif(i &gt; 50, 1, 0)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sdb</span><span class="o">.</span><span class="n">afl</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;&lt;b:int32&gt;[i=0:100,1000,0]&#39;</span><span class="p">,</span> <span class="s">&#39;i % 30&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">sdb</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grp</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grp</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="s">&#39;sum(b)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">todataframe</span><span class="p">()</span>
<span class="go">   a  b_sum</span>
<span class="go">0  0    645</span>
<span class="go">1  1    715</span>
</pre></div>
</div>
<p>Multiple aggregation functions can be provided with a dict:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">grp</span><span class="o">.</span><span class="n">aggregate</span><span class="p">({</span><span class="s">&#39;s&#39;</span><span class="p">:</span><span class="s">&#39;sum(b)&#39;</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">:</span><span class="s">&#39;max(b)&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">todataframe</span><span class="p">()</span>
<span class="go">       a    s   m</span>
<span class="go">    0  0  645  29</span>
<span class="go">    1  1  715  29</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#scidbpy.aggregation.GroupBy.aggregate" title="scidbpy.aggregation.GroupBy.aggregate"><tt class="xref py py-obj docutils literal"><span class="pre">aggregate</span></tt></a>(mappings)</td>
<td>Peform an aggregation over each group</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="scidbpy.aggregation.GroupBy.aggregate">
<tt class="descname">aggregate</tt><big>(</big><em>mappings</em><big>)</big><a class="headerlink" href="#scidbpy.aggregation.GroupBy.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Peform an aggregation over each group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mappings</strong> : string or dictionary</p>
<blockquote>
<div><p>If a string, a single SciDB expression to apply to each group
If a dict, mapping several attribute names to expression strings</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>agg</strong> : SciDBArray</p>
<blockquote class="last">
<div><p>A new SciDBArray, obtained by applying the aggregations to the
groups of the input array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="scidbpy.aggregation.histogram">
<tt class="descclassname">scidbpy.aggregation.</tt><tt class="descname">histogram</tt><big>(</big><em>X</em>, <em>bins=10</em>, <em>att=None</em>, <em>range=None</em>, <em>plot=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#scidbpy.aggregation.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a 1D histogram from a SciDBArray.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : SciDBArray</p>
<blockquote>
<div><p>The array to compute a histogram for</p>
</div></blockquote>
<p><strong>att</strong> : str (optional)</p>
<blockquote>
<div><p>The attribute of the array to consider. Defaults to the first attribute.</p>
</div></blockquote>
<p><strong>bins</strong> : int (optional)</p>
<blockquote>
<div><p>The number of bins</p>
</div></blockquote>
<p><strong>range</strong> : [min, max] (optional)</p>
<blockquote>
<div><p>The lower and upper limits of the histogram. Defaults to data limits.</p>
</div></blockquote>
<p><strong>plot</strong> : bool</p>
<blockquote>
<div><p>If True, plot the results with matplotlib</p>
</div></blockquote>
<p><strong>histtype</strong> : &#8216;bar&#8217; | &#8216;step&#8217; (default=&#8217;bar&#8217;)</p>
<blockquote>
<div><p>If plotting, the kind of hisogram to draw. See matplotlib.hist
for more details.</p>
</div></blockquote>
<p><strong>kwargs</strong> : optional</p>
<blockquote>
<div><p>Additional keywords passed to matplotlib</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>(counts, edges [, artists])</strong> :</p>
<blockquote class="last">
<div><ul class="simple">
<li>edges is a NumPy array of edge locations (length=bins+1)</li>
<li>counts is the number of data betwen [edges[i], edges[i+1]] (length=bins)</li>
<li>artists is a list of the matplotlib artists created if <em>plot=True</em></li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="api.html" class="btn btn-neutral" title="API Documentation"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013-2014, SciDB-Py Developers.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'14.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>