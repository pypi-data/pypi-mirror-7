#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class Digest(object):
  """
  Analytic-specific information about an attribute or edge. Digests
  are used to combine information from multiple sources to generate a
  unified value. The digests generated by an analytic will only ever
  be used by that same analytic, so analytics can feel free to encode
  information in whatever way is convenient.

  Attributes:
   - bytesValue: The following fields define various ways you can store the
  digest data (for convenience). If none of these meets your
  needs, then serialize the digest to a byte sequence and store it
  in bytesValue.
   - int64Value
   - doubleValue
   - stringValue
   - int64List
   - doubleList
   - stringList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bytesValue', None, None, ), # 1
    (2, TType.I64, 'int64Value', None, None, ), # 2
    (3, TType.DOUBLE, 'doubleValue', None, None, ), # 3
    (4, TType.STRING, 'stringValue', None, None, ), # 4
    (5, TType.LIST, 'int64List', (TType.I64,None), None, ), # 5
    (6, TType.LIST, 'doubleList', (TType.DOUBLE,None), None, ), # 6
    (7, TType.LIST, 'stringList', (TType.STRING,None), None, ), # 7
  )

  def __init__(self, bytesValue=None, int64Value=None, doubleValue=None, stringValue=None, int64List=None, doubleList=None, stringList=None,):
    self.bytesValue = bytesValue
    self.int64Value = int64Value
    self.doubleValue = doubleValue
    self.stringValue = stringValue
    self.int64List = int64List
    self.doubleList = doubleList
    self.stringList = stringList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bytesValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.int64Value = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.doubleValue = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.int64List = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI64();
            self.int64List.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.doubleList = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readDouble();
            self.doubleList.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.stringList = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = iprot.readString().decode('utf-8')
            self.stringList.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Digest')
    if self.bytesValue is not None:
      oprot.writeFieldBegin('bytesValue', TType.STRING, 1)
      oprot.writeString(self.bytesValue)
      oprot.writeFieldEnd()
    if self.int64Value is not None:
      oprot.writeFieldBegin('int64Value', TType.I64, 2)
      oprot.writeI64(self.int64Value)
      oprot.writeFieldEnd()
    if self.doubleValue is not None:
      oprot.writeFieldBegin('doubleValue', TType.DOUBLE, 3)
      oprot.writeDouble(self.doubleValue)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 4)
      oprot.writeString(self.stringValue.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.int64List is not None:
      oprot.writeFieldBegin('int64List', TType.LIST, 5)
      oprot.writeListBegin(TType.I64, len(self.int64List))
      for iter18 in self.int64List:
        oprot.writeI64(iter18)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.doubleList is not None:
      oprot.writeFieldBegin('doubleList', TType.LIST, 6)
      oprot.writeListBegin(TType.DOUBLE, len(self.doubleList))
      for iter19 in self.doubleList:
        oprot.writeDouble(iter19)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stringList is not None:
      oprot.writeFieldBegin('stringList', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.stringList))
      for iter20 in self.stringList:
        oprot.writeString(iter20.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AnnotationMetadata(object):
  """
  Metadata associated with an annotation or a set of annotations,
  that identifies where those annotations came from.

  Attributes:
   - tool: The name of the tool that generated this annotation.
   - timestamp: The time at which this annotation was generated (in unix time
  UTC -- i.e., seconds since January 1, 1970).
   - confidence: Confidence score. To do: define what this means!
   - digest: A Digest, carrying over any information the annotation metadata
  wishes to carry over.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tool', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.DOUBLE, 'confidence', None, None, ), # 3
    (4, TType.STRUCT, 'digest', (Digest, Digest.thrift_spec), None, ), # 4
  )

  def __init__(self, tool=None, timestamp=None, confidence=None, digest=None,):
    self.tool = tool
    self.timestamp = timestamp
    self.confidence = confidence
    self.digest = digest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tool = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.digest = Digest()
          self.digest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AnnotationMetadata')
    if self.tool is not None:
      oprot.writeFieldBegin('tool', TType.STRING, 1)
      oprot.writeString(self.tool.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 3)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    if self.digest is not None:
      oprot.writeFieldBegin('digest', TType.STRUCT, 4)
      self.digest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tool is None:
      raise TProtocol.TProtocolException(message='Required field tool is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
