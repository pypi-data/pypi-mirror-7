{
  "SDL_JoystickGetAxis": ":param joystick:\n:param axis:\n\nGet the current state of an axis control on a joystick.\n\nThe state is a value ranging from -32768 to 32767.\n\nThe axis indices start at index 0.\n", 
  "SDL_SetWindowTitle": ":param window:\n:param title:\n\nSet the title of a window, in UTF-8 format.\n\nSDL_GetWindowTitle()\n", 
  "SDL_SetSurfaceRLE": ":param surface:\n:param flag:\n\nSets the RLE acceleration hint for a surface.\n\n:return: 0 on success, or -1 if the surface is not validIf RLE is\nenabled, colorkey and alpha blending blits are much faster, but the\nsurface must be locked before directly accessing the pixels.\n", 
  "SDL_GetPerformanceFrequency": "\nGet the count per second of the high resolution counter.\n", 
  "SDL_HapticStopEffect": ":param haptic:\n:param effect:\n\nStops the haptic effect on its associated haptic device.\n\nhaptic: Haptic device to stop the effect on.\n\neffect: Identifier of the effect to stop.\n\n:return: 0 on success or -1 on error.SDL_HapticRunEffect\n\nSDL_HapticDestroyEffect\n", 
  "SDL_SetTextureAlphaMod": ":param texture:\n:param alpha:\n\nSet an additional alpha value used in render copy operations.\n\ntexture: The texture to update.\n\nalpha: The alpha value multiplied into copy operations.\n\n:return: 0 on success, or -1 if the texture is not valid or alpha\nmodulation is not supported.SDL_GetTextureAlphaMod()\n", 
  "SDL_UnionRect": ":param A:\n:param B:\n:param result:\n\nCalculate the union of two rectangles.\n", 
  "SDL_JoystickNumBalls": ":param joystick:\n\nGet the number of trackballs on a joystick.\n\nJoystick trackballs have only relative motion events associated with\nthem and their state cannot be polled.\n", 
  "SDL_GetSystemRAM": "\nThis function returns the amount of RAM configured in the system, in\nMB.\n", 
  "SDL_IsGameController": ":param joystick_index:\n\nIs the joystick on this index supported by the game controller\ninterface?\n", 
  "SDL_CreateTexture": ":param renderer:\n:param format:\n:param access:\n:param w:\n:param h:\n\nCreate a texture for a rendering context.\n\nrenderer: The renderer.\n\nformat: The format of the texture.\n\naccess: One of the enumerated values in SDL_TextureAccess.\n\nw: The width of the texture in pixels.\n\nh: The height of the texture in pixels.\n\n:return: The created texture is returned, or 0 if no rendering context\nwas active, the format was unsupported, or the width or height were\nout of range.SDL_QueryTexture()\n\nSDL_UpdateTexture()\n\nSDL_DestroyTexture()\n", 
  "SDL_GetMouseState": ":param x:\n:param y:\n\nRetrieve the current state of the mouse.\n\nThe current button state is returned as a button bitmask, which can be\ntested using the SDL_BUTTON(X) macros, and x and y are set to the\nmouse cursor position relative to the focus window for the currently\nselected mouse. You can pass NULL for either x or y.\n", 
  "SDL_ShowCursor": ":param toggle:\n\nToggle whether or not the cursor is shown.\n\ntoggle: 1 to show the cursor, 0 to hide it, -1 to query the current\nstate.\n\n:return: 1 if the cursor is shown, or 0 if the cursor is hidden.\n", 
  "SDLTest_Crc32Init": ":param crcContext:\n\n/brief Initialize the CRC context\n\nNote: The function initializes the crc table required for all crc\ncalculations.\n\n/param crcContext pointer to context variable\n\n/returns 0 for OK, -1 on error\n", 
  "SDL_Swap16": ":param x:\n", 
  "GLboolean": ":param PFNGLISQUERYPROC:\n", 
  "SDL_DestroyCond": ":param cond:\n\nDestroy a condition variable.\n", 
  "SDL_MixAudioFormat": ":param dst:\n:param src:\n:param format:\n:param len:\n:param volume:\n\nThis works like SDL_MixAudio(), but you specify the audio format\ninstead of using the format of audio device 1. Thus it can be used\nwhen no audio device is open at all.\n", 
  "SDL_GL_GetSwapInterval": "\nGet the swap interval for the current OpenGL context.\n\n:return: 0 if there is no vertical retrace synchronization, 1 if the\nbuffer swap is synchronized with the vertical retrace, and -1 if late\nswaps happen immediately instead of waiting for the next retrace. If\nthe system can't determine the swap interval, or there isn't a valid\ncurrent context, this will return 0 as a safe\ndefault.SDL_GL_SetSwapInterval()\n", 
  "SDL_LogSetOutputFunction": ":param callback:\n:param userdata:\n\nThis function allows you to replace the default log output function\nwith one of your own.\n", 
  "SDL_vsnprintf": ":param text:\n:param maxlen:\n:param fmt:\n:param ap:\n", 
  "SDL_GetMouseFocus": "\nGet the window which currently has mouse focus.\n", 
  "SDL_CreateSoftwareRenderer": ":param surface:\n\nCreate a 2D software rendering context for a surface.\n\nsurface: The surface where rendering is done.\n\n:return: A valid rendering context or NULL if there was an\nerror.SDL_CreateRenderer()\n\nSDL_DestroyRenderer()\n", 
  "SDL_GetDefaultAssertionHandler": "\nGet the default assertion handler.\n\nThis returns the function pointer that is called by default when an\nassertion is triggered. This is an internal function provided by SDL,\nthat is used for assertions when SDL_SetAssertionHandler() hasn't been\nused to provide a different function.\n\n:return: The default SDL_AssertionHandler that is called when an\nassert triggers.\n", 
  "SDL_GetCurrentVideoDriver": "\nReturns the name of the currently initialized video driver.\n\n:return: The name of the current video driver or NULL if no driver has\nbeen initializedSDL_GetNumVideoDrivers()\n\nSDL_GetVideoDriver()\n", 
  "SDLTest_Md5Init": ":param mdContext:\n\n/brief initialize the context\n\n/param mdContext pointer to context variable\n\nNote: The function initializes the message-digest context mdContext.\nCall before each new use of the context - all fields are set to zero.\n", 
  "SDL_FreeWAV": ":param audio_buf:\n\nThis function frees data previously allocated with SDL_LoadWAV_RW()\n", 
  "SDLTest_Md5Final": ":param mdContext:\n", 
  "SDL_CreateCursor": ":param data:\n:param mask:\n:param w:\n:param h:\n:param hot_x:\n:param hot_y:\n\nCreate a cursor, using the specified bitmap data and mask (in MSB\nformat).\n\nThe cursor width must be a multiple of 8 bits.\n\nThe cursor is created in black and white according to the following:\ndata\n\nmask\n\nresulting pixel on screen\n\n0\n\n1\n\nWhite\n\n1\n\n1\n\nBlack\n\n0\n\n0\n\nTransparent\n\n1\n\n0\n\nInverted color if possible, black if not.\n\nSDL_FreeCursor()\n", 
  "SDL_setenv": ":param name:\n:param value:\n:param overwrite:\n", 
  "void": ":param PFNGLBLENDCOLORPROC:\n", 
  "SDL_RenderTargetSupported": ":param renderer:\n\nDetermines whether a window supports the use of render targets.\n\nrenderer: The renderer that will be checked\n\n:return: SDL_TRUE if supported, SDL_FALSE if not.\n", 
  "SDL_GetScancodeFromKey": ":param key:\n\nGet the scancode corresponding to the given key code according to the\ncurrent keyboard layout.\n\nSee SDL_Scancode for details.\n\nSDL_GetScancodeName()\n", 
  "SDL_TLSGet": ":param id:\n\nGet the value associated with a thread local storage ID for the\ncurrent thread.\n\nid: The thread local storage ID\n\n:return: The value associated with the ID for the current thread, or\nNULL if no value has been set.SDL_TLSCreate()\n\nSDL_TLSSet()\n", 
  "SDL_SetTextInputRect": ":param rect:\n\nSet the rectangle used to type Unicode text inputs. This is used as a\nhint for IME and on-screen keyboard placement.\n\nSDL_StartTextInput()\n", 
  "SDL_UnlockAudioDevice": ":param dev:\n", 
  "SDL_DXGIGetOutputInfo": ":param displayIndex:\n:param adapterIndex:\n:param outputIndex:\n", 
  "SDL_VideoQuit": "\nShuts down the video subsystem.\n\nThis function closes all windows, and restores the original video\nmode.\n\nSDL_VideoInit()\n", 
  "SDL_SetSurfaceBlendMode": ":param surface:\n:param blendMode:\n\nSet the blend mode used for blit operations.\n\nsurface: The surface to update.\n\nblendMode: SDL_BlendMode to use for blit blending.\n\n:return: 0 on success, or -1 if the parameters are not\nvalid.SDL_GetSurfaceBlendMode()\n", 
  "SDL_atoi": ":param str:\n", 
  "SDL_pow": ":param x:\n:param y:\n", 
  "SDL_strlen": ":param str:\n", 
  "SDL_ShowMessageBox": ":param messageboxdata:\n:param buttonid:\n\nCreate a modal message box.\n\nmessageboxdata: The SDL_MessageBoxData structure with title, text,\netc.\n\nbuttonid: The pointer to which user id of hit button should be copied.\n\n:return: -1 on error, otherwise 0 and buttonid contains user id of\nbutton hit or -1 if dialog was closed.This function should be called\non the thread that created the parent window, or on the main thread if\nthe messagebox has no parent. It will block execution of that thread\nuntil the user clicks a button or closes the messagebox.\n", 
  "SDL_HideWindow": ":param window:\n\nHide a window.\n\nSDL_ShowWindow()\n", 
  "SDL_atof": ":param str:\n", 
  "SDL_GetRenderDrawColor": ":param renderer:\n:param r:\n:param g:\n:param b:\n:param a:\n\nGet the color used for drawing operations (Rect, Line and Clear).\n\nrenderer: The renderer from which drawing color should be queried.\n\nr: A pointer to the red value used to draw on the rendering target.\n\ng: A pointer to the green value used to draw on the rendering target.\n\nb: A pointer to the blue value used to draw on the rendering target.\n\na: A pointer to the alpha value used to draw on the rendering target,\nusually SDL_ALPHA_OPAQUE (255).\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_ReadBE16": ":param src:\n", 
  "SDL_SetWindowData": ":param window:\n:param name:\n:param userdata:\n\nAssociate an arbitrary named pointer with a window.\n\nwindow: The window to associate with the pointer.\n\nname: The name of the pointer.\n\nuserdata: The associated pointer.\n\n:return: The previous value associated with 'name'The name is case-\nsensitive.\n\nSDL_GetWindowData()\n", 
  "SDL_LogResetPriorities": "\nReset all priorities to default.\n\nThis is called in SDL_Quit().\n", 
  "SDL_GetDefaultCursor": "\nReturn the default cursor.\n", 
  "SDL_SetWindowSize": ":param window:\n:param w:\n:param h:\n\nSet the size of a window's client area.\n\nwindow: The window to resize.\n\nw: The width of the window, must be >0\n\nh: The height of the window, must be >0\n\nYou can't change the size of a fullscreen window, it automatically\nmatches the size of the display mode.\n\nSDL_GetWindowSize()\n", 
  "SDL_toupper": ":param x:\n", 
  "SDL_SetTextureBlendMode": ":param texture:\n:param blendMode:\n\nSet the blend mode used for texture copy operations.\n\ntexture: The texture to update.\n\nblendMode: SDL_BlendMode to use for texture blending.\n\n:return: 0 on success, or -1 if the texture is not valid or the blend\nmode is not supported.If the blend mode is not supported, the closest\nsupported mode is chosen.\n\nSDL_GetTextureBlendMode()\n", 
  "SDL_GetWindowWMInfo": ":param window:\n:param info:\n\nThis function allows access to driver-dependent window information.\n\nwindow: The window about which information is being requested\n\ninfo: This structure must be initialized with the SDL version, and is\nthen filled in with information about the given window.\n\n:return: SDL_TRUE if the function is implemented and the version\nmember of the\n\nYou typically use this function like this: *SDL_SysWMinfoinfo;*SDL_VER\nSION(&info.version);*if(SDL_GetWindowWMInfo(window,&info)){...}*\n", 
  "SDLTest_Crc32CalcEnd": ":param crcContext:\n:param crc32:\n", 
  "SDL_FillRect": ":param dst:\n:param rect:\n:param color:\n\nPerforms a fast fill of the given rectangle with color.\n\nIf rect is NULL, the whole surface will be filled with color.\n\nThe color should be a pixel of the format used by the surface, and can\nbe generated by the SDL_MapRGB() function.\n\n:return: 0 on success, or -1 on error.\n", 
  "SDL_RenderSetLogicalSize": ":param renderer:\n:param w:\n:param h:\n\nSet device independent resolution for rendering.\n\nrenderer: The renderer for which resolution should be set.\n\nw: The width of the logical resolution\n\nh: The height of the logical resolution\n\nThis function uses the viewport and scaling functionality to allow a\nfixed logical resolution for rendering, regardless of the actual\noutput resolution. If the actual output resolution doesn't have the\nsame aspect ratio the output rendering will be centered within the\noutput display.\n\nIf the output display is a window, mouse events in the window will be\nfiltered and scaled so they seem to arrive within the logical\nresolution.\n\nIf this function results in scaling or subpixel drawing by the\nrendering backend, it will be handled using the appropriate quality\nhints.\n\nSDL_RenderGetLogicalSize()\n\nSDL_RenderSetScale()\n\nSDL_RenderSetViewport()\n", 
  "SDL_LoadFunction": ":param handle:\n:param name:\n\nGiven an object handle, this function looks up the address of the\nnamed function in the shared object and returns it. This address is no\nlonger valid after calling SDL_UnloadObject().\n", 
  "SDL_GetNumAudioDevices": ":param iscapture:\n\nGet the number of available devices exposed by the current driver.\nOnly valid after a successfully initializing the audio subsystem.\nReturns -1 if an explicit list of devices can't be determined; this is\nnot an error. For example, if SDL is set up to talk to a remote audio\nserver, it can't list every one available on the Internet, but it will\nstill allow a specific host to be specified to SDL_OpenAudioDevice().\n\nIn many common cases, when this function returns a value <= 0, it can\nstill successfully open the default device (NULL for first argument of\nSDL_OpenAudioDevice()).\n", 
  "SDL_GetAudioDriver": ":param index:\n", 
  "SDL_GL_CreateContext": ":param window:\n\nCreate an OpenGL context for use with an OpenGL window, and make it\ncurrent.\n\nSDL_GL_DeleteContext()\n", 
  "SDL_HapticGetEffectStatus": ":param haptic:\n:param effect:\n\nGets the status of the current effect on the haptic device.\n\nDevice must support the SDL_HAPTIC_STATUS feature.\n\nhaptic: Haptic device to query the effect status on.\n\neffect: Identifier of the effect to query its status.\n\n:return: 0 if it isn't playing, 1 if it is playing or -1 on\nerror.SDL_HapticRunEffect\n\nSDL_HapticStopEffect\n", 
  "SDL_RenderFillRect": ":param renderer:\n:param rect:\n\nFill a rectangle on the current rendering target with the drawing\ncolor.\n\nrenderer: The renderer which should fill a rectangle.\n\nrect: A pointer to the destination rectangle, or NULL for the entire\nrendering target.\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_ReadU8": ":param src:\n", 
  "SDL_GetThreadID": ":param thread:\n\nGet the thread identifier for the specified thread.\n\nEquivalent to SDL_ThreadID() if the specified thread is NULL.\n", 
  "SDL_GetCPUCacheLineSize": "\nThis function returns the L1 cache line size of the CPU\n\nThis is useful for determining multi-threaded structure padding or\nSIMD prefetch sizes.\n", 
  "SDL_LogWarn": ":param category:\n:param fmt:\n:param :\n\nLog a message with SDL_LOG_PRIORITY_WARN.\n", 
  "SDL_SetWindowDisplayMode": ":param window:\n:param mode:\n\nSet the display mode used when a fullscreen window is visible.\n\nBy default the window's dimensions and the desktop format and refresh\nrate are used.\n\nwindow: The window for which the display mode should be set.\n\nmode: The mode to use, or NULL for the default mode.\n\n:return: 0 on success, or -1 if setting the display mode\nfailed.SDL_GetWindowDisplayMode()\n\nSDL_SetWindowFullscreen()\n", 
  "SDL_iconv_open": ":param tocode:\n:param fromcode:\n", 
  "SDL_GetTicks": "\nGet the number of milliseconds since the SDL library initialization.\n\nThis value wraps if the program runs for more than ~49 days.\n", 
  "SDL_ltoa": ":param value:\n:param str:\n:param radix:\n", 
  "SDL_AddEventWatch": ":param filter:\n:param userdata:\n\nAdd a function which is called when an event is added to the queue.\n", 
  "GLint": ":param PFNGLGETATTRIBLOCATIONPROC:\n", 
  "SDL_LogError": ":param category:\n:param fmt:\n:param :\n\nLog a message with SDL_LOG_PRIORITY_ERROR.\n", 
  "SDLTest_RandomSint8": "\nReturns a random Sint8\n\n:return: Generated signed integer\n", 
  "SDL_DetachThread": ":param thread:\n\nA thread may be \"detached\" to signify that it should not remain until\nanother thread has called SDL_WaitThread() on it. Detaching a thread\nis useful for long-running threads that nothing needs to synchronize\nwith or further manage. When a detached thread is done, it simply goes\naway.\n\nThere is no way to recover the return code of a detached thread. If\nyou need this, don't detach the thread and instead use\nSDL_WaitThread().\n\nOnce a thread is detached, you should usually assume the SDL_Thread\nisn't safe to reference again, as it will become invalid immediately\nupon the detached thread's exit, instead of remaining until someone\nhas called SDL_WaitThread() to finally clean it up. As such, don't\ndetach the same thread more than once.\n\nIf a thread has already exited when passed to SDL_DetachThread(), it\nwill stop waiting for a call to SDL_WaitThread() and clean up\nimmediately. It is not safe to detach a thread that might be used with\nSDL_WaitThread().\n\nYou may not call SDL_WaitThread() on a thread that has been detached.\nUse either that function or this one, but not both, or behavior is\nundefined.\n\nIt is safe to pass NULL to this function; it is a no-op.\n", 
  "SDL_DestroyMutex": ":param mutex:\n\nDestroy a mutex.\n", 
  "SDL_Error": ":param code:\n", 
  "SDL_memcpy": ":param dst:\n:param src:\n:param len:\n", 
  "SDL_GetWindowDisplayMode": ":param window:\n:param mode:\n\nFill in information about the display mode used when a fullscreen\nwindow is visible.\n\nSDL_SetWindowDisplayMode()\n\nSDL_SetWindowFullscreen()\n", 
  "SDL_FreeRW": ":param area:\n", 
  "SDL_GetRenderDrawBlendMode": ":param renderer:\n:param blendMode:\n\nGet the blend mode used for drawing operations.\n\nrenderer: The renderer from which blend mode should be queried.\n\nblendMode: A pointer filled in with the current blend mode.\n\n:return: 0 on success, or -1 on errorSDL_SetRenderDrawBlendMode()\n", 
  "SDL_GameControllerGetStringForButton": ":param button:\n\nturn this button enum into a string mapping\n", 
  "SDL_ConvertSurface": ":param src:\n:param fmt:\n:param flags:\n\nCreates a new surface of the specified format, and then copies and\nmaps the given surface to it so the blit of the converted surface will\nbe as fast as possible. If this function fails, it returns NULL.\n\nThe flags parameter is passed to SDL_CreateRGBSurface() and has those\nsemantics. You can also pass SDL_RLEACCEL in the flags parameter and\nSDL will try to RLE accelerate colorkey and alpha blits in the\nresulting surface.\n", 
  "SDL_ReadLE32": ":param src:\n", 
  "SDL_GetPixelFormatName": ":param format:\n\nGet the human readable name of a pixel format.\n", 
  "SDL_SemWait": ":param sem:\n\nThis function suspends the calling thread until the semaphore pointed\nto by sem has a positive count. It then atomically decreases the\nsemaphore count.\n", 
  "SDL_SetWindowPosition": ":param window:\n:param x:\n:param y:\n\nSet the position of a window.\n\nwindow: The window to reposition.\n\nx: The x coordinate of the window, SDL_WINDOWPOS_CENTERED, or\nSDL_WINDOWPOS_UNDEFINED.\n\ny: The y coordinate of the window, SDL_WINDOWPOS_CENTERED, or\nSDL_WINDOWPOS_UNDEFINED.\n\nThe window coordinate origin is the upper left of the display.\n\nSDL_GetWindowPosition()\n", 
  "SDL_CreateRGBSurfaceFrom": ":param pixels:\n:param width:\n:param height:\n:param depth:\n:param pitch:\n:param Rmask:\n:param Gmask:\n:param Bmask:\n:param Amask:\n", 
  "SDL_StartTextInput": "\nStart accepting Unicode text input events. This function will show the\non-screen keyboard if supported.\n\nSDL_StopTextInput()\n\nSDL_SetTextInputRect()\n\nSDL_HasScreenKeyboardSupport()\n", 
  "SDL_LockSurface": ":param surface:\n\nSets up a surface for directly accessing the pixels.\n\nBetween calls to SDL_LockSurface() / SDL_UnlockSurface(), you can\nwrite to and read from surface->pixels, using the pixel format stored\nin surface->format. Once you are done accessing the surface, you\nshould use SDL_UnlockSurface() to release it.\n\nNot all surfaces require locking. If SDL_MUSTLOCK(surface) evaluates\nto 0, then you can read and write to the surface at any time, and the\npixel format of the surface will not change.\n\nNo operating system or library calls should be made between\nlock/unlock pairs, as critical system locks may be held during this\ntime.\n\nSDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.\n\nSDL_UnlockSurface()\n", 
  "SDL_EnclosePoints": ":param points:\n:param count:\n:param clip:\n:param result:\n\nCalculate a minimal rectangle enclosing a set of points.\n\n:return: SDL_TRUE if any points were within the clipping rect\n", 
  "SDL_AtomicUnlock": ":param lock:\n\nUnlock a spin lock by setting it to 0. Always returns immediately.\n\nlock: Points to the lock.\n", 
  "SDL_HapticOpenFromMouse": "\nTries to open a haptic device from the current mouse.\n\n:return: The haptic device identifier or NULL on\nerror.SDL_MouseIsHaptic\n\nSDL_HapticOpen\n", 
  "SDLTest_AssertPass": ":param assertDescription:\n:param :\n\nExplicitely pass without checking an assertion condition. Updates\nassertion counter.\n\nassertDescription: Message to log with the assert describing it.\n", 
  "SDL_GetWindowBrightness": ":param window:\n\nGet the brightness (gamma correction) for a window.\n\n:return: The last brightness value passed to SDL_SetWindowBrightness()\n", 
  "SDL_JoystickGetBall": ":param joystick:\n:param ball:\n:param dx:\n:param dy:\n\nGet the ball axis change since the last poll.\n\n:return: 0, or -1 if you passed it invalid parameters.\n\nThe ball indices start at index 0.\n", 
  "SDL_LogMessage": ":param category:\n:param priority:\n:param fmt:\n:param :\n\nLog a message with the specified category and priority.\n", 
  "SDL_TLSSet": ":param id:\n:param value:\n:param destructor:\n\nSet the value associated with a thread local storage ID for the\ncurrent thread.\n\nid: The thread local storage ID\n\nvalue: The value to associate with the ID for the current thread\n\ndestructor: A function called when the thread exits, to free the\nvalue.\n\n:return: 0 on success, -1 on errorSDL_TLSCreate()\n\nSDL_TLSGet()\n", 
  "SDLTest_RandomSint16": "\nReturns a random Sint16\n\n:return: Generated signed integer\n", 
  "SDL_GetScancodeName": ":param scancode:\n\nGet a human-readable name for a scancode.\n\n:return: A pointer to the name for the scancode. If the scancode\ndoesn't have a name, this function returns an empty string\n(\"\").SDL_Scancode\n", 
  "SDL_UpperBlitScaled": ":param src:\n:param srcrect:\n:param dst:\n:param dstrect:\n\nThis is the public scaled blit function, SDL_BlitScaled(), and it\nperforms rectangle validation and clipping before passing it to\nSDL_LowerBlitScaled()\n", 
  "SDL_LogGetOutputFunction": ":param callback:\n:param userdata:\n\nGet the current log output function.\n", 
  "SDL_LockMutex": ":param mutex:\n", 
  "SDL_GameControllerEventState": ":param state:\n\nEnable/disable controller event polling.\n\nIf controller events are disabled, you must call\nSDL_GameControllerUpdate() yourself and check the state of the\ncontroller when you want controller information.\n\nThe state can be one of SDL_QUERY, SDL_ENABLE or SDL_IGNORE.\n", 
  "SDL_CreateThread": ":param fn:\n:param name:\n:param data:\n:param pfnBeginThread:\n:param pfnEndThread:\n\nCreate a thread.\n", 
  "SDL_OpenAudioDevice": ":param device:\n:param iscapture:\n:param desired:\n:param obtained:\n:param allowed_changes:\n\nOpen a specific audio device. Passing in a device name of NULL\nrequests the most reasonable default (and is equivalent to calling\nSDL_OpenAudio()).\n\nThe device name is a UTF-8 string reported by\nSDL_GetAudioDeviceName(), but some drivers allow arbitrary and driver-\nspecific strings, such as a hostname/IP address for a remote audio\nserver, or a filename in the diskaudio driver.\n\n:return: 0 on error, a valid device ID that is >= 2 on\nsuccess.SDL_OpenAudio(), unlike this function, always acts on device\nID 1.\n", 
  "SDL_sinf": ":param x:\n", 
  "SDL_EnableScreenSaver": "\nAllow the screen to be blanked by a screensaver.\n\nSDL_IsScreenSaverEnabled()\n\nSDL_DisableScreenSaver()\n", 
  "SDL_GetNumVideoDisplays": "\nReturns the number of available video displays.\n\nSDL_GetDisplayBounds()\n", 
  "SDL_RenderClear": ":param renderer:\n\nClear the current rendering target with the drawing color.\n\nThis function clears the entire rendering target, ignoring the\nviewport.\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_RenderSetClipRect": ":param renderer:\n:param rect:\n\nSet the clip rectangle for the current target.\n\nrenderer: The renderer for which clip rectangle should be set.\n\nrect: A pointer to the rectangle to set as the clip rectangle, or NULL\nto disable clipping.\n\n:return: 0 on success, or -1 on errorSDL_RenderGetClipRect()\n", 
  "SDL_HapticOpen": ":param device_index:\n\nOpens a Haptic device for usage.\n\nThe index passed as an argument refers to the N'th Haptic device on\nthis system.\n\nWhen opening a haptic device, its gain will be set to maximum and\nautocenter will be disabled. To modify these values use\nSDL_HapticSetGain() and SDL_HapticSetAutocenter().\n\ndevice_index: Index of the device to open.\n\n:return: Device identifier or NULL on error.SDL_HapticIndex\n\nSDL_HapticOpenFromMouse\n\nSDL_HapticOpenFromJoystick\n\nSDL_HapticClose\n\nSDL_HapticSetGain\n\nSDL_HapticSetAutocenter\n\nSDL_HapticPause\n\nSDL_HapticStopAll\n", 
  "SDL_GetKeyboardFocus": "\nGet the window which currently has keyboard focus.\n", 
  "SDLTest_Random": ":param rndContext:\n\nInitialize random number generator based on current system time.\n\nNote: ...RandomInit() or ...RandomInitTime() must have been called\nbefore using this function.\n\nrndContext: pointer to context structure\n\n:return: A random number (32bit unsigned integer)\n", 
  "SDL_HasSSE3": "\nThis function returns true if the CPU has SSE3 features.\n", 
  "SDL_CreateRenderer": ":param window:\n:param index:\n:param flags:\n\nCreate a 2D rendering context for a window.\n\nwindow: The window where rendering is displayed.\n\nindex: The index of the rendering driver to initialize, or -1 to\ninitialize the first one supporting the requested flags.\n\nflags: SDL_RendererFlags.\n\n:return: A valid rendering context or NULL if there was an\nerror.SDL_CreateSoftwareRenderer()\n\nSDL_GetRendererInfo()\n\nSDL_DestroyRenderer()\n", 
  "SDL_LoadBMP_RW": ":param src:\n:param freesrc:\n\nLoad a surface from a seekable SDL data stream (memory or file).\n\nIf freesrc is non-zero, the stream will be closed after being read.\n\nThe new surface should be freed with SDL_FreeSurface().\n\n:return: the new surface, or NULL if there was an error.\n", 
  "SDL_HapticNumEffectsPlaying": ":param haptic:\n\nReturns the number of effects a haptic device can play at the same\ntime.\n\nThis is not supported on all platforms, but will always return a\nvalue. Added here for the sake of completeness.\n\nhaptic: The haptic device to query maximum playing effects.\n\n:return: The number of effects the haptic device can play at the same\ntime or -1 on error.SDL_HapticNumEffects\n\nSDL_HapticQuery\n", 
  "SDL_HapticEffectSupported": ":param haptic:\n:param effect:\n\nChecks to see if effect is supported by haptic.\n\nhaptic: Haptic device to check on.\n\neffect: Effect to check to see if it is supported.\n\n:return: SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1\non error.SDL_HapticQuery\n\nSDL_HapticNewEffect\n", 
  "SDL_JoystickNumButtons": ":param joystick:\n\nGet the number of buttons on a joystick.\n", 
  "SDL_floor": ":param x:\n", 
  "SDL_UpdateTexture": ":param texture:\n:param rect:\n:param pixels:\n:param pitch:\n\nUpdate the given texture rectangle with new pixel data.\n\ntexture: The texture to update\n\nrect: A pointer to the rectangle of pixels to update, or NULL to\nupdate the entire texture.\n\npixels: The raw pixel data.\n\npitch: The number of bytes between rows of pixel data.\n\n:return: 0 on success, or -1 if the texture is not valid.This is a\nfairly slow function.\n", 
  "SDL_HasEvents": ":param minType:\n:param maxType:\n", 
  "SDL_GetPowerInfo": ":param secs:\n:param pct:\n\nGet the current power supply details.\n\nsecs: Seconds of battery life left. You can pass a NULL here if you\ndon't care. Will return -1 if we can't determine a value, or we're not\nrunning on a battery.\n\npct: Percentage of battery life left, between 0 and 100. You can pass\na NULL here if you don't care. Will return -1 if we can't determine a\nvalue, or we're not running on a battery.\n\n:return: The state of the battery (if any).\n", 
  "SDL_CondBroadcast": ":param cond:\n\nRestart all threads that are waiting on the condition variable.\n\n:return: 0 or -1 on error.\n", 
  "SDL_GameControllerGetButton": ":param gamecontroller:\n:param button:\n\nGet the current state of a button on a game controller.\n\nThe button indices start at index 0.\n", 
  "SDL_GameControllerGetAxis": ":param gamecontroller:\n:param axis:\n\nGet the current state of an axis control on a game controller.\n\nThe state is a value ranging from -32768 to 32767.\n\nThe axis indices start at index 0.\n", 
  "SDL_GetScancodeFromName": ":param name:\n\nGet a scancode from a human-readable name.\n\n:return: scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't\nrecognizedSDL_Scancode\n", 
  "SDL_GameControllerGetBindForAxis": ":param gamecontroller:\n:param axis:\n\nGet the SDL joystick layer binding for this controller button mapping\n", 
  "SDLTest_RandomUint64": "\nReturns random Uint64.\n\n:return: Generated integer\n", 
  "SDL_RenderGetScale": ":param renderer:\n:param scaleX:\n:param scaleY:\n\nGet the drawing scale for the current target.\n\nrenderer: The renderer from which drawing scale should be queried.\n\nscaleX: A pointer filled in with the horizontal scaling factor\n\nscaleY: A pointer filled in with the vertical scaling factor\n\nSDL_RenderSetScale()\n", 
  "SDL_GameControllerGetAxisFromString": ":param pchString:\n\nturn this string into a axis mapping\n", 
  "SDL_LogCritical": ":param category:\n:param fmt:\n:param :\n\nLog a message with SDL_LOG_PRIORITY_CRITICAL.\n", 
  "SDL_SoftStretch": ":param src:\n:param srcrect:\n:param dst:\n:param dstrect:\n\nPerform a fast, low quality, stretch blit between two surfaces of the\nsame pixel format.\n\nThis function uses a static buffer, and is not thread-safe.\n", 
  "SDL_GetRenderTarget": ":param renderer:\n\nGet the current render target or NULL for the default render target.\n\n:return: The current render targetSDL_SetRenderTarget()\n", 
  "SDL_NumJoysticks": "\nCount the number of joysticks attached to the system right now\n", 
  "SDL_RenderGetD3D9Device": ":param renderer:\n", 
  "SDL_UpperBlit": ":param src:\n:param srcrect:\n:param dst:\n:param dstrect:\n\nThis is the public blit function, SDL_BlitSurface(), and it performs\nrectangle validation and clipping before passing it to SDL_LowerBlit()\n", 
  "SDLTest_Log": ":param fmt:\n:param :\n\nPrints given message with a timestamp in the TEST category and INFO\npriority.\n\nfmt: Message to be logged\n", 
  "SDL_GetAudioDeviceStatus": ":param dev:\n", 
  "SDL_WriteLE16": ":param dst:\n:param value:\n", 
  "SDL_FreeFormat": ":param format:\n\nFree an SDL_PixelFormat structure.\n", 
  "SDL_IsShapedWindow": ":param window:\n\nReturn whether the given window is a shaped window.\n\nwindow: The window to query for being shaped.\n\n:return: SDL_TRUE if the window is a window that can be shaped,\nSDL_FALSE if the window is unshaped or NULL. SDL_CreateShapedWindow\n", 
  "SDL_DestroySemaphore": ":param sem:\n\nDestroy a semaphore.\n", 
  "SDLTest_RandomUint16": "\nReturns a random Uint16\n\n:return: Generated integer\n", 
  "SDL_IsScreenKeyboardShown": ":param window:\n\nReturns whether the screen keyboard is shown for given window.\n\nwindow: The window for which screen keyboard should be queried.\n\n:return: SDL_TRUE if screen keyboard is shown else\nSDL_FALSE.SDL_HasScreenKeyboardSupport()\n", 
  "SDL_HasScreenKeyboardSupport": "\nReturns whether the platform has some screen keyboard support.\n\n:return: SDL_TRUE if some keyboard support is available else\nSDL_FALSE.Not all screen keyboard functions are supported on all\nplatforms.\n\nSDL_IsScreenKeyboardShown()\n", 
  "SDL_AudioInit": ":param driver_name:\n", 
  "SDL_ConvertPixels": ":param width:\n:param height:\n:param src_format:\n:param src:\n:param src_pitch:\n:param dst_format:\n:param dst:\n:param dst_pitch:\n\nCopy a block of pixels of one format to another format.\n\n:return: 0 on success, or -1 if there was an error\n", 
  "SDL_SetWindowBordered": ":param window:\n:param bordered:\n\nSet the border state of a window.\n\nThis will add or remove the window's SDL_WINDOW_BORDERLESS flag and\nadd or remove the border from the actual window. This is a no-op if\nthe window's border already matches the requested state.\n\nwindow: The window of which to change the border state.\n\nbordered: SDL_FALSE to remove border, SDL_TRUE to add border.\n\nYou can't change the border state of a fullscreen window.\n\nSDL_GetWindowFlags()\n", 
  "SDL_LockTexture": ":param texture:\n:param rect:\n:param pixels:\n:param pitch:\n\nLock a portion of the texture for write-only pixel access.\n\ntexture: The texture to lock for access, which was created with\nSDL_TEXTUREACCESS_STREAMING.\n\nrect: A pointer to the rectangle to lock for access. If the rect is\nNULL, the entire texture will be locked.\n\npixels: This is filled in with a pointer to the locked pixels,\nappropriately offset by the locked area.\n\npitch: This is filled in with the pitch of the locked pixels.\n\n:return: 0 on success, or -1 if the texture is not valid or was not\ncreated with SDL_UnlockTexture()\n", 
  "SDL_RenderFillRects": ":param renderer:\n:param rects:\n:param count:\n\nFill some number of rectangles on the current rendering target with\nthe drawing color.\n\nrenderer: The renderer which should fill multiple rectangles.\n\nrects: A pointer to an array of destination rectangles.\n\ncount: The number of rectangles.\n\n:return: 0 on success, or -1 on error\n", 
  "SDLTest_RandomAsciiStringWithMaximumLength": ":param maxLength:\n\nGenerates random null-terminated string. The maximum length for the\nstring is defined by the maxLength parameter. String can contain ASCII\ncharacters from 32 to 126.\n\nNote: Returned string needs to be deallocated.\n\nmaxLength: The maximum length of the generated string.\n\n:return: Newly allocated random string; or NULL if maxLength was\ninvalid or string could not be allocated.\n", 
  "SDL_FreePalette": ":param palette:\n\nFree a palette created with SDL_AllocPalette().\n\nSDL_AllocPalette()\n", 
  "GLhandleARB": ":param PFNGLGETHANDLEARBPROC:\n", 
  "SDL_RenderGetLogicalSize": ":param renderer:\n:param w:\n:param h:\n\nGet device independent resolution for rendering.\n\nrenderer: The renderer from which resolution should be queried.\n\nw: A pointer filled with the width of the logical resolution\n\nh: A pointer filled with the height of the logical resolution\n\nSDL_RenderSetLogicalSize()\n", 
  "SDL_strdup": ":param str:\n", 
  "SDL_AllocPalette": ":param ncolors:\n\nCreate a palette structure with the specified number of color entries.\n\n:return: A new palette, or NULL if there wasn't enough memory.The\npalette entries are initialized to white.\n\nSDL_FreePalette()\n", 
  "GLintptr": ":param PFNGLGETUNIFORMOFFSETEXTPROC:\n", 
  "SDLTest_CommonCreateState": ":param argv:\n:param flags:\n\nParse command line parameters and create common state.\n\nargv: Array of command line parameters\n\nflags: Flags indicating which subsystem to initialize (i.e.\nSDL_INIT_VIDEO | SDL_INIT_AUDIO)\n\n:return: Returns a newly allocated common state object.\n", 
  "SDL_realloc": ":param mem:\n:param size:\n", 
  "SDL_GameControllerAddMappingsFromRW": ":param rw:\n:param freerw:\n\nTo count the number of game controllers in the system for the\nfollowing: int nJoysticks = SDL_NumJoysticks(); int nGameControllers =\n0; for ( int i = 0; i < nJoysticks; i++ ) { if (\nSDL_IsGameController(i) ) { nGameControllers++; } }\n\nUsing the SDL_HINT_GAMECONTROLLERCONFIG hint or the\nSDL_GameControllerAddMapping you can add support for controllers SDL\nis unaware of or cause an existing controller to have a different\nbinding. The format is: guid,name,mappings\n\nWhere GUID is the string value from SDL_JoystickGetGUIDString(), name\nis the human readable string for the device and mappings are\ncontroller mappings to joystick ones. Under Windows there is a\nreserved GUID of \"xinput\" that covers any XInput devices. The mapping\nformat for joystick is: bX - a joystick button, index X hX.Y - hat X\nwith value Y aX - axis X of the joystick Buttons can be used as a\ncontroller axis and vice versa.\n\nThis string shows an example of a valid mapping for a controller\n\"341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y\n:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,\ndpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick\n:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger\n:b7\", Load a set of mappings from a seekable SDL data stream (memory\nor file), filtered by the current SDL_GetPlatform() A community\nsourced database of controllers is available at https://raw.github.com\n/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt\n\nIf freerw is non-zero, the stream will be closed after being read.\n\n:return: number of mappings added, -1 on error\n", 
  "SDL_JoystickGetDeviceGUID": ":param device_index:\n\nReturn the GUID for the joystick at this index\n", 
  "SDL_LogVerbose": ":param category:\n:param fmt:\n:param :\n\nLog a message with SDL_LOG_PRIORITY_VERBOSE.\n", 
  "SDLTest_Crc32Done": ":param crcContext:\n\n/brief clean up CRC context\n\n/param crcContext pointer to context variable\n\n/returns 0 for OK, -1 on error\n", 
  "SDL_RWFromMem": ":param mem:\n:param size:\n", 
  "SDL_LowerBlitScaled": ":param src:\n:param srcrect:\n:param dst:\n:param dstrect:\n\nThis is a semi-private blit function and it performs low-level surface\nscaled blitting only.\n", 
  "SDL_JoystickNumHats": ":param joystick:\n\nGet the number of POV hats on a joystick.\n", 
  "SDL_JoystickOpen": ":param device_index:\n\nOpen a joystick for use. The index passed as an argument refers tothe\nN'th joystick on the system. This index is the value which will\nidentify this joystick in future joystick events.\n\n:return: A joystick identifier, or NULL if an error occurred.\n", 
  "SDL_MasksToPixelFormatEnum": ":param bpp:\n:param Rmask:\n:param Gmask:\n:param Bmask:\n:param Amask:\n\nConvert a bpp and RGBA masks to an enumerated pixel format.\n\n:return: The pixel format, or SDL_PixelFormatEnumToMasks()\n", 
  "SDL_tolower": ":param x:\n", 
  "SDL_Direct3D9GetAdapterIndex": ":param displayIndex:\n", 
  "SDL_copysign": ":param x:\n:param y:\n", 
  "SDL_LogMessageV": ":param category:\n:param priority:\n:param fmt:\n:param ap:\n\nLog a message with the specified category and priority.\n", 
  "SDL_GetTouchDevice": ":param index:\n\nGet the touch ID with the given index, or 0 if the index is invalid.\n", 
  "GLenum": ":param PFNGLCHECKFRAMEBUFFERSTATUSPROC:\n", 
  "SDL_RenderDrawPoints": ":param renderer:\n:param points:\n:param count:\n\nDraw multiple points on the current rendering target.\n\nrenderer: The renderer which should draw multiple points.\n\npoints: The points to draw\n\ncount: The number of points to draw\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_GetRendererInfo": ":param renderer:\n:param info:\n\nGet information about a rendering context.\n", 
  "SDL_AtomicSetPtr": ":param a:\n:param v:\n\nSet a pointer to a value atomically.\n\n:return: The previous value of the pointer.\n", 
  "SDL_cos": ":param x:\n", 
  "SDL_SaveDollarTemplate": ":param gestureId:\n:param dst:\n\nSave a currently loaded Dollar Gesture template.\n", 
  "SDL_GetRevision": "\nGet the code revision of SDL that is linked against your program.\n\nReturns an arbitrary string (a hash value) uniquely identifying the\nexact revision of the SDL library in use, and is only useful in\ncomparing against other revisions. It is NOT an incrementing number.\n", 
  "SDL_JoystickGetAttached": ":param joystick:\n\nReturns SDL_TRUE if the joystick has been opened and currently\nconnected, or SDL_FALSE if it has not.\n", 
  "SDL_HasAltiVec": "\nThis function returns true if the CPU has AltiVec features.\n", 
  "SDL_SetRenderDrawColor": ":param renderer:\n:param r:\n:param g:\n:param b:\n:param a:\n\nSet the color used for drawing operations (Rect, Line and Clear).\n\nrenderer: The renderer for which drawing color should be set.\n\nr: The red value used to draw on the rendering target.\n\ng: The green value used to draw on the rendering target.\n\nb: The blue value used to draw on the rendering target.\n\na: The alpha value used to draw on the rendering target, usually\nSDL_ALPHA_OPAQUE (255).\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_GetAssertionReport": "\nGet a list of all assertion failures.\n\nGet all assertions triggered since last call to\nSDL_ResetAssertionReport(), or the start of the program.\n\nThe proper way to examine this data looks something like this:\n\nconst SDL_assert_data *item = SDL_GetAssertionReport(); while (item) {\nprintf(\"'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n\",\nitem->condition, item->function, item->filename, item->linenum,\nitem->trigger_count, item->always_ignore ? \"yes\" : \"no\"); item =\nitem->next; }\n\n:return: List of all assertions. SDL_ResetAssertionReport\n", 
  "SDL_ReadLE64": ":param src:\n", 
  "SDLTest_RandomIntegerInRange": ":param min:\n:param max:\n\nReturns integer in range [min, max] (inclusive). Min and max values\ncan be negative values. If Max in smaller tham min, then the values\nare swapped. Min and max are the same value, that value will be\nreturned.\n\nmin: Minimum inclusive value of returned random number\n\nmax: Maximum inclusive value of returned random number\n\n:return: Generated random integer in range\n", 
  "SDL_HapticRunEffect": ":param haptic:\n:param effect:\n:param iterations:\n\nRuns the haptic effect on its associated haptic device.\n\nIf iterations are SDL_HAPTIC_INFINITY, it'll run the effect over and\nover repeating the envelope (attack and fade) every time. If you only\nwant the effect to last forever, set SDL_HAPTIC_INFINITY in the\neffect's length parameter.\n\nhaptic: Haptic device to run the effect on.\n\neffect: Identifier of the haptic effect to run.\n\niterations: Number of iterations to run the effect. Use\nSDL_HAPTIC_INFINITY for infinity.\n\n:return: 0 on success or -1 on error.SDL_HapticStopEffect\n\nSDL_HapticDestroyEffect\n\nSDL_HapticGetEffectStatus\n", 
  "SDLTest_DrawCharacter": ":param renderer:\n:param x:\n:param y:\n:param c:\n\nDraw a string in the currently set font.\n\nrenderer: The renderer to draw on.\n\nx: The X coordinate of the upper left corner of the character.\n\ny: The Y coordinate of the upper left corner of the character.\n\nc: The character to draw.\n\n:return: Returns 0 on success, -1 on failure.\n", 
  "SDL_RenderSetScale": ":param renderer:\n:param scaleX:\n:param scaleY:\n\nSet the drawing scale for rendering on the current target.\n\nrenderer: The renderer for which the drawing scale should be set.\n\nscaleX: The horizontal scaling factor\n\nscaleY: The vertical scaling factor\n\nThe drawing coordinates are scaled by the x/y scaling factors before\nthey are used by the renderer. This allows resolution independent\ndrawing with a single coordinate system.\n\nIf this results in scaling or subpixel drawing by the rendering\nbackend, it will be handled using the appropriate quality hints. For\nbest results use integer scaling factors.\n\nSDL_RenderGetScale()\n\nSDL_RenderSetLogicalSize()\n", 
  "SDL_RenderCopy": ":param renderer:\n:param texture:\n:param srcrect:\n:param dstrect:\n\nCopy a portion of the texture to the current rendering target.\n\nrenderer: The renderer which should copy parts of a texture.\n\ntexture: The source texture.\n\nsrcrect: A pointer to the source rectangle, or NULL for the entire\ntexture.\n\ndstrect: A pointer to the destination rectangle, or NULL for the\nentire rendering target.\n\n:return: 0 on success, or -1 on error\n", 
  "SDLTest_RandomUint32BoundaryValue": ":param boundary1:\n:param boundary2:\n:param validDomain:\n\nReturns a random boundary value for Uint32 within the given\nboundaries. Boundaries are inclusive, see the usage examples below. If\nvalidDomain is true, the function will only return valid boundaries,\notherwise non-valid boundaries are also possible. If boundary1 >\nboundary2, the values are swapped\n\nUsage examples: RandomUint32BoundaryValue(10, 20, SDL_TRUE) returns\n10, 11, 19 or 20 RandomUint32BoundaryValue(1, 20, SDL_FALSE) returns 0\nor 21 RandomUint32BoundaryValue(0, 99, SDL_FALSE) returns 100\nRandomUint32BoundaryValue(0, 0xFFFFFFFF, SDL_FALSE) returns 0 (with\nerror set)\n\nboundary1: Lower boundary limit\n\nboundary2: Upper boundary limit\n\nvalidDomain: Should the generated boundary be valid (=within the\nbounds) or not?\n\n:return: Random boundary value for the given range and domain or 0\nwith error set\n", 
  "SDL_GameControllerAddMapping": ":param mappingString:\n\nAdd or update an existing mapping configuration\n\n:return: 1 if mapping is added, 0 if updated, -1 on error\n", 
  "SDLTest_GetFuzzerInvocationCount": "\nReturns the invocation count for the fuzzer since last ...FuzzerInit.\n", 
  "SDL_GetDisplayName": ":param displayIndex:\n\nGet the name of a display in UTF-8 encoding.\n\n:return: The name of a display, or NULL for an invalid display\nindex.SDL_GetNumVideoDisplays()\n", 
  "SDL_FreeCursor": ":param cursor:\n\nFrees a cursor created with SDL_CreateCursor().\n\nSDL_CreateCursor()\n", 
  "SDL_HapticRumbleSupported": ":param haptic:\n\nChecks to see if rumble is supported on a haptic device.\n\nhaptic: Haptic device to check to see if it supports rumble.\n\n:return: SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1\non error.SDL_HapticRumbleInit\n\nSDL_HapticRumblePlay\n\nSDL_HapticRumbleStop\n", 
  "SDL_PauseAudioDevice": ":param dev:\n:param pause_on:\n", 
  "SDL_sin": ":param x:\n", 
  "SDL_GameControllerGetBindForButton": ":param gamecontroller:\n:param button:\n\nGet the SDL joystick layer binding for this controller button mapping\n", 
  "GLvdpauSurfaceNV": ":param PFNGLVDPAUREGISTERVIDEOSURFACENVPROC:\n", 
  "SDL_HasEvent": ":param type:\n\nChecks to see if certain event types are in the event queue.\n", 
  "SDL_lltoa": ":param value:\n:param str:\n:param radix:\n", 
  "SDL_wcslcat": ":param dst:\n:param src:\n:param maxlen:\n", 
  "SDL_SetColorKey": ":param surface:\n:param flag:\n:param key:\n\nSets the color key (transparent pixel) in a blittable surface.\n\nsurface: The surface to update\n\nflag: Non-zero to enable colorkey and 0 to disable colorkey\n\nkey: The transparent pixel in the native surface format\n\n:return: 0 on success, or -1 if the surface is not valid\n\nYou can pass SDL_RLEACCEL to enable RLE accelerated blits.\n", 
  "SDL_AtomicAdd": ":param a:\n:param v:\n\nAdd to an atomic variable.\n\n:return: The previous value of the atomic variable.This same style can\nbe used for any number operation\n", 
  "SDL_RenderDrawPoint": ":param renderer:\n:param x:\n:param y:\n\nDraw a point on the current rendering target.\n\nrenderer: The renderer which should draw a point.\n\nx: The x coordinate of the point.\n\ny: The y coordinate of the point.\n\n:return: 0 on success, or -1 on error\n", 
  "SDLTest_LogAssertSummary": "\nLogs summary of all assertions (total, pass, fail) since last reset as\nINFO or ERROR.\n", 
  "SDL_GetRelativeMouseState": ":param x:\n:param y:\n\nRetrieve the relative state of the mouse.\n\nThe current button state is returned as a button bitmask, which can be\ntested using the SDL_BUTTON(X) macros, and x and y are set to the\nmouse deltas since the last call to SDL_GetRelativeMouseState().\n", 
  "SDL_SetModState": ":param modstate:\n\nSet the current key modifier state for the keyboard.\n\nThis does not change the keyboard state, only the key modifier flags.\n", 
  "SDL_AtomicCAS": ":param a:\n:param oldval:\n:param newval:\n\nSet an atomic variable to a new value if it is currently an old value.\n\n:return: SDL_TRUE if the atomic variable was set, SDL_FALSE\notherwise.If you don't know what this function is for, you shouldn't\nuse it!\n", 
  "SDL_GetKeyboardState": ":param numkeys:\n\nGet a snapshot of the current state of the keyboard.\n\nnumkeys: if non-NULL, receives the length of the returned array.\n\n:return: An array of key states. Indexes into this array are obtained\nby using Example:*constUint8*state=SDL_GetKeyboardState(NULL);*if(stat\ne[SDL_SCANCODE_RETURN]){*printf(\"<RETURN>ispressed.\\n\");*}*\n", 
  "SDL_strlcat": ":param dst:\n:param src:\n:param maxlen:\n", 
  "SDL_GetCPUCount": "\nThis function returns the number of CPU cores available.\n", 
  "SDL_vsscanf": ":param text:\n:param fmt:\n:param ap:\n", 
  "SDL_MixAudio": ":param dst:\n:param src:\n:param len:\n:param volume:\n\nThis takes two audio buffers of the playing audio format and mixes\nthem, performing addition, volume adjustment, and overflow clipping.\nThe volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME\nfor full audio volume. Note this does not change hardware volume. This\nis provided for convenience  you can mix your own audio data.\n", 
  "SDL_HapticRumbleStop": ":param haptic:\n\nStops the simple rumble on a haptic device.\n\nhaptic: Haptic to stop the rumble on.\n\n:return: 0 on success or -1 on error.SDL_HapticRumbleSupported\n\nSDL_HapticRumbleInit\n\nSDL_HapticRumblePlay\n", 
  "SDL_strrchr": ":param str:\n:param c:\n", 
  "SDL_SetEventFilter": ":param filter:\n:param userdata:\n\nSets up a filter to process all events before they change internal\nstate and are posted to the internal event queue.\n\nThe filter is prototyped as:\n*intSDL_EventFilter(void*userdata,SDL_Event*event);*\n\nIf the filter returns 1, then the event will be added to the internal\nqueue. If it returns 0, then the event will be dropped from the queue,\nbut the internal state will still be updated. This allows selective\nfiltering of dynamically arriving events.\n\nBe very careful of what you do in the event filter function, as it may\nrun in a different thread!\n\nThere is one caveat when dealing with the SDL_QuitEvent event type.\nThe event filter is only called when the window manager desires to\nclose the application window. If the event filter returns 1, then the\nwindow will be closed, otherwise the window will remain open if\npossible.\n\nIf the quit event is generated by an interrupt signal, it will bypass\nthe internal queue and be delivered to the application at the next\nevent poll.\n", 
  "SDL_SaveAllDollarTemplates": ":param dst:\n\nSave all currently loaded Dollar Gesture templates.\n", 
  "SDL_SetClipboardText": ":param text:\n\nPut UTF-8 text into the clipboard.\n\nSDL_GetClipboardText()\n", 
  "SDL_free": ":param mem:\n", 
  "SDL_GetBasePath": "\nGet the path where the application resides.\n\nGet the \"base path\". This is the directory where the application was\nrun from, which is probably the installation directory, and may or may\nnot be the process's current working directory.\n\nThis returns an absolute path in UTF-8 encoding, and is guaranteed to\nend with a path separator ('\\' on Windows, '/' most other places).\n\nThe pointer returned by this function is owned by you. Please call\nSDL_free() on the pointer when you are done with it, or it will be a\nmemory leak. This is not necessarily a fast call, though, so you\nshould call this once near startup and save the string if you need it.\n\nSome platforms can't determine the application's path, and on other\nplatforms, this might be meaningless. In such cases, this function\nwill return NULL.\n\n:return: String of base dir in UTF-8 encoding, or NULL on\nerror.SDL_GetPrefPath\n", 
  "SDL_SetHintWithPriority": ":param name:\n:param value:\n:param priority:\n\nSet a hint with a specific priority.\n\nThe priority controls the behavior when setting a hint that already\nhas a value. Hints will replace existing hints of their priority and\nlower. Environment variables are considered to have override priority.\n\n:return: SDL_TRUE if the hint was set, SDL_FALSE otherwise\n", 
  "SDL_AddHintCallback": ":param name:\n:param callback:\n:param userdata:\n", 
  "SDL_GetWindowGammaRamp": ":param window:\n:param red:\n:param green:\n:param blue:\n\nGet the gamma ramp for a window.\n\nwindow: The window from which the gamma ramp should be queried.\n\nred: A pointer to a 256 element array of 16-bit quantities to hold the\ntranslation table for the red channel, or NULL.\n\ngreen: A pointer to a 256 element array of 16-bit quantities to hold\nthe translation table for the green channel, or NULL.\n\nblue: A pointer to a 256 element array of 16-bit quantities to hold\nthe translation table for the blue channel, or NULL.\n\n:return: 0 on success, or -1 if gamma ramps are\nunsupported.SDL_SetWindowGammaRamp()\n", 
  "SDL_GetCurrentAudioDriver": "\nThis function returns the name of the current audio driver, or NULL if\nno driver has been initialized.\n", 
  "SDLTest_RandomSint8BoundaryValue": ":param boundary1:\n:param boundary2:\n:param validDomain:\n\nReturns a random boundary value for Sint8 within the given boundaries.\nBoundaries are inclusive, see the usage examples below. If validDomain\nis true, the function will only return valid boundaries, otherwise\nnon-valid boundaries are also possible. If boundary1 > boundary2, the\nvalues are swapped\n\nUsage examples: RandomSint8BoundaryValue(-10, 20, SDL_TRUE) returns\n-11, -10, 19 or 20 RandomSint8BoundaryValue(-100, -10, SDL_FALSE)\nreturns -101 or -9 RandomSint8BoundaryValue(SINT8_MIN, 99, SDL_FALSE)\nreturns 100 RandomSint8BoundaryValue(SINT8_MIN, SINT8_MAX, SDL_FALSE)\nreturns SINT8_MIN (== error value) with error set\n\nboundary1: Lower boundary limit\n\nboundary2: Upper boundary limit\n\nvalidDomain: Should the generated boundary be valid (=within the\nbounds) or not?\n\n:return: Random boundary value for the given range and domain or\nSINT8_MIN with error set\n", 
  "SDL_wcslen": ":param wstr:\n", 
  "SDL_malloc": ":param size:\n", 
  "SDL_LogInfo": ":param category:\n:param fmt:\n:param :\n\nLog a message with SDL_LOG_PRIORITY_INFO.\n", 
  "SDL_GL_UnbindTexture": ":param texture:\n\nUnbind a texture from the current OpenGL/ES/ES2 context.\n\ntexture: The SDL texture to unbind\n\n:return: 0 on success, or -1 if the operation is not supported\n", 
  "SDL_PollEvent": ":param event:\n\nPolls for currently pending events.\n\n:return: 1 if there are any pending events, or 0 if there are none\navailable.event: If not NULL, the next event is removed from the queue\nand stored in that area.\n", 
  "SDL_ShowWindow": ":param window:\n\nShow a window.\n\nSDL_HideWindow()\n", 
  "SDLTest_RandomInitTime": ":param rndContext:\n\nInitialize random number generator based on current system time.\n\nrndContext: pointer to context structure\n", 
  "SDL_GetClipRect": ":param surface:\n:param rect:\n\nGets the clipping rectangle for the destination surface in a blit.\n\nrect must be a pointer to a valid rectangle which will be filled with\nthe correct values.\n", 
  "SDL_WriteBE16": ":param dst:\n:param value:\n", 
  "SDL_RenderCopyEx": ":param renderer:\n:param texture:\n:param srcrect:\n:param dstrect:\n:param angle:\n:param center:\n:param flip:\n\nCopy a portion of the source texture to the current rendering target,\nrotating it by angle around the given center.\n\nrenderer: The renderer which should copy parts of a texture.\n\ntexture: The source texture.\n\nsrcrect: A pointer to the source rectangle, or NULL for the entire\ntexture.\n\ndstrect: A pointer to the destination rectangle, or NULL for the\nentire rendering target.\n\nangle: An angle in degrees that indicates the rotation that will be\napplied to dstrect\n\ncenter: A pointer to a point indicating the point around which dstrect\nwill be rotated (if NULL, rotation will be done aroud dstrect.w/2,\ndstrect.h/2)\n\nflip: An SDL_RendererFlip value stating which flipping actions should\nbe performed on the texture\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_LoadObject": ":param sofile:\n\nThis function dynamically loads a shared object and returns a pointer\nto the object handle (or NULL if there was an error). The 'sofile'\nparameter is a system dependent name of the object file.\n", 
  "SDL_GetNumVideoDrivers": "\nGet the number of video drivers compiled into SDL.\n\nSDL_GetVideoDriver()\n", 
  "SDL_SetThreadPriority": ":param priority:\n\nSet the priority for the current thread\n", 
  "SDL_JoystickGetGUIDString": ":param guid:\n:param pszGUID:\n:param cbGUID:\n\nReturn a string representation for this guid. pszGUID must point to at\nleast 33 bytes (32 for the string plus a NULL terminator).\n", 
  "SDL_SetSurfacePalette": ":param surface:\n:param palette:\n\nSet the palette used by a surface.\n\n:return: 0, or -1 if the surface format doesn't use a palette.A single\npalette can be shared with many surfaces.\n", 
  "SDL_TLSCreate": "\nCreate an identifier that is globally visible to all threads but\nrefers to data that is thread-specific.\n\n:return: The newly created thread local storage identifier, or 0 on er\nror*staticSDL_SpinLocktls_lock;*staticSDL_TLSIDthread_local_storage;**\nvoidSetMyThreadData(void*value)*{*if(!thread_local_storage){*SDL_Atomi\ncLock(&tls_lock);*if(!thread_local_storage){*thread_local_storage=SDL_\nTLSCreate();*}*SDL_AtomicUnLock(&tls_lock);*}*SDL_TLSSet(thread_local_\nstorage,value);*}**void*GetMyThreadData(void)*{*returnSDL_TLSGet(threa\nd_local_storage);*}*\n\nSDL_TLSGet()\n\nSDL_TLSSet()\n", 
  "SDL_EventState": ":param type:\n:param state:\n\nThis function allows you to set the state of processing certain\nevents.If state is set to SDL_IGNORE, that event will be automatically\ndropped from the event queue and will not event be filtered.\n\nIf state is set to SDL_ENABLE, that event will be processed normally.\n\nIf state is set to SDL_QUERY, SDL_EventState() will return the current\nprocessing state of the specified event.\n", 
  "SDL_GetNumDisplayModes": ":param displayIndex:\n\nReturns the number of available display modes.\n\nSDL_GetDisplayMode()\n", 
  "SDL_LogDebug": ":param category:\n:param fmt:\n:param :\n\nLog a message with SDL_LOG_PRIORITY_DEBUG.\n", 
  "SDL_AddTimer": ":param interval:\n:param callback:\n:param param:\n\nAdd a new timer to the pool of timers already running.\n\n:return: A timer ID, or NULL when an error occurs.\n", 
  "SDL_GameControllerClose": ":param gamecontroller:\n\nClose a controller previously opened with SDL_GameControllerOpen().\n", 
  "SDL_AtomicSet": ":param a:\n:param v:\n\nSet an atomic variable to a value.\n\n:return: The previous value of the atomic variable.\n", 
  "SDL_GetSurfaceBlendMode": ":param surface:\n:param blendMode:\n\nGet the blend mode used for blit operations.\n\nsurface: The surface to query.\n\nblendMode: A pointer filled in with the current blend mode.\n\n:return: 0 on success, or -1 if the surface is not\nvalid.SDL_SetSurfaceBlendMode()\n", 
  "SDL_strcmp": ":param str1:\n:param str2:\n", 
  "SDL_MinimizeWindow": ":param window:\n\nMinimize a window to an iconic representation.\n\nSDL_RestoreWindow()\n", 
  "SDL_ReadLE16": ":param src:\n", 
  "SDL_AtomicCASPtr": ":param a:\n:param oldval:\n:param newval:\n\nSet a pointer to a new value if it is currently an old value.\n\n:return: SDL_TRUE if the pointer was set, SDL_FALSE otherwise.If you\ndon't know what this function is for, you shouldn't use it!\n", 
  "SDLTest_Crc32CalcStart": ":param crcContext:\n:param crc32:\n", 
  "SDLTest_RandomFloat": "\n:return: random float.\n", 
  "SDL_UnloadObject": ":param handle:\n\nUnload a shared object from memory.\n", 
  "SDL_GetWindowMaximumSize": ":param window:\n:param w:\n:param h:\n\nGet the maximum size of a window's client area.\n\nwindow: The window to query.\n\nw: Pointer to variable for storing the maximum width, may be NULL\n\nh: Pointer to variable for storing the maximum height, may be NULL\n\nSDL_GetWindowMinimumSize()\n\nSDL_SetWindowMaximumSize()\n", 
  "SDL_GetSurfaceColorMod": ":param surface:\n:param r:\n:param g:\n:param b:\n\nGet the additional color value used in blit operations.\n\nsurface: The surface to query.\n\nr: A pointer filled in with the current red color value.\n\ng: A pointer filled in with the current green color value.\n\nb: A pointer filled in with the current blue color value.\n\n:return: 0 on success, or -1 if the surface is not\nvalid.SDL_SetSurfaceColorMod()\n", 
  "SDL_AtomicGetPtr": ":param a:\n\nGet the value of a pointer atomically.\n", 
  "SDL_CreateWindowFrom": ":param data:\n\nCreate an SDL window from an existing native window.\n\ndata: A pointer to driver-dependent window creation data\n\n:return: The id of the window created, or zero if window creation\nfailed.SDL_DestroyWindow()\n", 
  "SDL_RecordGesture": ":param touchId:\n\nBegin Recording a gesture on the specified touch, or all touches (-1)\n", 
  "SDL_HasClipboardText": "\nReturns a flag indicating whether the clipboard exists and contains a\ntext string that is non-empty.\n\nSDL_GetClipboardText()\n", 
  "SDL_PushEvent": ":param event:\n\nAdd an event to the event queue.\n\n:return: 1 on success, 0 if the event was filtered, or -1 if the event\nqueue was full or there was some other error.\n", 
  "SDL_GameControllerNameForIndex": ":param joystick_index:\n\nGet the implementation dependent name of a game controller. This can\nbe called before any controllers are opened. If no name can be found,\nthis function returns NULL.\n", 
  "SDL_DestroyRenderer": ":param renderer:\n\nDestroy the rendering context for a window and free associated\ntextures.\n\nSDL_CreateRenderer()\n", 
  "SDL_Quit": "\nThis function cleans up all initialized subsystems. You should call it\nupon all exit conditions.\n", 
  "SDLTest_RandomDouble": "\n:return: random double.\n", 
  "SDL_GetRelativeMouseMode": "\nQuery whether relative mouse mode is enabled.\n\nSDL_SetRelativeMouseMode()\n", 
  "SDL_ShowSimpleMessageBox": ":param flags:\n:param title:\n:param message:\n:param window:\n\nCreate a simple modal message box.\n\nflags: SDL_MessageBoxFlags\n\ntitle: UTF-8 title text\n\nmessage: UTF-8 message text\n\nwindow: The parent window, or NULL for no parent\n\n:return: 0 on success, -1 on errorSDL_ShowMessageBox\n", 
  "SDL_OpenAudio": ":param desired:\n:param obtained:\n\nThis function opens the audio device with the desired parameters, and\nreturns 0 if successful, placing the actual hardware parameters in the\nstructure pointed to by obtained. If obtained is NULL, the audio data\npassed to the callback function will be guaranteed to be in the\nrequested format, and will be automatically converted to the hardware\naudio format if necessary. This function returns -1 if it failed to\nopen the audio device, or couldn't set up the audio thread.\n\nWhen filling in the desired audio spec structure,desired->freq should\nbe the desired audio frequency in samples-per- second.\n\ndesired->format should be the desired audio format.\n\ndesired->samples is the desired size of the audio buffer, in samples.\nThis number should be a power of two, and may be adjusted by the audio\ndriver to a value more suitable for the hardware. Good values seem to\nrange between 512 and 8096 inclusive, depending on the application and\nCPU speed. Smaller values yield faster response time, but can lead to\nunderflow if the application is doing heavy processing and cannot fill\nthe audio buffer in time. A stereo sample consists of both right and\nleft channels in LR ordering. Note that the number of samples is\ndirectly related to time by the following\nformula:ms=(samples*1000)/freq\n\ndesired->size is the size in bytes of the audio buffer, and is\ncalculated by SDL_OpenAudio().\n\ndesired->silence is the value used to set the buffer to silence, and\nis calculated by SDL_OpenAudio().\n\ndesired->callback should be set to a function that will be called when\nthe audio device is ready for more data. It is passed a pointer to the\naudio buffer, and the length in bytes of the audio buffer. This\nfunction usually runs in a separate thread, and so you should protect\ndata structures that it accesses by calling SDL_LockAudio() and\nSDL_UnlockAudio() in your code.\n\ndesired->userdata is passed as the first parameter to your callback\nfunction.\n\nThe audio device starts out playing silence when it's opened, and\nshould be enabled for playing by calling SDL_PauseAudio(0) when you\nare ready for your audio callback function to be called. Since the\naudio driver may modify the requested size of the audio buffer, you\nshould allocate any local mixing buffers after you open the audio\ndevice.\n", 
  "SDL_RenderSetViewport": ":param renderer:\n:param rect:\n\nSet the drawing area for rendering on the current target.\n\nrenderer: The renderer for which the drawing area should be set.\n\nrect: The rectangle representing the drawing area, or NULL to set the\nviewport to the entire target.\n\nThe x,y of the viewport rect represents the origin for rendering.\n\n:return: 0 on success, or -1 on errorIf the window associated with the\nrenderer is resized, the viewport is automatically reset.\n\nSDL_RenderGetViewport()\n\nSDL_RenderSetLogicalSize()\n", 
  "SDL_utf8strlcpy": ":param dst:\n:param src:\n:param dst_bytes:\n", 
  "SDL_wcslcpy": ":param dst:\n:param src:\n:param maxlen:\n", 
  "SDL_HapticPause": ":param haptic:\n\nPauses a haptic device.\n\nDevice must support the SDL_HAPTIC_PAUSE feature. Call\nSDL_HapticUnpause() to resume playback.\n\nDo not modify the effects nor add new ones while the device is paused.\nThat can cause all sorts of weird errors.\n\nhaptic: Haptic device to pause.\n\n:return: 0 on success or -1 on error.SDL_HapticUnpause\n", 
  "SDL_GetWindowTitle": ":param window:\n\nGet the title of a window, in UTF-8 format.\n\nSDL_SetWindowTitle()\n", 
  "SDL_MapRGB": ":param format:\n:param r:\n:param g:\n:param b:\n\nMaps an RGB triple to an opaque pixel value for a given pixel format.\n\nSDL_MapRGBA\n", 
  "SDL_GetWindowGrab": ":param window:\n\nGet a window's input grab mode.\n\n:return: This returns SDL_TRUE if input is grabbed, and SDL_FALSE\notherwise.SDL_SetWindowGrab()\n", 
  "SDL_IntersectRectAndLine": ":param rect:\n:param X1:\n:param Y1:\n:param X2:\n:param Y2:\n\nCalculate the intersection of a rectangle and line segment.\n\n:return: SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n", 
  "SDL_JoystickIsHaptic": ":param joystick:\n\nChecks to see if a joystick has haptic features.\n\njoystick: Joystick to test for haptic capabilities.\n\n:return: 1 if the joystick is haptic, 0 if it isn't or -1 if an error\nocurred.SDL_HapticOpenFromJoystick\n", 
  "SDL_GetKeyName": ":param key:\n\nGet a human-readable name for a key.\n\n:return: A pointer to a UTF-8 string that stays valid at least until\nthe next call to this function. If you need it around any longer, you\nmust copy it. If the key doesn't have a name, this function returns an\nempty string (\"\").SDL_Key\n", 
  "SDLTest_RunSuites": ":param testSuites:\n:param userRunSeed:\n:param userExecKey:\n:param filter:\n:param testIterations:\n\nExecute a test suite using the given run seed and execution key.\n\ntestSuites: Suites containing the test case.\n\nuserRunSeed: Custom run seed provided by user, or NULL to autogenerate\none.\n\nuserExecKey: Custom execution key provided by user, or 0 to\nautogenerate one.\n\nfilter: Filter specification. NULL disables. Case sensitive.\n\ntestIterations: Number of iterations to run each test case.\n\n:return: Test run result; 0 when all tests passed, 1 if any tests\nfailed.\n", 
  "SDL_main": ":param argc:\n:param argv:\n\nThe prototype for the application's main() function\n", 
  "SDL_LogSetPriority": ":param category:\n:param priority:\n\nSet the priority of a particular log category.\n", 
  "SDL_memcmp": ":param s1:\n:param s2:\n:param len:\n", 
  "SDL_RWFromFP": ":param fp:\n:param autoclose:\n", 
  "SDLTest_CommonQuit": ":param state:\n\nClose test window.\n\nstate: The common state used to create test window.\n", 
  "SDL_DisableScreenSaver": "\nPrevent the screen from being blanked by a screensaver.\n\nSDL_IsScreenSaverEnabled()\n\nSDL_EnableScreenSaver()\n", 
  "SDL_UnlockMutex": ":param mutex:\n", 
  "SDL_GetModState": "\nGet the current key modifier state for the keyboard.\n", 
  "SDL_CreateRGBSurface": ":param flags:\n:param width:\n:param height:\n:param depth:\n:param Rmask:\n:param Gmask:\n:param Bmask:\n:param Amask:\n\nAllocate and free an RGB surface.\n\nIf the depth is 4 or 8 bits, an empty palette is allocated for the\nsurface. If the depth is greater than 8 bits, the pixel format is set\nusing the flags '[RGB]mask'.\n\nIf the function runs out of memory, it will return NULL.\n\nflags: The flags are obsolete and should be set to 0.\n\nwidth: The width in pixels of the surface to create.\n\nheight: The height in pixels of the surface to create.\n\ndepth: The depth in bits of the surface to create.\n\nRmask: The red mask of the surface to create.\n\nGmask: The green mask of the surface to create.\n\nBmask: The blue mask of the surface to create.\n\nAmask: The alpha mask of the surface to create.\n", 
  "SDLTest_RandomUint8BoundaryValue": ":param boundary1:\n:param boundary2:\n:param validDomain:\n\nReturns a random boundary value for Uint8 within the given boundaries.\nBoundaries are inclusive, see the usage examples below. If validDomain\nis true, the function will only return valid boundaries, otherwise\nnon-valid boundaries are also possible. If boundary1 > boundary2, the\nvalues are swapped\n\nUsage examples: RandomUint8BoundaryValue(10, 20, SDL_TRUE) returns 10,\n11, 19 or 20 RandomUint8BoundaryValue(1, 20, SDL_FALSE) returns 0 or\n21 RandomUint8BoundaryValue(0, 99, SDL_FALSE) returns 100\nRandomUint8BoundaryValue(0, 255, SDL_FALSE) returns 0 (error set)\n\nboundary1: Lower boundary limit\n\nboundary2: Upper boundary limit\n\nvalidDomain: Should the generated boundary be valid (=within the\nbounds) or not?\n\n:return: Random boundary value for the given range and domain or 0\nwith error set\n", 
  "SDL_GetVersion": ":param ver:\n\nGet the version of SDL that is linked against your program.\n\nIf you are linking to SDL dynamically, then it is possible that the\ncurrent version will be different than the version you compiled\nagainst. This function returns the current version, while\nSDL_VERSION() is a macro that tells you what version you compiled\nwith.\n\n*SDL_versioncompiled;*SDL_versionlinked;**SDL_VERSION(&compiled);*SDL_\nGetVersion(&linked);*printf(\"WecompiledagainstSDLversion%d.%d.%d...\\n\"\n,*compiled.major,compiled.minor,compiled.patch);*printf(\"Butwelinkedag\nainstSDLversion%d.%d.%d.\\n\",*linked.major,linked.minor,linked.patch);*\n\nThis function may be called safely at any time, even before\nSDL_Init().\n\nSDL_VERSION\n", 
  "SDL_HapticSetGain": ":param haptic:\n:param gain:\n\nSets the global gain of the device.\n\nDevice must support the SDL_HAPTIC_GAIN feature.\n\nThe user may specify the maximum gain by setting the environment\nvariable SDL_HAPTIC_GAIN_MAX which should be between 0 and 100. All\ncalls to SDL_HapticSetGain() will scale linearly using\nSDL_HAPTIC_GAIN_MAX as the maximum.\n\nhaptic: Haptic device to set the gain on.\n\ngain: Value to set the gain to, should be between 0 and 100.\n\n:return: 0 on success or -1 on error.SDL_HapticQuery\n", 
  "SDL_CloseAudioDevice": ":param dev:\n", 
  "SDL_strlcpy": ":param dst:\n:param src:\n:param maxlen:\n", 
  "SDLTest_CommonEvent": ":param state:\n:param event:\n:param done:\n\nCommon event handler for test windows.\n\nstate: The common state used to create test window.\n\nevent: The event to handle.\n\ndone: Flag indicating we are done.\n", 
  "SDL_PixelFormatEnumToMasks": ":param format:\n:param bpp:\n:param Rmask:\n:param Gmask:\n:param Bmask:\n:param Amask:\n\nConvert one of the enumerated pixel formats to a bpp and RGBA masks.\n\n:return: SDL_TRUE, or SDL_FALSE if the conversion wasn't\npossible.SDL_MasksToPixelFormatEnum()\n", 
  "SDL_Delay": ":param ms:\n\nWait a specified number of milliseconds before returning.\n", 
  "SDL_GetVideoDriver": ":param index:\n\nGet the name of a built in video driver.\n\nThe video drivers are presented in the order in which they are\nnormally checked during initialization.\n\nSDL_GetNumVideoDrivers()\n", 
  "SDL_SetRelativeMouseMode": ":param enabled:\n\nSet relative mouse mode.\n\nenabled: Whether or not to enable relative mode\n\n:return: 0 on success, or -1 if relative mode is not supported.\n\nWhile the mouse is in relative mode, the cursor is hidden, and the\ndriver will try to report continuous motion in the current window.\nOnly relative motion events will be delivered, the mouse position will\nnot change.\n\nThis function will flush any pending mouse motion.\n\nSDL_GetRelativeMouseMode()\n", 
  "SDLTest_RandomUint64BoundaryValue": ":param boundary1:\n:param boundary2:\n:param validDomain:\n\nReturns a random boundary value for Uint64 within the given\nboundaries. Boundaries are inclusive, see the usage examples below. If\nvalidDomain is true, the function will only return valid boundaries,\notherwise non-valid boundaries are also possible. If boundary1 >\nboundary2, the values are swapped\n\nUsage examples: RandomUint64BoundaryValue(10, 20, SDL_TRUE) returns\n10, 11, 19 or 20 RandomUint64BoundaryValue(1, 20, SDL_FALSE) returns 0\nor 21 RandomUint64BoundaryValue(0, 99, SDL_FALSE) returns 100\nRandomUint64BoundaryValue(0, 0xFFFFFFFFFFFFFFFF, SDL_FALSE) returns 0\n(with error set)\n\nboundary1: Lower boundary limit\n\nboundary2: Upper boundary limit\n\nvalidDomain: Should the generated boundary be valid (=within the\nbounds) or not?\n\n:return: Random boundary value for the given range and domain or 0\nwith error set\n", 
  "SDL_SetWindowGrab": ":param window:\n:param grabbed:\n\nSet a window's input grab mode.\n\nwindow: The window for which the input grab mode should be set.\n\ngrabbed: This is SDL_TRUE to grab input, and SDL_FALSE to release\ninput.\n\nSDL_GetWindowGrab()\n", 
  "SDLTest_RandomUint8": "\nReturns a random Uint8\n\n:return: Generated integer\n", 
  "SDL_GetDesktopDisplayMode": ":param displayIndex:\n:param mode:\n\nFill in information about the desktop display mode.\n", 
  "SDL_HapticRumbleInit": ":param haptic:\n\nInitializes the haptic device for simple rumble playback.\n\nhaptic: Haptic device to initialize for simple rumble playback.\n\n:return: 0 on success or -1 on error.SDL_HapticOpen\n\nSDL_HapticRumbleSupported\n\nSDL_HapticRumblePlay\n\nSDL_HapticRumbleStop\n", 
  "SDL_GetPerformanceCounter": "\nGet the current value of the high resolution counter.\n", 
  "SDL_FreeSurface": ":param surface:\n", 
  "SDL_GetDisplayMode": ":param displayIndex:\n:param modeIndex:\n:param mode:\n\nFill in information about a specific display mode.\n\nThe display modes are sorted in this priority: bits per pixel -> more\ncolors to fewer colors\n\nwidth -> largest to smallest\n\nheight -> largest to smallest\n\nrefresh rate -> highest to lowest\n\nSDL_GetNumDisplayModes()\n", 
  "SDL_WriteLE64": ":param dst:\n:param value:\n", 
  "SDL_CondWait": ":param cond:\n:param mutex:\n\nWait on the condition variable, unlocking the provided mutex.\n\nThe mutex must be locked before entering this function!\n\nThe mutex is re-locked once the condition variable is signaled.\n\n:return: 0 when it is signaled, or -1 on error.\n", 
  "SDLTest_CommonUsage": ":param state:\n\nReturns common usage information.\n\nstate: The common state describing the test window to create.\n\n:return: String with usage information\n", 
  "SDL_WaitEvent": ":param event:\n\nWaits indefinitely for the next available event.\n\n:return: 1, or 0 if there was an error while waiting for events.event:\nIf not NULL, the next event is removed from the queue and stored in\nthat area.\n", 
  "SDL_GL_SetSwapInterval": ":param interval:\n\nSet the swap interval for the current OpenGL context.\n\ninterval: 0 for immediate updates, 1 for updates synchronized with the\nvertical retrace. If the system supports it, you may specify -1 to\nallow late swaps to happen immediately instead of waiting for the next\nretrace.\n\n:return: 0 on success, or -1 if setting the swap interval is not\nsupported.SDL_GL_GetSwapInterval()\n", 
  "SDL_SetHint": ":param name:\n:param value:\n\nSet a hint with normal priority.\n\n:return: SDL_TRUE if the hint was set, SDL_FALSE otherwise\n", 
  "SDL_FillRects": ":param dst:\n:param rects:\n:param count:\n:param color:\n", 
  "SDL_memcpy4": ":param dst:\n:param src:\n:param dwords:\n", 
  "SDL_ReadBE32": ":param src:\n", 
  "SDL_JoystickGetButton": ":param joystick:\n:param button:\n\nGet the current state of a button on a joystick.\n\nThe button indices start at index 0.\n", 
  "SDL_WarpMouseInWindow": ":param window:\n:param x:\n:param y:\n\nMoves the mouse to the given position within the window.\n\nwindow: The window to move the mouse into, or NULL for the current\nmouse focus\n\nx: The x coordinate within the window\n\ny: The y coordinate within the window\n\nThis function generates a mouse motion event\n", 
  "SDL_GetWindowMinimumSize": ":param window:\n:param w:\n:param h:\n\nGet the minimum size of a window's client area.\n\nwindow: The window to query.\n\nw: Pointer to variable for storing the minimum width, may be NULL\n\nh: Pointer to variable for storing the minimum height, may be NULL\n\nSDL_GetWindowMaximumSize()\n\nSDL_SetWindowMinimumSize()\n", 
  "SDLTest_RandomUnitDouble": "\n:return: random double in range [0.0 - 1.0[\n", 
  "SDL_GL_GetProcAddress": ":param proc:\n\nGet the address of an OpenGL function.\n", 
  "SDL_GetClipboardText": "\nGet UTF-8 text from the clipboard, which must be freed with SDL_free()\n\nSDL_SetClipboardText()\n", 
  "SDL_GL_BindTexture": ":param texture:\n:param texw:\n:param texh:\n\nBind the texture to the current OpenGL/ES/ES2 context for use with\nOpenGL instructions.\n\ntexture: The SDL texture to bind\n\ntexw: A pointer to a float that will be filled with the texture width\n\ntexh: A pointer to a float that will be filled with the texture height\n\n:return: 0 on success, or -1 if the operation is not supported\n", 
  "SDL_QueryTexture": ":param texture:\n:param format:\n:param access:\n:param w:\n:param h:\n\nQuery the attributes of a texture.\n\ntexture: A texture to be queried.\n\nformat: A pointer filled in with the raw format of the texture. The\nactual format may differ, but pixel transfers will use this format.\n\naccess: A pointer filled in with the actual access to the texture.\n\nw: A pointer filled in with the width of the texture in pixels.\n\nh: A pointer filled in with the height of the texture in pixels.\n\n:return: 0 on success, or -1 if the texture is not valid.\n", 
  "SDL_GL_MakeCurrent": ":param window:\n:param context:\n\nSet up an OpenGL context for rendering into an OpenGL window.\n\nThe context must have been created with a compatible window.\n", 
  "SDL_strcasecmp": ":param str1:\n:param str2:\n", 
  "SDL_calloc": ":param nmemb:\n:param size:\n", 
  "SDLTest_ResetAssertSummary": "\nResets the assert summary counters to zero.\n", 
  "SDL_GetTouchFinger": ":param touchID:\n:param index:\n\nGet the finger object of the given touch, with the given index.\n", 
  "SDL_SemWaitTimeout": ":param sem:\n:param ms:\n\nVariant of SDL_SemWait() with a timeout in milliseconds.\n\n:return: 0 if the wait succeeds, On some platforms this function is\nimplemented by looping with a delay of 1 ms, and so should be avoided\nif possible.\n", 
  "SDL_atan2": ":param x:\n:param y:\n", 
  "SDL_HapticNewEffect": ":param haptic:\n:param effect:\n\nCreates a new haptic effect on the device.\n\nhaptic: Haptic device to create the effect on.\n\neffect: Properties of the effect to create.\n\n:return: The id of the effect on success or -1 on\nerror.SDL_HapticUpdateEffect\n\nSDL_HapticRunEffect\n\nSDL_HapticDestroyEffect\n", 
  "SDL_GetRevisionNumber": "\nGet the revision number of SDL that is linked against your program.\n\nReturns a number uniquely identifying the exact revision of the SDL\nlibrary in use. It is an incrementing number based on commits to\nhg.libsdl.org.\n", 
  "SDL_GetWindowFromID": ":param id:\n\nGet a window from a stored ID, or NULL if it doesn't exist.\n", 
  "SDL_GL_GetDrawableSize": ":param window:\n:param w:\n:param h:\n\nGet the size of a window's underlying drawable (for use with\nglViewport).\n\nwindow: Window from which the drawable size should be queried\n\nw: Pointer to variable for storing the width, may be NULL\n\nh: Pointer to variable for storing the height, may be NULL\n\nThis may differ from SDL_GetWindowSize if we're rendering to a high-\nDPI drawable, i.e. the window was created with\nSDL_WINDOW_ALLOW_HIGHDPI on a platform with high-DPI support (Apple\ncalls this \"Retina\"), and not disabled by the\nSDL_HINT_VIDEO_HIGHDPI_DISABLED hint.\n\nSDL_GetWindowSize()\n\nSDL_CreateWindow()\n", 
  "SDL_PumpEvents": "\nPumps the event loop, gathering events from the input devices.\n\nThis function updates the event queue and internal input device state.\n\nThis should only be run in the thread that sets the video mode.\n", 
  "SDL_AllocFormat": ":param pixel_format:\n\nCreate an SDL_PixelFormat structure from a pixel format enum.\n", 
  "SDLTest_DrawString": ":param renderer:\n:param x:\n:param y:\n:param s:\n\nDraw a string in the currently set font.\n\nrenderer: The renderer to draw on.\n\nx: The X coordinate of the upper left corner of the string.\n\ny: The Y coordinate of the upper left corner of the string.\n\ns: The string to draw.\n\n:return: Returns 0 on success, -1 on failure.\n", 
  "SDL_GL_GetCurrentContext": "\nGet the currently active OpenGL context.\n", 
  "SDL_PauseAudio": ":param pause_on:\n", 
  "SDL_GameControllerMapping": ":param gamecontroller:\n\nGet a mapping string for an open GameController\n\n:return: the mapping string. Must be freed with SDL_free. Returns NULL\nif no mapping is available\n", 
  "SDL_GetWindowPixelFormat": ":param window:\n\nGet the pixel format associated with the window.\n", 
  "SDL_RWFromConstMem": ":param mem:\n:param size:\n", 
  "SDLTest_RandomAsciiStringOfSize": ":param size:\n\nGenerates random null-terminated string. The length for the string is\ndefined by the size parameter. String can contain ASCII characters\nfrom 32 to 126.\n\nNote: Returned string needs to be deallocated.\n\nsize: The length of the generated string\n\n:return: Newly allocated random string; or NULL if size was invalid or\nstring could not be allocated.\n", 
  "SDLTest_Crc32CalcBuffer": ":param crcContext:\n:param inBuf:\n:param inLen:\n:param crc32:\n", 
  "SDL_RestoreWindow": ":param window:\n\nRestore the size and position of a minimized or maximized window.\n\nSDL_MaximizeWindow()\n\nSDL_MinimizeWindow()\n", 
  "SDL_LockAudioDevice": ":param dev:\n", 
  "SDL_memset": ":param dst:\n:param c:\n:param len:\n", 
  "SDL_JoystickClose": ":param joystick:\n\nClose a joystick previously opened with SDL_JoystickOpen().\n", 
  "SDL_isspace": ":param x:\n", 
  "SDL_SetCursor": ":param cursor:\n\nSet the active cursor.\n", 
  "SDL_GetHint": ":param name:\n\nGet a hint.\n\n:return: The string value of a hint variable.\n", 
  "SDL_fabs": ":param x:\n", 
  "SDL_HasRDTSC": "\nThis function returns true if the CPU has the RDTSC instruction.\n", 
  "SDL_Swap32": ":param x:\n", 
  "SDL_GetWindowFlags": ":param window:\n\nGet the window flags.\n", 
  "SDL_SwapFloat": ":param x:\n", 
  "SDL_strupr": ":param str:\n", 
  "SDL_GL_DeleteContext": ":param context:\n\nDelete an OpenGL context.\n\nSDL_GL_CreateContext()\n", 
  "GLsync": ":param PFNGLFENCESYNCPROC:\n", 
  "SDL_strtoull": ":param str:\n:param endp:\n:param base:\n", 
  "SDLTest_RandomSint32": "\nReturns a random integer\n\n:return: Generated integer\n", 
  "SDL_CreateSemaphore": ":param initial_value:\n\nCreate a semaphore, initialized with value, returns NULL on failure.\n", 
  "SDL_WriteLE32": ":param dst:\n:param value:\n", 
  "SDL_LowerBlit": ":param src:\n:param srcrect:\n:param dst:\n:param dstrect:\n\nThis is a semi-private blit function and it performs low-level surface\nblitting only.\n", 
  "SDLTest_FuzzerInit": ":param execKey:\n\nInitializes the fuzzer for a test\n\n/param execKey Execution \"Key\" that initializes the random number\ngenerator uniquely for the test.\n", 
  "SDLTest_RandomSint32BoundaryValue": ":param boundary1:\n:param boundary2:\n:param validDomain:\n\nReturns a random boundary value for Sint32 within the given\nboundaries. Boundaries are inclusive, see the usage examples below. If\nvalidDomain is true, the function will only return valid boundaries,\notherwise non-valid boundaries are also possible. If boundary1 >\nboundary2, the values are swapped\n\nUsage examples: RandomSint32BoundaryValue(-10, 20, SDL_TRUE) returns\n-11, -10, 19 or 20 RandomSint32BoundaryValue(-100, -10, SDL_FALSE)\nreturns -101 or -9 RandomSint32BoundaryValue(SINT32_MIN, 99,\nSDL_FALSE) returns 100 RandomSint32BoundaryValue(SINT32_MIN,\nSINT32_MAX, SDL_FALSE) returns SINT32_MIN (== error value)\n\nboundary1: Lower boundary limit\n\nboundary2: Upper boundary limit\n\nvalidDomain: Should the generated boundary be valid (=within the\nbounds) or not?\n\n:return: Random boundary value for the given range and domain or\nSINT32_MIN with error set\n", 
  "SDL_CreateCond": "\nCreate a condition variable.\n\nTypical use of condition variables:\n\nThread A: SDL_LockMutex(lock); while ( ! condition ) {\nSDL_CondWait(cond, lock); } SDL_UnlockMutex(lock);\n\nThread B: SDL_LockMutex(lock); ... condition = true; ...\nSDL_CondSignal(cond); SDL_UnlockMutex(lock);\n\nThere is some discussion whether to signal the condition variable with\nthe mutex locked or not. There is some potential performance benefit\nto unlocking first on some platforms, but there are some potential\nrace conditions depending on how your code is structured.\n\nIn general it's safer to signal the condition variable while the mutex\nis locked.\n", 
  "SDL_GetWindowPosition": ":param window:\n:param x:\n:param y:\n\nGet the position of a window.\n\nwindow: The window to query.\n\nx: Pointer to variable for storing the x position, may be NULL\n\ny: Pointer to variable for storing the y position, may be NULL\n\nSDL_SetWindowPosition()\n", 
  "SDL_JoystickGetHat": ":param joystick:\n:param hat:\n\nGet the current state of a POV hat on a joystick.\n\nThe hat indices start at index 0.\n\n:return: The return value is one of the following positions:\n", 
  "SDL_GetNumRenderDrivers": "\nGet the number of 2D rendering drivers available for the current\ndisplay.\n\nA render driver is a set of code that handles rendering and texture\nmanagement on a particular display. Normally there is only one, but\nsome drivers may have several available with different capabilities.\n\nSDL_GetRenderDriverInfo()\n\nSDL_CreateRenderer()\n", 
  "SDL_GetRGB": ":param pixel:\n:param format:\n:param r:\n:param g:\n:param b:\n\nGet the RGB components from a pixel of the specified format.\n\nSDL_GetRGBA\n", 
  "SDL_HapticName": ":param device_index:\n\nGet the implementation dependent name of a Haptic device.\n\nThis can be called before any joysticks are opened. If no name can be\nfound, this function returns NULL.\n\ndevice_index: Index of the device to get its name.\n\n:return: Name of the device or NULL on error.SDL_NumHaptics\n", 
  "SDLTest_crc32Calc": ":param crcContext:\n:param inBuf:\n:param inLen:\n:param crc32:\n\n/brief calculate a crc32 from a data block\n\n/param crcContext pointer to context variable /param inBuf input\nbuffer to checksum /param inLen length of input buffer /param crc32\npointer to Uint32 to store the final CRC into\n\n/returns 0 for OK, -1 on error\n", 
  "SDL_WaitThread": ":param thread:\n:param status:\n\nWait for a thread to finish. Threads that haven't been detached will\nremain (as a \"zombie\") until this function cleans them up. Not doing\nso is a resource leak.\n\nOnce a thread has been cleaned up through this function, the\nSDL_Thread that references it becomes invalid and should not be\nreferenced again. As such, only one thread may call SDL_WaitThread()\non another.\n\nThe return code for the thread function is placed in the area pointed\nto by status, if status is not NULL.\n\nYou may not wait on a thread that has been used in a call to\nSDL_DetachThread(). Use either that function or this one, but not\nboth, or behavior is undefined.\n\nIt is safe to pass NULL to this function; it is a no-op.\n", 
  "SDLTest_CommonInit": ":param state:\n\nOpen test window.\n\nstate: The common state describing the test window to create.\n\n:return: True if initialization succeeded, false otherwise\n", 
  "SDL_RenderDrawRect": ":param renderer:\n:param rect:\n\nDraw a rectangle on the current rendering target.\n\nrenderer: The renderer which should draw a rectangle.\n\nrect: A pointer to the destination rectangle, or NULL to outline the\nentire rendering target.\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_WriteU8": ":param dst:\n:param value:\n", 
  "SDLTest_Assert": ":param assertCondition:\n:param assertDescription:\n:param :\n\nAssert that logs and break execution flow on failures.\n\nassertCondition: Evaluated condition or variable to assert; fail (==0)\nor pass (!=0).\n\nassertDescription: Message to log with the assert describing it.\n", 
  "SDL_iconv": ":param cd:\n:param inbuf:\n:param inbytesleft:\n:param outbuf:\n:param outbytesleft:\n", 
  "SDL_GetWindowDisplayIndex": ":param window:\n\nGet the display index associated with a window.\n\n:return: the display index of the display containing the center of the\nwindow, or -1 on error.\n", 
  "SDL_HapticQuery": ":param haptic:\n\nGets the haptic devices supported features in bitwise matter.\n\nExample: *if(SDL_HapticQuery(haptic)&SDL_HAPTIC_CONSTANT){*printf(\"Weh\naveconstanthapticeffect!\");*}*\n\nhaptic: The haptic device to query.\n\n:return: Haptic features in bitwise manner (OR'd).SDL_HapticNumEffects\n\nSDL_HapticEffectSupported\n", 
  "SDL_GL_GetAttribute": ":param attr:\n:param value:\n\nGet the actual value for an attribute from the current context.\n", 
  "SDL_GetWindowData": ":param window:\n:param name:\n\nRetrieve the data pointer associated with a window.\n\nwindow: The window to query.\n\nname: The name of the pointer.\n\n:return: The value associated with 'name'SDL_SetWindowData()\n", 
  "SDL_SetWindowIcon": ":param window:\n:param icon:\n\nSet the icon for a window.\n\nwindow: The window for which the icon should be set.\n\nicon: The icon for the window.\n", 
  "SDL_GetKeyFromScancode": ":param scancode:\n\nGet the key code corresponding to the given scancode according to the\ncurrent keyboard layout.\n\nSee SDL_Keycode for details.\n\nSDL_GetKeyName()\n", 
  "SDL_GetRGBA": ":param pixel:\n:param format:\n:param r:\n:param g:\n:param b:\n:param a:\n\nGet the RGBA components from a pixel of the specified format.\n\nSDL_GetRGB\n", 
  "SDL_UnlockSurface": ":param surface:\n\nSDL_LockSurface()\n", 
  "SDL_memmove": ":param dst:\n:param src:\n:param len:\n", 
  "SDL_GetPlatform": "\nGets the name of the platform.\n", 
  "SDL_SetWindowMinimumSize": ":param window:\n:param min_w:\n:param min_h:\n\nSet the minimum size of a window's client area.\n\nwindow: The window to set a new minimum size.\n\nmin_w: The minimum width of the window, must be >0\n\nmin_h: The minimum height of the window, must be >0\n\nYou can't change the minimum size of a fullscreen window, it\nautomatically matches the size of the display mode.\n\nSDL_GetWindowMinimumSize()\n\nSDL_SetWindowMaximumSize()\n", 
  "SDL_ReportAssertion": ":param :\n:param :\n:param :\n:param :\n", 
  "SDL_memset4": ":param dst:\n:param val:\n:param dwords:\n", 
  "SDL_GetSurfaceAlphaMod": ":param surface:\n:param alpha:\n\nGet the additional alpha value used in blit operations.\n\nsurface: The surface to query.\n\nalpha: A pointer filled in with the current alpha value.\n\n:return: 0 on success, or -1 if the surface is not\nvalid.SDL_SetSurfaceAlphaMod()\n", 
  "SDL_SetWindowFullscreen": ":param window:\n:param flags:\n\nSet a window's fullscreen state.\n\n:return: 0 on success, or -1 if setting the display mode\nfailed.SDL_SetWindowDisplayMode()\n\nSDL_GetWindowDisplayMode()\n", 
  "SDLTest_RandomInit": ":param rndContext:\n:param xi:\n:param ci:\n\nInitialize random number generator with two integers.\n\nNote: The random sequence of numbers returned by ...Random() is the\nsame for the same two integers and has a period of 2^31.\n\nrndContext: pointer to context structure\n\nxi: integer that defines the random sequence\n\nci: integer that defines the random sequence\n", 
  "SDL_HasSSE": "\nThis function returns true if the CPU has SSE features.\n", 
  "SDL_AtomicLock": ":param lock:\n\nLock a spin lock by setting it to a non-zero value.\n\nlock: Points to the lock.\n", 
  "SDL_CreateSystemCursor": ":param id:\n\nCreate a system cursor.\n\nSDL_FreeCursor()\n", 
  "SDL_HapticOpened": ":param device_index:\n\nChecks if the haptic device at index has been opened.\n\ndevice_index: Index to check to see if it has been opened.\n\n:return: 1 if it has been opened or 0 if it hasn't.SDL_HapticOpen\n\nSDL_HapticIndex\n", 
  "SDL_SemValue": ":param sem:\n\nReturns the current count of the semaphore.\n", 
  "SDL_ReadBE64": ":param src:\n", 
  "SDLTest_CompareSurfaces": ":param surface:\n:param referenceSurface:\n:param allowable_error:\n\nCompares a surface and with reference image data for equality.\n\nsurface: Surface used in comparison\n\nreferenceSurface: Test Surface used in comparison\n\nallowable_error: Allowable difference (squared) in blending accuracy.\n\n:return: 0 if comparison succeeded, >0 (=number of pixels where\ncomparison failed) if comparison failed, -1 if any of the surfaces\nwere NULL, -2 if the surface sizes differ.\n", 
  "SDL_JoystickNameForIndex": ":param device_index:\n\nGet the implementation dependent name of a joystick. This can be\ncalled before any joysticks are opened. If no name can be found, this\nfunction returns NULL.\n", 
  "SDL_LoadDollarTemplates": ":param touchId:\n:param src:\n\nLoad Dollar Gesture templates from a file.\n", 
  "SDL_HasAVX": "\nThis function returns true if the CPU has AVX features.\n", 
  "SDL_GetCursor": "\nReturn the active cursor.\n", 
  "SDL_GameControllerMappingForGUID": ":param guid:\n\nGet a mapping string for a GUID\n\n:return: the mapping string. Must be freed with SDL_free. Returns NULL\nif no mapping is available\n", 
  "SDL_SaveBMP_RW": ":param surface:\n:param dst:\n:param freedst:\n\nSave a surface to a seekable SDL data stream (memory or file).\n\nIf freedst is non-zero, the stream will be closed after being written.\n\n:return: 0 if successful or -1 if there was an error.\n", 
  "SDL_HapticUnpause": ":param haptic:\n\nUnpauses a haptic device.\n\nCall to unpause after SDL_HapticPause().\n\nhaptic: Haptic device to pause.\n\n:return: 0 on success or -1 on error.SDL_HapticPause\n", 
  "SDL_HapticSetAutocenter": ":param haptic:\n:param autocenter:\n\nSets the global autocenter of the device.\n\nAutocenter should be between 0 and 100. Setting it to 0 will disable\nautocentering.\n\nDevice must support the SDL_HAPTIC_AUTOCENTER feature.\n\nhaptic: Haptic device to set autocentering on.\n\nautocenter: Value to set autocenter to, 0 disables autocentering.\n\n:return: 0 on success or -1 on error.SDL_HapticQuery\n", 
  "SDLTest_RandomSint16BoundaryValue": ":param boundary1:\n:param boundary2:\n:param validDomain:\n\nReturns a random boundary value for Sint16 within the given\nboundaries. Boundaries are inclusive, see the usage examples below. If\nvalidDomain is true, the function will only return valid boundaries,\notherwise non-valid boundaries are also possible. If boundary1 >\nboundary2, the values are swapped\n\nUsage examples: RandomSint16BoundaryValue(-10, 20, SDL_TRUE) returns\n-11, -10, 19 or 20 RandomSint16BoundaryValue(-100, -10, SDL_FALSE)\nreturns -101 or -9 RandomSint16BoundaryValue(SINT16_MIN, 99,\nSDL_FALSE) returns 100 RandomSint16BoundaryValue(SINT16_MIN,\nSINT16_MAX, SDL_FALSE) returns SINT16_MIN (== error value) with error\nset\n\nboundary1: Lower boundary limit\n\nboundary2: Upper boundary limit\n\nvalidDomain: Should the generated boundary be valid (=within the\nbounds) or not?\n\n:return: Random boundary value for the given range and domain or\nSINT16_MIN with error set\n", 
  "SDL_SetAssertionHandler": ":param handler:\n:param userdata:\n\nSet an application-defined assertion handler.\n\nThis allows an app to show its own assertion UI and/or force the\nresponse to an assertion failure. If the app doesn't provide this, SDL\nwill try to do the right thing, popping up a system-specific GUI\ndialog, and probably minimizing any fullscreen windows.\n\nThis callback may fire from any thread, but it runs wrapped in a\nmutex, so it will only fire from one thread at a time.\n\nSetting the callback to NULL restores SDL's original internal handler.\n\nThis callback is NOT reset to SDL's internal handler upon SDL_Quit()!\n\n:return: SDL_assert_state value of how to handle the assertion\nfailure.handler: Callback function, called when an assertion fails.\n\nuserdata: A pointer passed to the callback as-is.\n", 
  "SDL_iconv_string": ":param tocode:\n:param fromcode:\n:param inbuf:\n:param inbytesleft:\n\nThis function converts a string between encodings in one pass,\nreturning a string that must be freed with SDL_free() or NULL on\nerror.\n", 
  "SDL_UpdateWindowSurfaceRects": ":param window:\n:param rects:\n:param numrects:\n\nCopy a number of rectangles on the window surface to the screen.\n\n:return: 0 on success, or -1 on error.SDL_GetWindowSurface()\n\nSDL_UpdateWindowSurfaceRect()\n", 
  "SDL_QuitSubSystem": ":param flags:\n\nThis function cleans up specific SDL subsystems\n", 
  "SDL_VideoInit": ":param driver_name:\n\nInitialize the video subsystem, optionally specifying a video driver.\n\ndriver_name: Initialize a specific driver by name, or NULL for the\ndefault video driver.\n\n:return: 0 on success, -1 on error\n\nThis function initializes the video subsystem; setting up a connection\nto the window manager, etc, and determines the available display modes\nand pixel formats, but does not initialize a window or graphics mode.\n\nSDL_VideoQuit()\n", 
  "SDLTest_RandomUnitFloat": "\n:return: random float in range [0.0 - 1.0[\n", 
  "SDL_GetDisplayBounds": ":param displayIndex:\n:param rect:\n\nGet the desktop area represented by a display, with the primary\ndisplay located at 0,0.\n\n:return: 0 on success, or -1 if the index is out of\nrange.SDL_GetNumVideoDisplays()\n", 
  "SDL_HapticNumEffects": ":param haptic:\n\nReturns the number of effects a haptic device can store.\n\nOn some platforms this isn't fully supported, and therefore is an\napproximation. Always check to see if your created effect was actually\ncreated and do not rely solely on SDL_HapticNumEffects().\n\nhaptic: The haptic device to query effect max.\n\n:return: The number of effects the haptic device can store or -1 on\nerror.SDL_HapticNumEffectsPlaying\n\nSDL_HapticQuery\n", 
  "SDLTest_CommonArg": ":param state:\n:param index:\n\nProcess one common argument.\n\nstate: The common state describing the test window to create.\n\nindex: The index of the argument to process in argv[].\n\n:return: The number of arguments processed (i.e. 1 for\n", 
  "SDL_SetWindowMaximumSize": ":param window:\n:param max_w:\n:param max_h:\n\nSet the maximum size of a window's client area.\n\nwindow: The window to set a new maximum size.\n\nmax_w: The maximum width of the window, must be >0\n\nmax_h: The maximum height of the window, must be >0\n\nYou can't change the maximum size of a fullscreen window, it\nautomatically matches the size of the display mode.\n\nSDL_GetWindowMaximumSize()\n\nSDL_SetWindowMinimumSize()\n", 
  "SDL_HapticClose": ":param haptic:\n\nCloses a Haptic device previously opened with SDL_HapticOpen().\n\nhaptic: Haptic device to close.\n", 
  "SDL_SetPixelFormatPalette": ":param format:\n:param palette:\n\nSet the palette for a pixel format structure.\n", 
  "SDL_HapticDestroyEffect": ":param haptic:\n:param effect:\n\nDestroys a haptic effect on the device.\n\nThis will stop the effect if it's running. Effects are automatically\ndestroyed when the device is closed.\n\nhaptic: Device to destroy the effect on.\n\neffect: Identifier of the effect to destroy.\n\nSDL_HapticNewEffect\n", 
  "SDL_RenderPresent": ":param renderer:\n\nUpdate the screen with rendering performed.\n", 
  "SDL_HasSSE41": "\nThis function returns true if the CPU has SSE4.1 features.\n", 
  "SDL_HasSSE42": "\nThis function returns true if the CPU has SSE4.2 features.\n", 
  "SDLTest_RandomSint64BoundaryValue": ":param boundary1:\n:param boundary2:\n:param validDomain:\n\nReturns a random boundary value for Sint64 within the given\nboundaries. Boundaries are inclusive, see the usage examples below. If\nvalidDomain is true, the function will only return valid boundaries,\notherwise non-valid boundaries are also possible. If boundary1 >\nboundary2, the values are swapped\n\nUsage examples: RandomSint64BoundaryValue(-10, 20, SDL_TRUE) returns\n-11, -10, 19 or 20 RandomSint64BoundaryValue(-100, -10, SDL_FALSE)\nreturns -101 or -9 RandomSint64BoundaryValue(SINT64_MIN, 99,\nSDL_FALSE) returns 100 RandomSint64BoundaryValue(SINT64_MIN,\nSINT64_MAX, SDL_FALSE) returns SINT64_MIN (== error value) and error\nset\n\nboundary1: Lower boundary limit\n\nboundary2: Upper boundary limit\n\nvalidDomain: Should the generated boundary be valid (=within the\nbounds) or not?\n\n:return: Random boundary value for the given range and domain or\nSINT64_MIN with error set\n", 
  "SDL_DelHintCallback": ":param name:\n:param callback:\n:param userdata:\n\nRemove a function watching a particular hint.\n\nname: The hint being watched\n\ncallback: The function being called when the hint value changes\n\nuserdata: A pointer being passed to the callback function\n", 
  "SDL_JoystickGetGUIDFromString": ":param pchGUID:\n\nconvert a string into a joystick formatted guid\n", 
  "SDL_ultoa": ":param value:\n:param str:\n:param radix:\n", 
  "SDL_LogSetAllPriority": ":param priority:\n\nSet the priority of all log categories.\n", 
  "SDL_SetRenderDrawBlendMode": ":param renderer:\n:param blendMode:\n\nSet the blend mode used for drawing operations (Fill and Line).\n\nrenderer: The renderer for which blend mode should be set.\n\nblendMode: SDL_BlendMode to use for blending.\n\n:return: 0 on success, or -1 on errorIf the blend mode is not\nsupported, the closest supported mode is chosen.\n\nSDL_GetRenderDrawBlendMode()\n", 
  "SDL_FilterEvents": ":param filter:\n:param userdata:\n\nRun the filter function on the current event queue, removing any\nevents for which the filter returns 0.\n", 
  "SDLTest_RandomAsciiString": "\nGenerates random null-terminated string. The minimum length for the\nstring is 1 character, maximum length for the string is 255 characters\nand it can contain ASCII characters from 32 to 126.\n\nNote: Returned string needs to be deallocated.\n\n:return: Newly allocated random string; or NULL if length was invalid\nor string could not be allocated.\n", 
  "SDLTest_LogError": ":param fmt:\n:param :\n\nPrints given message with a timestamp in the TEST category and the\nERROR priority.\n\nfmt: Message to be logged\n", 
  "SDL_GetPrefPath": ":param org:\n:param app:\n\nGet the user-and-app-specific path where files can be written.\n\nGet the \"pref dir\". This is meant to be where users can write personal\nfiles (preferences and save games, etc) that are specific to your\napplication. This directory is unique per user, per application.\n\nThis function will decide the appropriate location in the native\nfilesystem, create the directory if necessary, and return a string of\nthe absolute path to the directory in UTF-8 encoding.\n\nOn Windows, the string might look like:\n\"C:\\\\Users\\\\bob\\\\AppData\\\\Roaming\\\\My Company\\\\My Program Name\\\\\"\n\nOn Linux, the string might look like: \"/home/bob/.local/share/My\nProgram Name/\"\n\nOn Mac OS X, the string might look like:\n\"/Users/bob/Library/Application Support/My Program Name/\"\n\n(etc.)\n\nYou specify the name of your organization (if it's not a real\norganization, your name or an Internet domain you own might do) and\nthe name of your application. These should be untranslated proper\nnames.\n\nBoth the org and app strings may become part of a directory name, so\nplease follow these rules:\n\nTry to use the same org string (including case-sensitivity) for all\nyour applications that use this function.\n\nAlways use a unique app string for each one, and make sure it never\nchanges for an app once you've decided on it.\n\nUnicode characters are legal, as long as it's UTF-8 encoded, but...\n\n...only use letters, numbers, and spaces. Avoid punctuation like \"Game\nName 2: Bad Guy's Revenge!\" ... \"Game Name 2\" is sufficient.\n\nThis returns an absolute path in UTF-8 encoding, and is guaranteed to\nend with a path separator ('\\' on Windows, '/' most other places).\n\nThe pointer returned by this function is owned by you. Please call\nSDL_free() on the pointer when you are done with it, or it will be a\nmemory leak. This is not necessarily a fast call, though, so you\nshould call this once near startup and save the string if you need it.\n\nYou should assume the path returned by this function is the only safe\nplace to write files (and that SDL_GetBasePath(), while it might be\nwritable, or even the parent of the returned path, aren't where you\nshould be writing things).\n\nSome platforms can't determine the pref path, and on other platforms,\nthis might be meaningless. In such cases, this function will return\nNULL.\n\norg: The name of your organization.\n\napp: The name of your application.\n\n:return: UTF-8 string of user dir in platform-dependent notation. NULL\nif there's a problem (creating directory failed, etc).SDL_GetBasePath\n", 
  "SDL_TryLockMutex": ":param mutex:\n\nTry to lock the mutex\n\n:return: 0, SDL_MUTEX_TIMEDOUT, or -1 on error\n", 
  "SDLTest_AssertSummaryToTestResult": "\nConverts the current assert summary state to a test result.\n\n:return: TEST_RESULT_PASSED, TEST_RESULT_FAILED, or\nTEST_RESULT_NO_ASSERT\n", 
  "SDLTest_AssertCheck": ":param assertCondition:\n:param assertDescription:\n:param :\n\nAssert for test cases that logs but does not break execution flow on\nfailures. Updates assertion counters.\n\nassertCondition: Evaluated condition or variable to assert; fail (==0)\nor pass (!=0).\n\nassertDescription: Message to log with the assert describing it.\n\n:return: Returns the assertCondition so it can be used to externally\nto break execution flow if desired.\n", 
  "SDL_DelEventWatch": ":param filter:\n:param userdata:\n\nRemove an event watch function added with SDL_AddEventWatch()\n", 
  "SDL_iconv_close": ":param cd:\n", 
  "SDL_CreateMutex": "\nCreate a mutex, initialized unlocked.\n", 
  "SDL_SetSurfaceAlphaMod": ":param surface:\n:param alpha:\n\nSet an additional alpha value used in blit operations.\n\nsurface: The surface to update.\n\nalpha: The alpha value multiplied into blit operations.\n\n:return: 0 on success, or -1 if the surface is not\nvalid.SDL_GetSurfaceAlphaMod()\n", 
  "SDL_RegisterApp": ":param name:\n:param style:\n:param hInst:\n\nThis can be called to set the application class at startup\n", 
  "SDL_Swap64": ":param x:\n", 
  "SDL_strrev": ":param str:\n", 
  "SDL_ConvertSurfaceFormat": ":param src:\n:param pixel_format:\n:param flags:\n", 
  "SDL_GetRenderDriverInfo": ":param index:\n:param info:\n\nGet information about a specific 2D rendering driver for the current\ndisplay.\n\nindex: The index of the driver to query information about.\n\ninfo: A pointer to an SDL_RendererInfo struct to be filled with\ninformation on the rendering driver.\n\n:return: 0 on success, -1 if the index was out of\nrange.SDL_CreateRenderer()\n", 
  "SDL_UnlockTexture": ":param texture:\n\nUnlock a texture, uploading the changes to video memory, if needed.\n\nSDL_LockTexture()\n", 
  "SDL_GetTextureColorMod": ":param texture:\n:param r:\n:param g:\n:param b:\n\nGet the additional color value used in render copy operations.\n\ntexture: The texture to query.\n\nr: A pointer filled in with the current red color value.\n\ng: A pointer filled in with the current green color value.\n\nb: A pointer filled in with the current blue color value.\n\n:return: 0 on success, or -1 if the texture is not\nvalid.SDL_SetTextureColorMod()\n", 
  "SDL_RegisterEvents": ":param numevents:\n\nThis function allocates a set of user-defined events, and returns the\nbeginning event number for that set of events.\n\nIf there aren't enough user-defined events left, this function returns\n(Uint32)-1\n", 
  "SDL_WaitEventTimeout": ":param event:\n:param timeout:\n\nWaits until the specified timeout (in milliseconds) for the next\navailable event.\n\n:return: 1, or 0 if there was an error while waiting for events.event:\nIf not NULL, the next event is removed from the queue and stored in\nthat area.\n\ntimeout: The timeout (in milliseconds) to wait for next event.\n", 
  "SDL_GameControllerName": ":param gamecontroller:\n\nReturn the name for this currently opened controller\n", 
  "SDL_SetWindowBrightness": ":param window:\n:param brightness:\n\nSet the brightness (gamma correction) for a window.\n\n:return: 0 on success, or -1 if setting the brightness isn't\nsupported.SDL_GetWindowBrightness()\n\nSDL_SetWindowGammaRamp()\n", 
  "SDL_Has3DNow": "\nThis function returns true if the CPU has 3DNow! features.\n", 
  "SDL_UpdateWindowSurface": ":param window:\n\nCopy the window surface to the screen.\n\n:return: 0 on success, or -1 on error.SDL_GetWindowSurface()\n\nSDL_UpdateWindowSurfaceRects()\n", 
  "SDL_WriteBE64": ":param dst:\n:param value:\n", 
  "unsigned": ":param func:\n", 
  "SDL_GameControllerOpen": ":param joystick_index:\n\nOpen a game controller for use. The index passed as an argument refers\nto the N'th game controller on the system. This index is the value\nwhich will identify this controller in future controller events.\n\n:return: A controller identifier, or NULL if an error occurred.\n", 
  "SDL_RenderGetViewport": ":param renderer:\n:param rect:\n\nGet the drawing area for the current target.\n\nSDL_RenderSetViewport()\n", 
  "SDL_GetThreadName": ":param thread:\n\nGet the thread name, as it was specified in SDL_CreateThread(). This\nfunction returns a pointer to a UTF-8 string that names the specified\nthread, or NULL if it doesn't have a name. This is internal memory,\nnot to be free()'d by the caller, and remains valid until the\nspecified thread is cleaned up by SDL_WaitThread().\n", 
  "SDL_RenderDrawLine": ":param renderer:\n:param x1:\n:param y1:\n:param x2:\n:param y2:\n\nDraw a line on the current rendering target.\n\nrenderer: The renderer which should draw a line.\n\nx1: The x coordinate of the start point.\n\ny1: The y coordinate of the start point.\n\nx2: The x coordinate of the end point.\n\ny2: The y coordinate of the end point.\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_SetSurfaceColorMod": ":param surface:\n:param r:\n:param g:\n:param b:\n\nSet an additional color value used in blit operations.\n\nsurface: The surface to update.\n\nr: The red color value multiplied into blit operations.\n\ng: The green color value multiplied into blit operations.\n\nb: The blue color value multiplied into blit operations.\n\n:return: 0 on success, or -1 if the surface is not\nvalid.SDL_GetSurfaceColorMod()\n", 
  "GLuint": ":param PFNGLCREATEPROGRAMPROC:\n", 
  "SDL_GetNumTouchFingers": ":param touchID:\n\nGet the number of active fingers for a given touch device.\n", 
  "SDL_AtomicTryLock": ":param lock:\n\nTry to lock a spin lock by setting it to a non-zero value.\n\nlock: Points to the lock.\n\n:return: SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is\nalready held.\n", 
  "SDL_GL_GetCurrentWindow": "\nGet the currently active OpenGL window.\n", 
  "SDL_WasInit": ":param flags:\n\nThis function returns a mask of the specified subsystems which have\npreviously been initialized.\n\nIf flags is 0, it returns a mask of all initialized subsystems.\n", 
  "SDL_FlushEvents": ":param minType:\n:param maxType:\n", 
  "SDLTest_RandomUint16BoundaryValue": ":param boundary1:\n:param boundary2:\n:param validDomain:\n\nReturns a random boundary value for Uint16 within the given\nboundaries. Boundaries are inclusive, see the usage examples below. If\nvalidDomain is true, the function will only return valid boundaries,\notherwise non-valid boundaries are also possible. If boundary1 >\nboundary2, the values are swapped\n\nUsage examples: RandomUint16BoundaryValue(10, 20, SDL_TRUE) returns\n10, 11, 19 or 20 RandomUint16BoundaryValue(1, 20, SDL_FALSE) returns 0\nor 21 RandomUint16BoundaryValue(0, 99, SDL_FALSE) returns 100\nRandomUint16BoundaryValue(0, 0xFFFF, SDL_FALSE) returns 0 (error set)\n\nboundary1: Lower boundary limit\n\nboundary2: Upper boundary limit\n\nvalidDomain: Should the generated boundary be valid (=within the\nbounds) or not?\n\n:return: Random boundary value for the given range and domain or 0\nwith error set\n", 
  "SDL_RenderGetClipRect": ":param renderer:\n:param rect:\n\nGet the clip rectangle for the current target.\n\nrenderer: The renderer from which clip rectangle should be queried.\n\nrect: A pointer filled in with the current clip rectangle, or an empty\nrectangle if clipping is disabled.\n\nSDL_RenderSetClipRect()\n", 
  "SDL_LogGetPriority": ":param category:\n\nGet the priority of a particular log category.\n", 
  "SDL_getenv": ":param name:\n", 
  "SDL_ulltoa": ":param value:\n:param str:\n:param radix:\n", 
  "SDL_abs": ":param x:\n", 
  "SDL_GameControllerGetAttached": ":param gamecontroller:\n\nReturns SDL_TRUE if the controller has been opened and currently\nconnected, or SDL_FALSE if it has not.\n", 
  "SDL_SetClipRect": ":param surface:\n:param rect:\n\nSets the clipping rectangle for the destination surface in a blit.\n\nIf the clip rectangle is NULL, clipping will be disabled.\n\nIf the clip rectangle doesn't intersect the surface, the function will\nreturn SDL_FALSE and blits will be completely clipped. Otherwise the\nfunction returns SDL_TRUE and blits to the surface will be clipped to\nthe intersection of the surface area and the clipping rectangle.\n\nNote that blits are automatically clipped to the edges of the source\nand destination surfaces.\n", 
  "SDL_RenderReadPixels": ":param renderer:\n:param rect:\n:param format:\n:param pixels:\n:param pitch:\n\nRead pixels from the current rendering target.\n\nrenderer: The renderer from which pixels should be read.\n\nrect: A pointer to the rectangle to read, or NULL for the entire\nrender target.\n\nformat: The desired format of the pixel data, or 0 to use the format\nof the rendering target\n\npixels: A pointer to be filled in with the pixel data\n\npitch: The pitch of the pixels parameter.\n\n:return: 0 on success, or -1 if pixel reading is not supported.This is\na very slow operation, and should not be used frequently.\n", 
  "SDL_SemPost": ":param sem:\n\nAtomically increases the semaphore's count (not blocking).\n\n:return: 0, or -1 on error.\n", 
  "SDL_SetError": ":param fmt:\n:param :\n", 
  "SDL_IsScreenSaverEnabled": "\nReturns whether the screensaver is currently enabled (default on).\n\nSDL_EnableScreenSaver()\n\nSDL_DisableScreenSaver()\n", 
  "SDL_ClearHints": "\nClear all hints.\n\nThis function is called during SDL_Quit() to free stored hints.\n", 
  "SDL_SetRenderTarget": ":param renderer:\n:param texture:\n\nSet a texture as the current rendering target.\n\nrenderer: The renderer.\n\ntexture: The targeted texture, which must be created with the\nSDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target\n\n:return: 0 on success, or -1 on errorSDL_GetRenderTarget()\n", 
  "SDL_log": ":param x:\n", 
  "SDL_RaiseWindow": ":param window:\n\nRaise a window above other windows and set the input focus.\n", 
  "SDL_ceil": ":param x:\n", 
  "SDL_LoadWAV_RW": ":param src:\n:param freesrc:\n:param spec:\n:param audio_buf:\n:param audio_len:\n\nThis function loads a WAVE from the data source, automatically freeing\nthat source if freesrc is non-zero. For example, to load a WAVE file,\nyou could do:\n*SDL_LoadWAV_RW(SDL_RWFromFile(\"sample.wav\",\"rb\"),1,...);*\n\nIf this function succeeds, it returns the given SDL_AudioSpec, filled\nwith the audio data format of the wave data, and sets *audio_buf to a\nmalloc()'d buffer containing the audio data, and sets *audio_len to\nthe length of that audio buffer, in bytes. You need to free the audio\nbuffer with SDL_FreeWAV() when you are done with it.\n\nThis function returns NULL and sets the SDL error message if the wave\nfile cannot be opened, uses an unknown data format, or is corrupt.\nCurrently raw and MS-ADPCM WAVE files are supported.\n", 
  "SDL_cosf": ":param x:\n", 
  "SDL_strtoll": ":param str:\n:param endp:\n:param base:\n", 
  "SDL_HapticOpenFromJoystick": ":param joystick:\n\nOpens a Haptic device for usage from a Joystick device.\n\nYou must still close the haptic device seperately. It will not be\nclosed with the joystick.\n\nWhen opening from a joystick you should first close the haptic device\nbefore closing the joystick device. If not, on some implementations\nthe haptic device will also get unallocated and you'll be unable to\nuse force feedback on that device.\n\njoystick: Joystick to create a haptic device from.\n\n:return: A valid haptic device identifier on success or NULL on\nerror.SDL_HapticOpen\n\nSDL_HapticClose\n", 
  "SDL_uitoa": ":param value:\n:param str:\n:param radix:\n", 
  "SDL_CondWaitTimeout": ":param cond:\n:param mutex:\n:param ms:\n\nWaits for at most ms milliseconds, and returns 0 if the condition\nvariable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not\nsignaled in the allotted time, and -1 on error.\n\nOn some platforms this function is implemented by looping with a delay\nof 1 ms, and so should be avoided if possible.\n", 
  "SDL_isdigit": ":param x:\n", 
  "SDL_CondSignal": ":param cond:\n\nRestart one of the threads that are waiting on the condition variable.\n\n:return: 0 or -1 on error.\n", 
  "SDL_IntersectRect": ":param A:\n:param B:\n:param result:\n\nCalculate the intersection of two rectangles.\n\n:return: SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n", 
  "SDL_JoystickNumAxes": ":param joystick:\n\nGet the number of general axis controls on a joystick.\n", 
  "SDL_DestroyWindow": ":param window:\n\nDestroy a window.\n", 
  "SDL_acos": ":param x:\n", 
  "SDL_MouseIsHaptic": "\nGets whether or not the current mouse has haptic capabilities.\n\n:return: SDL_TRUE if the mouse is haptic, SDL_FALSE if it\nisn't.SDL_HapticOpenFromMouse\n", 
  "SDL_qsort": ":param base:\n:param nmemb:\n:param size:\n:param compare:\n", 
  "SDL_PeepEvents": ":param events:\n:param numevents:\n:param action:\n:param minType:\n:param maxType:\n\nChecks the event queue for messages and optionally returns them.\n\nIf action is SDL_ADDEVENT, up to numevents events will be added to the\nback of the event queue.\n\nIf action is SDL_PEEKEVENT, up to numevents events at the front of the\nevent queue, within the specified minimum and maximum type, will be\nreturned and will not be removed from the queue.\n\nIf action is SDL_GETEVENT, up to numevents events at the front of the\nevent queue, within the specified minimum and maximum type, will be\nreturned and will be removed from the queue.\n\n:return: The number of events actually stored, or -1 if there was an\nerror.\n\nThis function is thread-safe.\n", 
  "SDL_NumHaptics": "\nCount the number of haptic devices attached to the system.\n\n:return: Number of haptic devices detected on the system.\n", 
  "SDL_GetTextureAlphaMod": ":param texture:\n:param alpha:\n\nGet the additional alpha value used in render copy operations.\n\ntexture: The texture to query.\n\nalpha: A pointer filled in with the current alpha value.\n\n:return: 0 on success, or -1 if the texture is not\nvalid.SDL_SetTextureAlphaMod()\n", 
  "SDL_scalbn": ":param x:\n:param n:\n", 
  "SDL_GL_ResetAttributes": "\nReset all previously set OpenGL context attributes to their default\nvalues.\n", 
  "SDL_GL_SetAttribute": ":param attr:\n:param value:\n\nSet an OpenGL window attribute before window creation.\n", 
  "SDL_IsTextInputActive": "\nReturn whether or not Unicode text input events are enabled.\n\nSDL_StartTextInput()\n\nSDL_StopTextInput()\n", 
  "SDL_GetWindowSurface": ":param window:\n\nGet the SDL surface associated with the window.\n\n:return: The window's framebuffer surface, or NULL on error.\n\nA new surface will be created with the optimal format for the window,\nif necessary. This surface will be freed when the window is destroyed.\n\nYou may not combine this with 3D or the rendering API on this window.\n\nSDL_UpdateWindowSurface()\n\nSDL_UpdateWindowSurfaceRects()\n", 
  "SDL_strstr": ":param haystack:\n:param needle:\n", 
  "SDL_JoystickGetGUID": ":param joystick:\n\nReturn the GUID for this opened joystick\n", 
  "SDL_GetEventFilter": ":param filter:\n:param userdata:\n\nReturn the current event filter - can be used to \"chain\" filters. If\nthere is no event filter set, this function returns SDL_FALSE.\n", 
  "SDL_GetNumTouchDevices": "\nGet the number of registered touch devices.\n", 
  "SDL_GetRendererOutputSize": ":param renderer:\n:param w:\n:param h:\n\nGet the output size of a rendering context.\n", 
  "SDL_GetColorKey": ":param surface:\n:param key:\n\nGets the color key (transparent pixel) in a blittable surface.\n\nsurface: The surface to update\n\nkey: A pointer filled in with the transparent pixel in the native\nsurface format\n\n:return: 0 on success, or -1 if the surface is not valid or colorkey\nis not enabled.\n", 
  "SDL_ConvertAudio": ":param cvt:\n\nOnce you have initialized the cvt structure using SDL_BuildAudioCVT(),\ncreated an audio buffer cvt->buf, and filled it with cvt->len bytes of\naudio data in the source format, this function will convert it in-\nplace to the desired format.\n\nThe data conversion may expand the size of the audio data, so the\nbuffer cvt->buf should be allocated after the cvt structure is\ninitialized by SDL_BuildAudioCVT(), and should be\ncvt->len*cvt->len_mult bytes long.\n", 
  "SDL_CreateWindow": ":param title:\n:param x:\n:param y:\n:param w:\n:param h:\n:param flags:\n\nCreate a window with the specified position, dimensions, and flags.\n\ntitle: The title of the window, in UTF-8 encoding.\n\nx: The x position of the window, SDL_WINDOWPOS_CENTERED, or\nSDL_WINDOWPOS_UNDEFINED.\n\ny: The y position of the window, SDL_WINDOWPOS_CENTERED, or\nSDL_WINDOWPOS_UNDEFINED.\n\nw: The width of the window.\n\nh: The height of the window.\n\nflags: The flags for the window, a mask of any of the following:\nSDL_WINDOW_FULLSCREEN, SDL_WINDOW_OPENGL, SDL_WINDOW_HIDDEN,\nSDL_WINDOW_BORDERLESS, SDL_WINDOW_RESIZABLE, SDL_WINDOW_MAXIMIZED,\nSDL_WINDOW_MINIMIZED, SDL_WINDOW_INPUT_GRABBED,\nSDL_WINDOW_ALLOW_HIGHDPI.\n\n:return: The id of the window created, or zero if window creation\nfailed.SDL_DestroyWindow()\n", 
  "SDL_HasSSE2": "\nThis function returns true if the CPU has SSE2 features.\n", 
  "SDL_DestroyTexture": ":param texture:\n\nDestroy the specified texture.\n\nSDL_CreateTexture()\n\nSDL_CreateTextureFromSurface()\n", 
  "SDL_Init": ":param flags:\n\nThis function initializes the subsystems specified by flags Unless the\nSDL_INIT_NOPARACHUTE flag is set, it will install cleanup signal\nhandlers for some commonly ignored fatal signals (like SIGSEGV).\n", 
  "SDL_GameControllerGetButtonFromString": ":param pchString:\n\nturn this string into a button mapping\n", 
  "SDL_JoystickName": ":param joystick:\n\nReturn the name for this currently opened joystick. If no name can be\nfound, this function returns NULL.\n", 
  "SDL_GameControllerUpdate": "\nUpdate the current state of the open game controllers.\n\nThis is called automatically by the event loop if any game controller\nevents are enabled.\n", 
  "SDL_GL_ExtensionSupported": ":param extension:\n\nReturn true if an OpenGL extension is supported for the current\ncontext.\n", 
  "SDL_GetShapedWindowMode": ":param window:\n:param shape_mode:\n\nGet the shape parameters of a shaped window.\n\nwindow: The shaped window whose parameters should be retrieved.\n\nshape_mode: An empty shape-mode structure to fill, or NULL to check\nwhether the window has a shape.\n\n:return: 0 if the window has a shape and, provided shape_mode was not\nNULL, shape_mode has been filled with the mode data,\nSDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped\nwindow, or SDL_WINDOW_LACKS_SHAPE if the SDL_Window* given is a\nshapeable window currently lacking a shape.SDL_WindowShapeMode\n\nSDL_SetWindowShape\n", 
  "SDL_GetTextureBlendMode": ":param texture:\n:param blendMode:\n\nGet the blend mode used for texture copy operations.\n\ntexture: The texture to query.\n\nblendMode: A pointer filled in with the current blend mode.\n\n:return: 0 on success, or -1 if the texture is not\nvalid.SDL_SetTextureBlendMode()\n", 
  "SDL_GL_UnloadLibrary": "\nUnload the OpenGL library previously loaded by SDL_GL_LoadLibrary().\n\nSDL_GL_LoadLibrary()\n", 
  "SDL_GetKeyFromName": ":param name:\n\nGet a key code from a human-readable name.\n\n:return: key code, or SDLK_UNKNOWN if the name wasn't\nrecognizedSDL_Keycode\n", 
  "SDL_CreateTextureFromSurface": ":param renderer:\n:param surface:\n\nCreate a texture from an existing surface.\n\nrenderer: The renderer.\n\nsurface: The surface containing pixel data used to fill the texture.\n\n:return: The created texture is returned, or 0 on error.The surface is\nnot modified or freed by this function.\n\nSDL_QueryTexture()\n\nSDL_DestroyTexture()\n", 
  "SDL_ThreadID": "\nGet the thread identifier for the current thread.\n", 
  "SDL_SetMainReady": "\nThis is called by the real SDL main function to let the rest of the\nlibrary know that initialization was done properly.\n\nCalling this yourself without knowing what you're doing can cause\ncrashes and hard to diagnose problems with your application.\n", 
  "SDL_SetPaletteColors": ":param palette:\n:param colors:\n:param firstcolor:\n:param ncolors:\n\nSet a range of colors in a palette.\n\npalette: The palette to modify.\n\ncolors: An array of colors to copy into the palette.\n\nfirstcolor: The index of the first palette entry to modify.\n\nncolors: The number of entries to modify.\n\n:return: 0 on success, or -1 if not all of the colors could be set.\n", 
  "SDL_GameControllerGetStringForAxis": ":param axis:\n\nturn this axis enum into a string mapping\n", 
  "SDL_HapticStopAll": ":param haptic:\n\nStops all the currently playing effects on a haptic device.\n\nhaptic: Haptic device to stop.\n\n:return: 0 on success or -1 on error.\n", 
  "SDL_GL_LoadLibrary": ":param path:\n\nDynamically load an OpenGL library.\n\npath: The platform dependent OpenGL library name, or NULL to open the\ndefault OpenGL library.\n\n:return: 0 on success, or -1 if the library couldn't be loaded.\n\nThis should be done after initializing the video driver, but before\ncreating any OpenGL windows. If no OpenGL library is loaded, the\ndefault library will be loaded upon creation of the first OpenGL\nwindow.\n\nIf you do this, you need to retrieve all of the GL functions used in\nyour program from the dynamic library using SDL_GL_GetProcAddress().\n\nSDL_GL_GetProcAddress()\n\nSDL_GL_UnloadLibrary()\n", 
  "SDL_strtoul": ":param str:\n:param endp:\n:param base:\n", 
  "SDL_GetAssertionHandler": ":param puserdata:\n\nGet the current assertion handler.\n\nThis returns the function pointer that is called when an assertion is\ntriggered. This is either the value last passed to\nSDL_SetAssertionHandler(), or if no application-specified function is\nset, is equivalent to calling SDL_GetDefaultAssertionHandler().\n\npuserdata: Pointer to a void*, which will store the \"userdata\" pointer\nthat was passed to SDL_SetAssertionHandler(). This value will always\nbe NULL for the default handler. If you don't care about this data, it\nis safe to pass a NULL pointer to this function to ignore it.\n\n:return: The SDL_AssertionHandler that is called when an assert\ntriggers.\n", 
  "SDL_UpdateYUVTexture": ":param texture:\n:param rect:\n:param Yplane:\n:param Ypitch:\n:param Uplane:\n:param Upitch:\n:param Vplane:\n:param Vpitch:\n\nUpdate a rectangle within a planar YV12 or IYUV texture with new pixel\ndata.\n\ntexture: The texture to update\n\nrect: A pointer to the rectangle of pixels to update, or NULL to\nupdate the entire texture.\n\nYplane: The raw pixel data for the Y plane.\n\nYpitch: The number of bytes between rows of pixel data for the Y\nplane.\n\nUplane: The raw pixel data for the U plane.\n\nUpitch: The number of bytes between rows of pixel data for the U\nplane.\n\nVplane: The raw pixel data for the V plane.\n\nVpitch: The number of bytes between rows of pixel data for the V\nplane.\n\n:return: 0 on success, or -1 if the texture is not valid.You can use\nSDL_UpdateTexture() as long as your pixel data is a contiguous block\nof Y and U/V planes in the proper order, but this function is\navailable if your pixel data is not contiguous.\n", 
  "SDL_RemoveTimer": ":param id:\n\nRemove a timer knowing its ID.\n\n:return: A boolean value indicating success or failure.It is not safe\nto remove a timer multiple times.\n", 
  "SDL_RWFromFile": ":param file:\n:param mode:\n", 
  "SDL_GetAudioDeviceName": ":param index:\n:param iscapture:\n\nGet the human-readable name of a specific audio device. Must be a\nvalue between 0 and (number of audio devices-1). Only valid after a\nsuccessfully initializing the audio subsystem. The values returned by\nthis function reflect the latest call to SDL_GetNumAudioDevices();\nrecall that function to redetect available hardware.\n\nThe string returned by this function is UTF-8 encoded, read-only, and\nmanaged internally. You are not to free it. If you need to keep the\nstring for any length of time, you should make your own copy of it, as\nit will be invalid next time any of several other SDL functions is\ncalled.\n", 
  "SDL_GetClosestDisplayMode": ":param displayIndex:\n:param mode:\n:param closest:\n\nGet the closest match to the requested display mode.\n\ndisplayIndex: The index of display from which mode should be queried.\n\nmode: The desired display mode\n\nclosest: A pointer to a display mode to be filled in with the closest\nmatch of the available display modes.\n\n:return: The passed in value\n\nThe available display modes are scanned, and closest is filled in with\nthe closest mode matching the requested mode and returned. The mode\nformat and refresh_rate default to the desktop mode if they are 0. The\nmodes are scanned with size being first priority, format being second\npriority, and finally checking the refresh_rate. If all the available\nmodes are too small, then NULL is returned.\n\nSDL_GetNumDisplayModes()\n\nSDL_GetDisplayMode()\n", 
  "SDL_InitSubSystem": ":param flags:\n\nThis function initializes specific SDL subsystems\n", 
  "SDL_CreateColorCursor": ":param surface:\n:param hot_x:\n:param hot_y:\n\nCreate a color cursor.\n\nSDL_FreeCursor()\n", 
  "SDL_GetWindowSize": ":param window:\n:param w:\n:param h:\n\nGet the size of a window's client area.\n\nwindow: The window to query.\n\nw: Pointer to variable for storing the width, may be NULL\n\nh: Pointer to variable for storing the height, may be NULL\n\nSDL_SetWindowSize()\n", 
  "uintptr_t": ":param pfnSDL_CurrentBeginThread:\n", 
  "SDL_sscanf": ":param text:\n:param fmt:\n:param :\n", 
  "SDL_SetTextureColorMod": ":param texture:\n:param r:\n:param g:\n:param b:\n\nSet an additional color value used in render copy operations.\n\ntexture: The texture to update.\n\nr: The red color value multiplied into copy operations.\n\ng: The green color value multiplied into copy operations.\n\nb: The blue color value multiplied into copy operations.\n\n:return: 0 on success, or -1 if the texture is not valid or color\nmodulation is not supported.SDL_GetTextureColorMod()\n", 
  "SDL_ResetAssertionReport": "\nReset the list of all assertion failures.\n\nReset list of all assertions triggered.\n\nSDL_GetAssertionReport\n", 
  "SDL_CreateWindowAndRenderer": ":param width:\n:param height:\n:param window_flags:\n:param window:\n:param renderer:\n\nCreate a window and default renderer.\n\nwidth: The width of the window\n\nheight: The height of the window\n\nwindow_flags: The flags used to create the window\n\nwindow: A pointer filled with the window, or NULL on error\n\nrenderer: A pointer filled with the renderer, or NULL on error\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_JoystickInstanceID": ":param joystick:\n\nGet the instance ID of an opened joystick or -1 if the joystick is\ninvalid.\n", 
  "SDL_StopTextInput": "\nStop receiving any text input events. This function will hide the on-\nscreen keyboard if supported.\n\nSDL_StartTextInput()\n\nSDL_HasScreenKeyboardSupport()\n", 
  "SDL_Log": ":param fmt:\n:param :\n\nLog a message with SDL_LOG_CATEGORY_APPLICATION and\nSDL_LOG_PRIORITY_INFO.\n", 
  "SDL_GetCurrentDisplayMode": ":param displayIndex:\n:param mode:\n\nFill in information about the current display mode.\n", 
  "SDL_asin": ":param x:\n", 
  "SDL_RectEquals": ":param a:\n:param b:\n\nReturns true if the two rectangles are equal.\n", 
  "SDL_HasMMX": "\nThis function returns true if the CPU has MMX features.\n", 
  "SDL_HasIntersection": ":param A:\n:param B:\n\nDetermine whether two rectangles intersect.\n\n:return: SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n", 
  "SDL_strncasecmp": ":param str1:\n:param str2:\n:param len:\n", 
  "SDL_MostSignificantBitIndex32": ":param x:\n\nGet the index of the most significant bit. Result is undefined when\ncalled with 0. This operation can also be stated as \"count leading\nzeroes\" and \"log base 2\".\n\n:return: Index of the most significant bit, or -1 if the value is 0.\n", 
  "SDL_CloseAudio": "\nThis function shuts down audio processing and closes the audio device.\n", 
  "SDL_GetRenderer": ":param window:\n\nGet the renderer associated with a window.\n", 
  "SDL_WriteBE32": ":param dst:\n:param value:\n", 
  "SDL_CalculateGammaRamp": ":param gamma:\n:param ramp:\n\nCalculate a 256 entry gamma ramp for a gamma value.\n", 
  "SDL_GL_SwapWindow": ":param window:\n\nSwap the OpenGL buffers for a window, if double-buffering is\nsupported.\n", 
  "SDL_HapticRumblePlay": ":param haptic:\n:param strength:\n:param length:\n\nRuns simple rumble on a haptic device.\n\nhaptic: Haptic device to play rumble effect on.\n\nstrength: Strength of the rumble to play as a 0-1 float value.\n\nlength: Length of the rumble to play in milliseconds.\n\n:return: 0 on success or -1 on error.SDL_HapticRumbleSupported\n\nSDL_HapticRumbleInit\n\nSDL_HapticRumbleStop\n", 
  "SDL_RenderDrawLines": ":param renderer:\n:param points:\n:param count:\n\nDraw a series of connected lines on the current rendering target.\n\nrenderer: The renderer which should draw multiple lines.\n\npoints: The points along the lines\n\ncount: The number of points, drawing count-1 lines\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_BuildAudioCVT": ":param cvt:\n:param src_format:\n:param src_channels:\n:param src_rate:\n:param dst_format:\n:param dst_channels:\n:param dst_rate:\n\nThis function takes a source format and rate and a destination format\nand rate, and initializes the cvt structure with information needed by\nSDL_ConvertAudio() to convert a buffer of audio data from one format\nto the other.\n\n:return: -1 if the format conversion is not supported, 0 if there's no\nconversion needed, or 1 if the audio filter is set up.\n", 
  "SDL_SetWindowGammaRamp": ":param window:\n:param red:\n:param green:\n:param blue:\n\nSet the gamma ramp for a window.\n\nwindow: The window for which the gamma ramp should be set.\n\nred: The translation table for the red channel, or NULL.\n\ngreen: The translation table for the green channel, or NULL.\n\nblue: The translation table for the blue channel, or NULL.\n\n:return: 0 on success, or -1 if gamma ramps are unsupported.\n\nSet the gamma translation table for the red, green, and blue channels\nof the video hardware. Each table is an array of 256 16-bit\nquantities, representing a mapping between the input and output for\nthat channel. The input is the index into the array, and the output is\nthe 16-bit gamma value at that index, scaled to the output color\nprecision.\n\nSDL_GetWindowGammaRamp()\n", 
  "SDL_strchr": ":param str:\n:param c:\n", 
  "SDLTest_Md5Update": ":param mdContext:\n:param inBuf:\n:param inLen:\n\n/brief update digest from variable length data\n\n/param mdContext pointer to context variable /param inBuf pointer to\ndata array/string /param inLen length of data array/string\n\nNote: The function updates the message-digest context to account for\nthe presence of each of the characters inBuf[0..inLen-1] in the\nmessage whose digest is being computed.\n", 
  "SDL_strtod": ":param str:\n:param endp:\n", 
  "SDL_snprintf": ":param text:\n:param maxlen:\n:param fmt:\n:param :\n", 
  "SDL_strtol": ":param str:\n:param endp:\n:param base:\n", 
  "SDL_MapRGBA": ":param format:\n:param r:\n:param g:\n:param b:\n:param a:\n\nMaps an RGBA quadruple to a pixel value for a given pixel format.\n\nSDL_MapRGB\n", 
  "SDL_SemTryWait": ":param sem:\n\nNon-blocking variant of SDL_SemWait().\n\n:return: 0 if the wait succeeds,\n", 
  "SDL_FlushEvent": ":param type:\n\nThis function clears events from the event queue\n", 
  "SDL_itoa": ":param value:\n:param str:\n:param radix:\n", 
  "SDL_strlwr": ":param str:\n", 
  "SDL_sqrt": ":param x:\n", 
  "SDL_GameControllerGetJoystick": ":param gamecontroller:\n\nGet the underlying joystick object used by a controller\n", 
  "SDL_GetWindowID": ":param window:\n\nGet the numeric ID of a window, for logging purposes.\n", 
  "SDL_RectEmpty": ":param r:\n\nReturns true if the rectangle has no area.\n", 
  "SDL_CreateShapedWindow": ":param title:\n:param x:\n:param y:\n:param w:\n:param h:\n:param flags:\n\nCreate a window that can be shaped with the specified position,\ndimensions, and flags.\n\ntitle: The title of the window, in UTF-8 encoding.\n\nx: The x position of the window, SDL_WINDOWPOS_CENTERED, or\nSDL_WINDOWPOS_UNDEFINED.\n\ny: The y position of the window, SDL_WINDOWPOS_CENTERED, or\nSDL_WINDOWPOS_UNDEFINED.\n\nw: The width of the window.\n\nh: The height of the window.\n\nflags: The flags for the window, a mask of SDL_WINDOW_BORDERLESS with\nany of the following: SDL_WINDOW_OPENGL, SDL_WINDOW_INPUT_GRABBED,\nSDL_WINDOW_HIDDEN, SDL_WINDOW_RESIZABLE, SDL_WINDOW_MAXIMIZED,\nSDL_WINDOW_MINIMIZED, SDL_WINDOW_BORDERLESS is always set, and\nSDL_WINDOW_FULLSCREEN is always unset.\n\n:return: The window created, or NULL if window creation\nfailed.SDL_DestroyWindow()\n", 
  "SDL_JoystickEventState": ":param state:\n\nEnable/disable joystick event polling.\n\nIf joystick events are disabled, you must call SDL_JoystickUpdate()\nyourself and check the state of the joystick when you want joystick\ninformation.\n\nThe state can be one of SDL_QUERY, SDL_ENABLE or SDL_IGNORE.\n", 
  "SDL_RenderDrawRects": ":param renderer:\n:param rects:\n:param count:\n\nDraw some number of rectangles on the current rendering target.\n\nrenderer: The renderer which should draw multiple rectangles.\n\nrects: A pointer to an array of destination rectangles.\n\ncount: The number of rectangles.\n\n:return: 0 on success, or -1 on error\n", 
  "SDL_atan": ":param x:\n", 
  "SDL_HapticUpdateEffect": ":param haptic:\n:param effect:\n:param data:\n\nUpdates the properties of an effect.\n\nCan be used dynamically, although behaviour when dynamically changing\ndirection may be strange. Specifically the effect may reupload itself\nand start playing from the start. You cannot change the type either\nwhen running SDL_HapticUpdateEffect().\n\nhaptic: Haptic device that has the effect.\n\neffect: Effect to update.\n\ndata: New effect properties to use.\n\n:return: 0 on success or -1 on error.SDL_HapticNewEffect\n\nSDL_HapticRunEffect\n\nSDL_HapticDestroyEffect\n", 
  "SDL_strncmp": ":param str1:\n:param str2:\n:param maxlen:\n", 
  "SDLTest_RandomUint32": "\nReturns a random positive integer\n\n:return: Generated integer\n", 
  "SDL_MaximizeWindow": ":param window:\n\nMake a window as large as possible.\n\nSDL_RestoreWindow()\n", 
  "SDL_HapticIndex": ":param haptic:\n\nGets the index of a haptic device.\n\nhaptic: Haptic device to get the index of.\n\n:return: The index of the haptic device or -1 on error.SDL_HapticOpen\n\nSDL_HapticOpened\n", 
  "SDL_JoystickUpdate": "\nUpdate the current state of the open joysticks.\n\nThis is called automatically by the event loop if any joystick events\nare enabled.\n", 
  "SDL_SetWindowShape": ":param window:\n:param shape:\n:param shape_mode:\n\nSet the shape and parameters of a shaped window.\n\nwindow: The shaped window whose parameters should be set.\n\nshape: A surface encoding the desired shape for the window.\n\nshape_mode: The parameters to set for the shaped window.\n\n:return: 0 on success, SDL_INVALID_SHAPE_ARGUMENT on invalid an\ninvalid shape argument, or SDL_NONSHAPEABLE_WINDOW if the SDL_Window*\ngiven does not reference a valid shaped window.SDL_WindowShapeMode\n\nSDL_GetShapedWindowMode.\n", 
  "SDL_AtomicGet": ":param a:\n\nGet the value of an atomic variable.\n", 
  "SDL_HapticNumAxes": ":param haptic:\n\nGets the number of haptic axes the device has.\n\nSDL_HapticDirection\n", 
  "SDLTest_RandomSint64": "\nReturns random Sint64.\n\n:return: Generated signed integer\n"
}