diff -r e47f878a45dc django/core/management/__init__.py
--- a/django/core/management/__init__.py	Tue Jun 29 22:27:22 2010 -0400
+++ b/django/core/management/__init__.py	Tue Jun 29 22:29:32 2010 -0400
@@ -14,6 +14,9 @@
 # doesn't have to reload every time it's called.
 _commands = None
 
+# Name of the settings module to use.
+_SETTINGS_MODULE = 'DJANGO_SETTINGS_MODULE'
+
 def find_commands(management_dir):
     """
     Given a path to a management directory, returns a list of all the command
@@ -105,8 +108,8 @@
         # Find the project directory
         try:
             from django.conf import settings
-            module = import_module(settings.SETTINGS_MODULE)
-            project_directory = setup_environ(module, settings.SETTINGS_MODULE)
+            module = import_module(settings.SETTINGS_MODULE.split('.', 1)[0])
+            project_directory = setup_environ(module)
         except (AttributeError, EnvironmentError, ImportError, KeyError):
             project_directory = None
 
@@ -378,47 +381,27 @@
         else:
             self.fetch_command(subcommand).run_from_argv(self.argv)
 
-def setup_environ(settings_mod, original_settings_path=None):
+def setup_environ(settings_mod):
     """
     Configures the runtime environment. This can also be used by external
     scripts wanting to set up a similar environment to manage.py.
+    
     Returns the project directory (assuming the passed settings module is
     directly in the project directory).
 
-    The "original_settings_path" parameter is optional, but recommended, since
-    trying to work out the original path from the module can be problematic.
     """
-    # Add this project to sys.path so that it's importable in the conventional
-    # way. For example, if this file (manage.py) lives in a directory
-    # "myproject", this code would add "/path/to/myproject" to sys.path.
-    if '__init__.py' in settings_mod.__file__:
-        p = os.path.dirname(settings_mod.__file__)
-    else:
-        p = settings_mod.__file__
-    project_directory, settings_filename = os.path.split(p)
-    if project_directory == os.curdir or not project_directory:
-        project_directory = os.getcwd()
-    project_name = os.path.basename(project_directory)
-
-    # Strip filename suffix to get the module name.
+    project_directory, settings_filename = os.path.split(settings_mod.__file__)
     settings_name = os.path.splitext(settings_filename)[0]
-
+    
     # Strip $py for Jython compiled files (like settings$py.class)
     if settings_name.endswith("$py"):
         settings_name = settings_name[:-3]
-
-    # Set DJANGO_SETTINGS_MODULE appropriately.
-    if original_settings_path:
-        os.environ['DJANGO_SETTINGS_MODULE'] = original_settings_path
-    else:
-        os.environ['DJANGO_SETTINGS_MODULE'] = '%s.%s' % (project_name, settings_name)
-
-    # Import the project module. We add the parent directory to PYTHONPATH to
-    # avoid some of the path errors new users can have.
-    sys.path.append(os.path.join(project_directory, os.pardir))
-    project_module = import_module(project_name)
-    sys.path.pop()
-
+    
+    if not _SETTINGS_MODULE in os.environ:
+        # set this to the correct settings module.
+        os.environ[_SETTINGS_MODULE] = settings_name
+    
+    # keep this for backward compatibility
     return project_directory
 
 def execute_from_command_line(argv=None):
