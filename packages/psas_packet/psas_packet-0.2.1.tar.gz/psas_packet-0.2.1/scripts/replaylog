#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
import argparse
import struct
from contextlib import closing
import socket
import time
import sys
from psas_packet import io
from psas_packet import messages

PSAS = messages.MESSAGES
HEAD = messages.HEADER

def replay(log):

    with closing(socket.socket(socket.AF_INET, socket.SOCK_DGRAM)) as sock:
        sock.bind(('', 0))
        sock.connect(('127.0.0.1', 35001))

        with io.BinFile(log) as log:
            seq = 0
            cur_seq = -1
            file_time = 0
            last_seq_time = 0
            now = time.time()
            last_pack_sent = 0
            buff = b''
            for fourcc, data in log.read():
                # scan sequnce numbers
                if fourcc == 'SEQN':
                    seq = data['Sequence']
                    if seq != cur_seq:
                        # Wait and send
                        if len(buff) > 0:
                            now = time.time()
                            packet_delay = (file_time - last_seq_time)/1e9
                            real_delay = now - last_pack_sent
                            wait_time = packet_delay - real_delay
                            if wait_time > 0:
                                time.sleep(wait_time)
                            sock.send(buff)
                            sys.stdout.write("  Sequence No.: {0}\r".format(seq))
                            sys.stdout.flush()
                            #print(cur_seq, len(buff), packet_delay, real_delay, wait_time)
                            last_pack_sent = time.time()

                        # reset
                        last_seq_time = file_time
                        buff = b''
                        buff += struct.pack('!L', seq)
                        cur_seq = seq
                else:
                    # copy log
                    msg = messages.MESSAGES.get(messages.printable(fourcc))
                    if msg is not None:
                        buff += HEAD.encode(msg, data['timestamp'])
                        buff += msg.encode(data)
                        file_time = data['timestamp']

            # flush last packet
            now = time.time()
            packet_delay = (file_time - last_seq_time)/1e9
            real_delay = now - last_pack_sent
            wait_time = packet_delay - real_delay
            if wait_time > 0:
                time.sleep(wait_time)
            udp.send_raw(buff)
            sys.stdout.write("  Sequence No.: {0}\n".format(seq))
            #print(cur_seq, len(buff), packet_delay, real_delay, wait_time)

    print("EOF")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog='replaylog')
    parser.add_argument('logfile', type=argparse.FileType('rb'), help="Log file to read")

    args = vars(parser.parse_args())

    replay(args['logfile'])
