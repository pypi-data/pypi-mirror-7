**Введение.**

Перед тем, как мы будем говорить о HTTP, давайте рассмотрим набор сетевых протоколов TCP/IP, в частности взглянем на модель распределения протоколов по уровням. Сам набор TCP/IP включает в себя несколько протоколов, но самыми важными и чаще всего используемыми являются IP и TCP.

На самом нижнем уровне находится все то, что свзяано с физической передачей данных или электрических сигналов от устройства к устройству. Это то, чем занимаются производители железа и инженеры-сетевики.

Следующий – сетевой уровень. К нему относится протокол IP. Разработан для передачи данных между разными сетями.

Транспортный уровень отвечает за доставку данных от машины к машине. TCP относится к этому уровню, и, в отличие от IP, TCP гарантирует доставку данных и их верный порядок. Нужно понимать, что TCP это не альтернатива IP, а протокол, работающий поверх и благодаря IP.

Наконец, прикладной уровень этот тот уровень, с которым мы чаще всего имеем дело как пользователи. Браузер, почтовый клиент, мессенджер относятся к прикладному уровню. 

Каждый уровень является абстрактным, что позволяет работать с ним, не думая об уровнях выше или ниже. Протокол каждого уровня работает благодаря уровню ниже.

Если мы посмотрим на данные на каждом уровне, то увидим дополнительную служебную информацию, в частности, заголовки различных протоколов. При передаче данных, скажем, от веб-сервера к браузеру, информация оборачивается дополнительными заголовками на каждом уровне, пересылается по сети, а на последних шагах до браузера “распаковывается” обратно. Благодаря абстракции каждого уровня, что является важной концепцией информатики в целом, веб-разработчики могут рассматривать этот процесс как передачу данных на одном уровне, уровне приложения.

Самым популярным протоколом такого уровня является HTTP.

**HTTP в действии**

Давайте посмотрим на HTTP в действии. Я открыл веб-инспектор в Хроме и открыл вкладку Network. После этого я перезагружу страницу нашего сайта http://tengs.ru и в этой вкладке увижу все HTTP-запросы, которые сделал мой веб-браузер при посещении этой страницы. Как вы увидите, их здесь много, они соответствуют разным деталям на сайте. Меня интересует самый первый запрос, с которого все и началось, это запрос к tengs.ru

Каждый HTTP-запрос состоит из трех частей: стартовой строки, заголовка и тела сообщения. Заголовок и тело сообщения могут быть опциональными, но стартовая строка обязательна, она и задает сам запрос. 
Если мы посмотрим в чистом виде на то, что мой браузер пытался сказать веб-серверу, то мы увидим стартовую строку, и увидим несколько параметров в заголовке. Нужно понимать, что это просто текст, который был отправлен браузером веб-серверу. И веб-сервер понял этот текст, потому что этот текст задан в формате, соответствующем HTTP. Это просто некий общий язык, который был заранее принят обеими сторонами.

Это также означает, что нам не обязательно использовать веб-браузер для этого, мы можем сделать тот же запрос вручную. Для этого я возьму IP-адрес, на котором находится этот сайт, и с помощью утилиты telnet попытаюсь подсоединиться к нему на порт 80, порт, на котором и “висит” веб-сервер.

После того, как соединение установлено, я отправлю тот же текст, что отправлял мой браузер. Я скажу:

GET (мы чуть позже узнаем, что это значит), дальше укажу адрес – “/“ – тут я хочу загрузить корневую страницу, и укажу версия протокола HTTP – “HTTP/1.1”. Последняя версия это 1.1.

После этого, я укажу хост, который хочу посетить, это tengs.ru, и два раза переведу строку, что соответствует окончанию HTTP-сообщения. В ответ мы получим много информации, большая часть из которой, как вы видите, это HTML. Этот и есть тот код, который отображается браузером и который видит пользователь. Перед ним идет также заголовок и стартовая строка, которая пришла от сервера браузеру.

Если мы посмотрим на вот этот код в стартовой строке, то увидим “200 ОК”. И это способ, который пользуется веб-сервер, чтобы сказать веб-браузеру, что данная страница, что данный запрос был выполнен корректно, что все нормально. Если мы, скажем, перейдем на страницу, которой точно не существует, то по-хорошему, если веб-сервер и приложение было настроено правильно, мы должны получить другой ответ. В частности, здесь мы получили код 404, “не найдено”. Код, который извествен всем, даже тем, кто не работает с веб-программированием. Таких кодов в рамках HTTP много, они разделены на классы. В частности, класс, начинающийся с двойки означает, что все нормально, коды, начинающиеся с пятерки означают ошибку, и так далее.

Стоит так же заметить, что тут мы указали хост, и это обязательный параметр в версии HTTP 1.1. В прошлой версии, HTTP 1.0 и предыдущей версии (0.9) этот параметр был не обязателен, потому что в те годы, в начале 90-х, была идея, что один IP-адрес соответствует одному сайту. То есть, если вы подсоединяетесь к какому-то IP-адресу, то там может быть только один сайт, поэтому не нужно указывать хост. Но в последствии оказалось, что на один IP-адрес стали “цеплять” очень много сайтов, виртуальные хостинги нам сегодня позволяют это делать. Поэтому, нужно указывать также хост. Опять же, в зависимости от настроек, если хост не указывать, то возможно будет возвращен дефолтный хост или хост по-умолчанию.

**GET и POST**

Мы видели, что браузер может передать какую-то информацию серверу, сервер – обработать ее и ответить браузеру. Что, если нам нужно отправить какую-то дополнительную информацию с самой страницы, например, информацию, которую вводит пользователь в формы. До этого мы рассматривали один метод протокола HTTP – метод GET. И, как понятно из названия, этот метод используется для того, чтобы получить с сервера какую-то информацию. Если мы еще раз посмотрим на нашу стартовую строку запроса от браузера, то увидим GET прямо здесь.

Мы также передаем серверу адрес, который хотим посетить. Это значит, что мы можем передать какую-нибудь дополнительную информацию прямо здесь. Для этого мы к адресу добавим параметры вот в таком формате:

http://tengs.ru/?param1=value1&param2=value2

Я добавил два параметра. Параметр 1 – “param1”, и его значение – “value1”, и параметр 2 – “param2”, и его значение – “value2”.

Это тот же запрос GET, и если мы посмотрим на наш запрос, то увидим, что эти данные были отправлены серверу, веб-инспектор их нам здесь даже отдельно подсветил.

Это способ, который в целом нормальный, работает во многих ситуациях, например, если вы пользовались гуглом, то видели, что каждый раз когда вы делаете запрос – информация передается там прямо через этот же адрес. Это позволяет делиться запросами и показывать вашему приятелю поисковую выдачу. Но у такого подхода есть очень много минусов, и некоторые ограничения.

Например, длина этого сообщения, длина адреса, который здесь можно ввести, количество параметров. Сам протокол HTTP не ограничивает длину, но, в частности, браузеры, в зависимости от их настроек, и веб-серверы, в зависимости от их настроек, могут ограничивать эту длину и отвечать, что сообщение было слишком длинным. Передать, допустим, целый файл, становится проблематичным.

Вторая проблема в том, что такие запросы могут делать роботы, например, пауки Гугла и Яндекса. Если вы где-то оставили такую ссылку, то они могут посетить эту ссылку и сгенерировать какой-то запрос. И если вы к этому запросу привязали на сервере какое-то действие, то это действие выполнит робот, что, наверное, нежелательно.

По определению, GET-запрос должен использоваться для уже существующих данных, он должен возвращать с сервера что-то, что уже там было. Поэтому, если вы хотите использовать такой подход чтобы создать что-то новое, допустим, добавить новый комментарий в базу или создать новый пользовательский аккаунт, то GET использовать нежелательно.

Что же делать? Ну, кроме GET в протоколе HTTP есть множество других методов, самый популярный наряду с GET’ом это запрос POST. Метод POST позволяет отправить в принципе неограниченного размера данные и данные эти будут пересылаться в теле сообщения, а не в стартовой строке. 

На этом сайте мы можем посмотреть на пример запроса POST если сделаем выход из нашего аккаунта. Как вы видите, выход ссылается на /session, и там нет никаких параметров, как в GET-запросе, который мы только что делали, но если мы нажмем на эту ссылку и потом посмотрим на нашу вкладку Network, то увидим, что вот этот запрос был метода POST. И некоторые данные были отправлены в теле. В частности, мы здесь попросили сервер удалить нашу сессию, из-за чего мы разлогинились на этом сайте.

**Cookies**

Протокол HTTP относится к классу так называемых stateless протоколов, или протоколов, которые на хранят в себе состояния. Каждый HTTP-запрос независим, то есть каждый раз сервер отвечает как в первый раз. Сервер не должен помнить и делать допущений о том, что один клиент делает несколько запросов подряд. Но, как вы знаете, интернет работает не так. Интернет любит запоминать нас, интернет любит узнавать нас и знать что мы делаем повторные запросы и показывать нам, что сервер знает о том, что мы уже залогинились, например. 

Как же решается эта проблема? Одно из решений это так называемые куки. Это просто некий кусок текста, который веб-сервер посылает браузеру, браузер его запоминает, и при последующем запросе посылает серверу. И если эти куки совпадают, то сервер понимает, что, да, этот пользователь до этого делал запрос, да, это тот пользователь, которому я до этого отправил этот же кусок текста.

Куки могут использоваться для аутентификации пользователей (если вы когда-нибудь нажимали на галочку “запомнить меня” при логине, то, скорее всего, был использован куки), там могут храниться какие-то персональные параметры, настройки сайта, может быть, цветовое решение, и также куки могут быть использованы для сбора статистики.

Нужно понимать, что куки не делает HTTP другим протоколом. HTTP продолжает быть stateless-протоколом, он продолжает ничего не знать о состоянии, но на уровне выше, на уровне приложения сервер может узнавать о том, в каком состоянии находится клиент.

Давайте посмотрим, опять же, в деле, как это может работать. Я также нахожусь на нашем сайте и перейду во вкладку “Ресурсы”. Тут мы увидим ресурсы этого сайта, которые запомнил мой браузер, и во вкладке “Cookies” я увижу tengs.ru.

Мы видим некоторые названия, соответствующие им значения, и какую-то дополнительную информацию. Это и есть куки, которые браузер запомнил для этого сайта. Чтобы понять лучше как это работает давайте я очищу куки, перейду на вкладку “Network” еще раз и перезагружу страницу. Теперь посмотрим на наш заголовок еще раз, заголовок запроса, который мы делали в сторону сервера, и поймем, что здесь нет ничего, что связано с куки. Если мы посмотрим на тот ответ, что сервер нам прислал, то увидим что-то связанное с куки, мы увидим такую строку:

    Set-Cookie: _teng_session=RmhDVG9Pb...bc9ec3136768c7f5d4; path=/; HttpOnly

И внимательный зритель заметит, что эти параметры очень похожи на те, что мы до этого видели в вкладке “Ресурсы”. Если мы вернемся в “Ресурсы”, то увидим, что вот они снова здесь появились.

Сам сайт нам отдал, в частности, вот такой параметр, но здесь есть дополнительные параметры, например, вот куки для Google Analytics, который прикреплен к этому сайту.

Если мы вернемся на вкладку “Network”, и сделаем повторный запрос, и снова посмотрим на заголовки, которые отправлены от браузера, то мы увидим что здесь появился куки. Тут появилось упоминание куки, и это показывает как этот механизм работает. Теперь когда у браузера есть куки, они отправляются серверу. И сервер понимает, что это тот же самый клиент, который с ним работал до этого.

В этот раз сервер решил ответить новыми куки, и в частности он сменил идентификатор сессии. Нас сейчас не волнует, что делает это приложение и для чего оно сменило куки. Суть в том, что с помощью такого механизма браузер и сервер смогли сохранить некое состояние.

**Кэширование**

Есть еще одна проблема. Когда я посещаю страницы на одном сайте, то я часто вижу одни и те же ресурсы: картинки, стили и другие файлы. И если бы не существовало кэширования, то каждый раз при таком посещении страницы моему браузеру приходилось бы скачивать все эти ресурсы заново, хотя он их уже скачивал в прошлом. Это было бы медленно и неприятно не только для меня, это повысило бы нагрузку на сам сервер, которому приходилось бы обрабатывать все эти постоянные запросы. 

К счастью, кэширование как идея существует давно, и кэширование существует также на уровне протокола HTTP. В своем ответе, сервер, когда он отдает нам какие-то ресурсы, может указать и дать инструкции по тому, как это ресурс нужно кэшировать.

Кэширование может происходить как на пути к моему браузеру, на каких-то серверах, через которые проходит этот запрос, так и в самом браузере. Если мы посмотрим на ответ сервера, который нам вернул одну из этих картинок, то мы увидим заголовок Expires и дату. Этот ресурс считается устаревшим если на данный момент мы зашли дальше этой даты. И, как вы видите, эта дата – в прошлом, 2006 год, то есть как бы мы ни старались, этот ресурс будет считаться устаревшим всегда. 

В текущей версии протокола HTTP также есть заголовки Cache-Control. И здесь возможны несколько разных параметров, здесь мы видим два параметра: no-cache и must-revalidate. 

No-cache может запутать, потому что он не означает “не кэшировать”, он означает, что ресурс должен быть ревалидирован даже если он является свежим, даже если вот эта дата еще не наступила. “Must-revalidate” означает, что то же самое нужно делать только если ресурс не свежий. И “Must-revalidate” это скорее избыточное во многих случаях условие, потому что, как правило, браузер и так понимает, что если ресурс устарел, то его нужно ревалидировать и скачать заново.

Если мы посмотрим на аналогичную страницу, но где все те же ресурсы отдаются с кэшированием, то мы увидим разницу. Во-первых, мы увидим, что Expires указывает на какую-то дату в будущем, аж на 10 лет вперед. Мы также увидим, что в Cache-Control есть параметр max-age и очень большое число. Это число – количество секунд, которое этот ресурс будет считаться свежим. И если у нас есть и Expires и max-age, то используется max-age, у него есть приоритет.

Здесь мы также видим 10 лет в секундах, если я не ошибаюсь, это означает, что ресурс будет закэширован максимум на 10 лет на этом браузере. 

Мы также видим здесь поле ETag, но оно пустое. Давайте снова посмотрим на наш сайт tengs.ru, посмотрим на запрос, который нам вернул нам вот эту картинку, обложку курса, и мы увидим здесь, что у поля ETag есть значение. Это уникальный идентификатор, который меняется, если этот ресурс изменился. Если на сервере сам файл изменится, допустим, не изменится у него ни имя, ни размер, только сам файл внутри, его содержание. То это поле ETag также изменится. Это позволит браузер понять, что этот ресурс изменился и его нужно заново скачать.
