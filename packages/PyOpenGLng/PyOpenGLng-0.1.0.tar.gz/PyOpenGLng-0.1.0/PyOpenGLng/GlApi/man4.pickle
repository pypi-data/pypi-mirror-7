ÄcPyOpenGLng.GlApi.ManualParser
Manual
q)Åq(UglCopyTexImage1DqcPyOpenGLng.GlApi.ManualParser
Page
q)Åq}q(UfunctionqhU	page_nameqUglCopyTexImage1DUpurposeq	U#copy pixels into a 1D texture imageubUglStencilMaskSeparateq
h)Åq}q(hh
hUglStencilMaskSeparateh	UNcontrol the front and/or back writing of individual bits in the stencil planesubUglMinSampleShadingqh)Åq}q(hhhUglMinSampleShadingh	U9specifies minimum rate at which sample shaing takes placeubUglFramebufferRenderbufferqh)Åq}q(hhhUglFramebufferRenderbufferh	USattach a renderbuffer as a logical buffer to the currently bound framebuffer objectubUglCompressedTexSubImage3Dqh)Åq}q(hhhUglCompressedTexSubImage3Dh	UCspecify a three-dimensional texture subimage in a compressed formatubUglBindSamplerqh)Åq}q(hhhUglBindSamplerh	U*bind a named sampler to a texturing targetubUglLineWidthqh)Åq}q(hhhUglLineWidthh	U%specify the width of rasterized linesubUglCompileShaderqh)Åq}q(hhhUglCompileShaderh	UCompiles a shader objectubUglGetTransformFeedbackVaryingqh)Åq }q!(hhhUglGetTransformFeedbackVaryingh	ULretrieve information about varying variables selected for transform feedbackubU#glDrawElementsInstancedBaseInstanceq"h)Åq#}q$(hh"hU#glDrawElementsInstancedBaseInstanceh	UXdraw multiple instances of a set of elements with offset applied to instanced attributesubUglCreateShaderq%h)Åq&}q'(hh%hUglCreateShaderh	UCreates a shader objectubU
glIsBufferq(h)Åq)}q*(hh(hU
glIsBufferh	U2determine if a name corresponds to a buffer objectubUglGetMultisamplefvq+h)Åq,}q-(hh+hUglGetMultisampleh	U!retrieve the location of a sampleubUglGenRenderbuffersq.h)Åq/}q0(hh.hUglGenRenderbuffersh	U"generate renderbuffer object namesubUglCopyTexSubImage2Dq1h)Åq2}q3(hh1hUglCopyTexSubImage2Dh	U'copy a two-dimensional texture subimageubUglCompressedTexImage2Dq4h)Åq5}q6(hh4hUglCompressedTexImage2Dh	U>specify a two-dimensional texture image in a compressed formatubUglBlendFuncSeparateq7h)Åq8}q9(hh7hUglBlendFuncSeparateh	U@specify pixel arithmetic for RGB and alpha components separatelyubUglProgramUniformMatrix4fvq:h)Åq;}q<(hh:hUglProgramUniformq=h	UFSpecify the value of a uniform variable for a specified program objectq>ubUglDrawBuffersq?h)Åq@}qA(hh?hUglDrawBuffersh	U2Specifies a list of color buffers to be drawn intoubUglSampleMaskiqBh)ÅqC}qD(hhBhUglSampleMaskih	U.set the value of a sub-word of the sample maskubUglUniformMatrix3x2fvqEh)ÅqF}qG(hhEhU	glUniformqHh	UFSpecify the value of a uniform variable for the current program objectqIubUglDebugMessageControlqJh)ÅqK}qL(hhJhUglDebugMessageControlh	U:control the reporting of debug messages in a debug contextubUglPointSizeqMh)ÅqN}qO(hhMhUglPointSizeh	U)specify the diameter of rasterized pointsubUglGetProgramPipelineInfoLogqPh)ÅqQ}qR(hhPhUglGetProgramPipelineInfoLogh	U;retrieve the info log string from a program pipeline objectubUglDeleteProgramqSh)ÅqT}qU(hhShUglDeleteProgramh	UDeletes a program objectubUglUniformMatrix3x4fvqVh)ÅqW}qX(hhVhhHh	hIubU
glWaitSyncqYh)ÅqZ}q[(hhYhU
glWaitSynch	UPinstruct the GL server to block until the specified sync object becomes signaledubUglUniformMatrix4x3fvq\h)Åq]}q^(hh\hhHh	hIubUglUniform3iq_h)Åq`}qa(hh_hhHh	hIubUglGetObjectLabelqbh)Åqc}qd(hhbhUglGetObjectLabelh	UBretrieve the label of a named object identified within a namespaceubUglTexParameterqeh)Åqf}qg(hhehUglTexParameterh	Uset texture parametersubUglUniform3fqhh)Åqi}qj(hhhhhHh	hIubUglGetBufferParameterivqkh)Åql}qm(hhkhUglGetBufferParameterh	U$return parameters of a buffer objectubUglDrawArraysIndirectqnh)Åqo}qp(hhnhUglDrawArraysIndirecth	U@render primitives from array data, taking parameters from memoryubU&glBeginQueryIndexed, glEndQueryIndexedqqh)Åqr}qs(hhqhUglBeginQueryIndexedh	U=delimit the boundaries of a query object on an indexed targetubUglProgramUniform3fqth)Åqu}qv(hhthh=h	h>ubUglGetFragDataIndexqwh)Åqx}qy(hhwhUglGetFragDataIndexh	UIquery the bindings of color indices to user-defined varying out variablesubUglTexStorage3Dqzh)Åq{}q|(hhzhUglTexStorage3Dh	Uusimultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array textureubUglBindImageTextureq}h)Åq~}q(hh}hUglBindImageTextureh	U*bind a level of a texture to an image unitubUglGetVertexAttribdvqÄh)ÅqÅ}qÇ(hhÄhUglGetVertexAttribqÉh	U+Return a generic vertex attribute parameterqÑubUglInvalidateBufferSubDataqÖh)ÅqÜ}qá(hhÖhUglInvalidateBufferSubDatah	U3invalidate a region of a buffer object's data storeubUglResumeTransformFeedbackqàh)Åqâ}qä(hhàhUglResumeTransformFeedbackh	U$resume transform feedback operationsubUglProgramUniformMatrix4x3fvqãh)Åqå}qç(hhãhh=h	h>ubUglDeleteFramebuffersqéh)Åqè}qê(hhéhUglDeleteFramebuffersh	Udelete framebuffer objectsubUglDrawArraysqëh)Åqí}qì(hhëhUglDrawArraysh	U!render primitives from array dataubUglUniform1uiqîh)Åqï}qñ(hhîhhHh	hIubUglClearqóh)Åqò}qô(hhóhUglClearh	Uclear buffers to preset valuesubUglGetActiveUniformNameqöh)Åqõ}qú(hhöhUglGetActiveUniformNameh	U#query the name of an active uniformubUglMemoryBarrierqùh)Åqû}qü(hhùhUglMemoryBarrierh	U.defines a barrier ordering memory transactionsubUglStencilOpq†h)Åq°}q¢(hh†hUglStencilOph	U'set front and back stencil test actionsubUglProgramUniform2uiq£h)Åq§}q•(hh£hh=h	h>ubUglGetFragDataLocationq¶h)Åqß}q®(hh¶hUglGetFragDataLocationh	UIquery the bindings of color numbers to user-defined varying out variablesubUglGetActiveSubroutineUniformq©h)Åq™}q´(hh©hUglGetActiveSubroutineUniformh	U7query a property of an active shader subroutine uniformubUglDrawElementsIndirectq¨h)Åq≠}qÆ(hh¨hUglDrawElementsIndirecth	UHrender indexed primitives from array data, taking parameters from memoryubUglGetTexImageqØh)Åq∞}q±(hhØhUglGetTexImageh	Ureturn a texture imageubUglGenFramebuffersq≤h)Åq≥}q¥(hh≤hUglGenFramebuffersh	U!generate framebuffer object namesubUglClearTexSubImageqµh)Åq∂}q∑(hhµhUglClearTexSubImageh	U:fills all or part of a texture image with a constant valueubUglGetAttachedShadersq∏h)Åqπ}q∫(hh∏hUglGetAttachedShadersh	UFReturns the handles of the shader objects attached to a program objectubUglIsRenderbufferqªh)Åqº}qΩ(hhªhUglIsRenderbufferh	U8determine if a name corresponds to a renderbuffer objectubUglDeleteVertexArraysqæh)Åqø}q¿(hhæhUglDeleteVertexArraysh	Udelete vertex array objectsubUglBindVertexBuffersq¡h)Åq¬}q√(hh¡hUglBindVertexBuffersh	U_bind one or more named buffer objects to a sequence of consecutive vertex buffer binding pointsubUglProgramUniform1uivqƒh)Åq≈}q∆(hhƒhh=h	h>ubUglIsVertexArrayq«h)Åq»}q…(hh«hUglIsVertexArrayh	U8determine if a name corresponds to a vertex array objectubUglDisableVertexAttribArrayq h)ÅqÀ}qÃ(hh hUglEnableVertexAttribArrayqÕh	U2Enable or disable a generic vertex attribute arrayqŒubUglProgramUniform2ivqœh)Åq–}q—(hhœhh=h	h>ubUglGetQueryivq“h)Åq”}q‘(hh“hUglGetQueryivh	U*return parameters of a query object targetubUglShaderStorageBlockBindingq’h)Åq÷}q◊(hh’hUglShaderStorageBlockBindingh	U-change an active shader storage block bindingubUglGetUniformIndicesqÿh)ÅqŸ}q⁄(hhÿhUglGetUniformIndicesh	U+retrieve the index of a named uniform blockubU
glIsShaderq€h)Åq‹}q›(hh€hU
glIsShaderh	U3Determines if a name corresponds to a shader objectubUglProgramUniformMatrix2x3fvqﬁh)Åqﬂ}q‡(hhﬁhh=h	h>ubUglGetActiveUniformsivq·h)Åq‚}q„(hh·hUglGetActiveUniformsivh	U[Returns information about several active uniform variables for the specified program objectubUglGetAttribLocationq‰h)ÅqÂ}qÊ(hh‰hUglGetAttribLocationh	U-Returns the location of an attribute variableubUglProgramUniform3uiqÁh)ÅqË}qÈ(hhÁhh=h	h>ubUglVertexBindingDivisorqÍh)ÅqÎ}qÏ(hhÍhUglVertexBindingDivisorh	U:modify the rate at which generic vertex attributes advanceubUglPolygonOffsetqÌh)ÅqÓ}qÔ(hhÌhUglPolygonOffseth	U6set the scale and units used to calculate depth valuesubUglEnableqh)ÅqÒ}qÚ(hhhUglEnableh	U-enable or disable server-side GL capabilitiesubUglDepthRangeqÛh)ÅqÙ}qı(hhÛhUglDepthRangeh	UXspecify mapping of depth values from normalized device coordinates to window coordinatesubUglDrawBufferqˆh)Åq˜}q¯(hhˆhUglDrawBufferh	U0specify which color buffers are to be drawn intoubUglDrawElementsInstancedq˘h)Åq˙}q˚(hh˘hUglDrawElementsInstancedh	U,draw multiple instances of a set of elementsubUglProgramUniform1iq¸h)Åq˝}q˛(hh¸hh=h	h>ubUglProgramUniform1fqˇh)År   }r  (hhˇhh=h	h>ubUglFlushr  h)År  }r  (hj  hUglFlushh	U-force execution of GL commands in finite timeubUglGetRenderbufferParameterivr  h)År  }r  (hj  hUglGetRenderbufferParameterh	U6retrieve information about a bound renderbuffer objectubUglProgramUniform3ivr  h)År	  }r
  (hj  hh=h	h>ubUglPixelStorer  h)År  }r  (hj  hUglPixelStoreh	Uset pixel storage modesubUglGetVertexAttribPointervr  h)År  }r  (hj  hUglGetVertexAttribPointervh	UDreturn the address of the specified generic vertex attribute pointerubUglFenceSyncr  h)År  }r  (hj  hUglFenceSynch	UAcreate a new sync object and insert it into the GL command streamubU-glDrawElementsInstancedBaseVertexBaseInstancer  h)År  }r  (hj  hU-glDrawElementsInstancedBaseVertexBaseInstanceh	UZrender multiple instances of a set of primitives from array data with a per-element offsetubUglValidateProgramPipeliner  h)År  }r  (hj  hUglValidateProgramPipelineh	U;validate a program pipeline object against current GL stateubUglTexStorage3DMultisampler  h)År  }r  (hj  hUglTexStorage3DMultisampleh	U?specify storage for a two-dimensional multisample array textureubUglStencilFuncSeparater  h)År  }r  (hj  hUglStencilFuncSeparateh	UFset front and/or back function and reference value for stencil testingubUglPatchParameterr   h)År!  }r"  (hj   hUglPatchParameterh	U-specifies the parameters for patch primitivesubUglGenSamplersr#  h)År$  }r%  (hj#  hUglGenSamplersh	Ugenerate sampler object namesubUglClampColorr&  h)År'  }r(  (hj&  hUglClampColorh	Uspecify whether data read via ubUglUniform4ivr)  h)År*  }r+  (hj)  hhHh	hIubUglClearStencilr,  h)År-  }r.  (hj,  hUglClearStencilh	U.specify the clear value for the stencil bufferubUglDepthRangeArrayr/  h)År0  }r1  (hj/  hUglDepthRangeArrayh	Uyspecify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewportsubU glDrawTransformFeedbackInstancedr2  h)År3  }r4  (hj2  hU glDrawTransformFeedbackInstancedh	U^render multiple instances of primitives using a count derived from a transform feedback objectubUglGenTexturesr5  h)År6  }r7  (hj5  hUglGenTexturesh	Ugenerate texture namesubUglDrawTransformFeedbackr8  h)År9  }r:  (hj8  hUglDrawTransformFeedbackh	UHrender primitives using a count derived from a transform feedback objectubUglIsSyncr;  h)År<  }r=  (hj;  hUglIsSynch	U0determine if a name corresponds to a sync objectubUglDeleteRenderbuffersr>  h)År?  }r@  (hj>  hUglDeleteRenderbuffersh	Udelete renderbuffer objectsubUglUniform2irA  h)ÅrB  }rC  (hjA  hhHh	hIubUglUniform2frD  h)ÅrE  }rF  (hjD  hhHh	hIubUglGetProgramivrG  h)ÅrH  }rI  (hjG  hUglGetProgramh	U)Returns a parameter from a program objectubUglVertexAttribPointerrJ  h)ÅrK  }rL  (hjJ  hUglVertexAttribPointerh	U0define an array of generic vertex attribute dataubUglFramebufferTextureLayerrM  h)ÅrN  }rO  (hjM  hUglFramebufferTextureLayerh	U3attach a single layer of a texture to a framebufferubUglProgramUniform4fvrP  h)ÅrQ  }rR  (hjP  hh=h	h>ubUglGetObjectPtrLabelrS  h)ÅrT  }rU  (hjS  hUglGetObjectPtrLabelh	U;retrieve the label of a sync object identified by a pointerubUglFlushMappedBufferRangerV  h)ÅrW  }rX  (hjV  hUglFlushMappedBufferRangeh	U4indicate modifications to a range of a mapped bufferubUglProgramUniform2fvrY  h)ÅrZ  }r[  (hjY  hh=h	h>ubUglTexStorage2Dr\  h)År]  }r^  (hj\  hUglTexStorage2Dh	Ucsimultaneously specify storage for all levels of a two-dimensional or one-dimensional array textureubUglGenQueriesr_  h)År`  }ra  (hj_  hUglGenQueriesh	Ugenerate query object namesubUglTexSubImage3Drb  h)Årc  }rd  (hjb  hUglTexSubImage3Dh	U,specify a three-dimensional texture subimageubUglDeleteSamplersre  h)Årf  }rg  (hje  hUglDeleteSamplersh	Udelete named sampler objectsubUglCopyTexImage2Drh  h)Åri  }rj  (hjh  hUglCopyTexImage2Dh	U#copy pixels into a 2D texture imageubUglBlitFramebufferrk  h)Årl  }rm  (hjk  hUglBlitFramebufferh	UHcopy a block of pixels from the read framebuffer to the draw framebufferubUglBindBuffersRangern  h)Åro  }rp  (hjn  hUglBindBuffersRangeh	UQbind ranges of one or more buffer objects to a sequence of indexed buffer targetsubUglBindFragDataLocationIndexedrq  h)Årr  }rs  (hjq  hUglBindFragDataLocationIndexedh	UTbind a user-defined varying out variable to a fragment shader color number and indexubUglUniform2ivrt  h)Åru  }rv  (hjt  hhHh	hIubUglUniform4uivrw  h)Årx  }ry  (hjw  hhHh	hIubUglGetShaderivrz  h)År{  }r|  (hjz  hUglGetShaderh	U(Returns a parameter from a shader objectubUglProgramUniformMatrix3fvr}  h)År~  }r  (hj}  hh=h	h>ubUglObjectPtrLabelrÄ  h)ÅrÅ  }rÇ  (hjÄ  hUglObjectPtrLabelh	U-label a a sync object identified by a pointerubUglGetDebugMessageLogrÉ  h)ÅrÑ  }rÖ  (hjÉ  hUglGetDebugMessageLogh	U,retrieve messages from the debug message logubUglBindTexturesrÜ  h)Årá  }rà  (hjÜ  hUglBindTexturesh	UJbind one or more named textures to a sequence of consecutive texture unitsubUglBindFragDataLocationrâ  h)Årä  }rã  (hjâ  hUglBindFragDataLocationh	UJbind a user-defined varying out variable to a fragment shader color numberubUglGetUniformfvrå  h)Årç  }ré  (hjå  hUglGetUniformrè  h	U'Returns the value of a uniform variablerê  ubUglInvalidateBufferDatarë  h)Årí  }rì  (hjë  hUglInvalidateBufferDatah	U6invalidate the content of a buffer object's data storeubUglUniform3fvrî  h)Årï  }rñ  (hjî  hhHh	hIubUglMultiDrawElementsIndirectró  h)Årò  }rô  (hjó  hUglMultiDrawElementsIndirecth	UHrender indexed primitives from array data, taking parameters from memoryubUglGetVertexAttribIivrö  h)Årõ  }rú  (hjö  hhÉh	hÑubUglInvalidateSubFramebufferrù  h)Årû  }rü  (hjù  hUglInvalidateSubFramebufferh	UWinvalidate the content of a region of some or all of a framebuffer object's attachmentsubUglMapBufferr†  h)År°  }r¢  (hj†  hUglMapBufferh	U map a buffer object's data storeubUglClearTexImager£  h)År§  }r•  (hj£  hUglClearTexImageh	U/fills all a texture image with a constant valueubUglPushDebugGroupr¶  h)Årß  }r®  (hj¶  hUglPushDebugGrouph	U0push a named debug group into the command streamubUglDeleteSyncr©  h)År™  }r´  (hj©  hUglDeleteSynch	Udelete a sync objectubUglCopyTexSubImage3Dr¨  h)År≠  }rÆ  (hj¨  hUglCopyTexSubImage3Dh	U)copy a three-dimensional texture subimageubUglGetVertexAttribivrØ  h)År∞  }r±  (hjØ  hhÉh	hÑubUglMultiDrawElementsr≤  h)År≥  }r¥  (hj≤  hUglMultiDrawElementsh	UOrender multiple sets of primitives by specifying indices of array data elementsubUglClearBufferrµ  h)År∂  }r∑  (hjµ  hUglClearBufferh	U@clear individual buffers of the currently bound draw framebufferubUglUniform3ivr∏  h)Årπ  }r∫  (hj∏  hhHh	hIubUglPolygonModerª  h)Årº  }rΩ  (hjª  hUglPolygonModeh	U#select a polygon rasterization modeubUglGetProgramPipelineræ  h)Årø  }r¿  (hjæ  hUglGetProgramPipelineh	U0retrieve properties of a program pipeline objectubUglProgramUniform4ivr¡  h)År¬  }r√  (hj¡  hh=h	h>ubUglGetProgramBinaryrƒ  h)År≈  }r∆  (hjƒ  hUglGetProgramBinaryh	UZreturn a binary representation of a program object's compiled and linked executable sourceubUglUseProgramr«  h)År»  }r…  (hj«  hUglUseProgramh	U<Installs a program object as part of current rendering stateubUglGetProgramInfoLogr   h)ÅrÀ  }rÃ  (hj   hUglGetProgramInfoLogh	U0Returns the information log for a program objectubUglBindTransformFeedbackrÕ  h)ÅrŒ  }rœ  (hjÕ  hUglBindTransformFeedbackh	U bind a transform feedback objectubUglBindVertexArrayr–  h)År—  }r“  (hj–  hUglBindVertexArrayh	Ubind a vertex array objectubUglDeleteBuffersr”  h)År‘  }r’  (hj”  hUglDeleteBuffersh	Udelete named buffer objectsubUglMultiDrawElementsBaseVertexr÷  h)År◊  }rÿ  (hj÷  hUglMultiDrawElementsBaseVertexh	Usrender multiple sets of primitives by specifying indices of array data elements and an index to apply to each indexubUglUniform2uivrŸ  h)År⁄  }r€  (hjŸ  hhHh	hIubUglCompressedTexSubImage1Dr‹  h)År›  }rﬁ  (hj‹  hUglCompressedTexSubImage1Dh	UAspecify a one-dimensional texture subimage in a compressed formatubUglFinishrﬂ  h)År‡  }r·  (hjﬂ  hUglFinishh	U(block until all GL execution is completeubUglDeleteShaderr‚  h)År„  }r‰  (hj‚  hUglDeleteShaderh	UDeletes a shader objectubUglCompressedTexImage3DrÂ  h)ÅrÊ  }rÁ  (hjÂ  hUglCompressedTexImage3Dh	U@specify a three-dimensional texture image in a compressed formatubUglInvalidateTexImagerË  h)ÅrÈ  }rÍ  (hjË  hUglInvalidateTexImageh	U'invalidate the entirety a texture imageubU!glGetProgramResourceLocationIndexrÎ  h)ÅrÏ  }rÌ  (hjÎ  hU!glGetProgramResourceLocationIndexh	UCquery the fragment color index of a named variable within a programubUglGetUniformSubroutinerÓ  h)ÅrÔ  }r  (hjÓ  hUglGetUniformSubroutineh	UYretrieve the value of a subroutine uniform of a given shader stage of the current programubU
glViewportrÒ  h)ÅrÚ  }rÛ  (hjÒ  hU
glViewporth	Uset the viewportubUglUniform1uivrÙ  h)Årı  }rˆ  (hjÙ  hhHh	hIubUglTransformFeedbackVaryingsr˜  h)År¯  }r˘  (hj˜  hUglTransformFeedbackVaryingsh	U6specify values to record in transform feedback buffersubUglUniform2uir˙  h)År˚  }r¸  (hj˙  hhHh	hIubUglDebugMessageCallbackr˝  h)År˛  }rˇ  (hj˝  hUglDebugMessageCallbackh	U<specify a callback to receive debugging messages from the GLubUglVertexAttribFormatr   h)År  }r  (hj   hUglVertexAttribFormath	U)specify the organization of vertex arraysubUglTexStorage2DMultisampler  h)År  }r  (hj  hUglTexStorage2DMultisampleh	U9specify storage for a two-dimensional multisample textureubUglProgramUniform1uir  h)År  }r  (hj  hh=h	h>ubUglVertexAttribBindingr	  h)År
  }r  (hj	  hUglVertexAttribBindingh	U8associate a vertex attribute and a vertex buffer bindingubUglGetShaderSourcer  h)År  }r  (hj  hUglGetShaderSourceh	U3Returns the source code string from a shader objectubUglTexBufferr  h)År  }r  (hj  hUglTexBufferh	UCattach the storage for a buffer object to the active buffer textureubUglValidateProgramr  h)År  }r  (hj  hUglValidateProgramh	UValidates a program objectubUglActiveShaderProgramr  h)År  }r  (hj  hUglActiveShaderProgramh	U;set the active program object for a program pipeline objectubUglGenProgramPipelinesr  h)År  }r  (hj  hUglGenProgramPipelinesh	U%reserve program pipeline object namesubUglGetInternalformatr  h)År  }r  (hj  hUglGetInternalformath	UPretrieve information about implementation-dependent support for internal formatsubUglGetProgramInterfacer  h)År  }r   (hj  hUglGetProgramInterfaceh	U-query a property of an interface in a programubUglGetProgramStager!  h)År"  }r#  (hj!  hUglGetProgramStageh	UQretrieve properties of a program object corresponding to a specified shader stageubUglLinkProgramr$  h)År%  }r&  (hj$  hUglLinkProgramh	ULinks a program objectubUglBindTexturer'  h)År(  }r)  (hj'  hUglBindTextureh	U*bind a named texture to a texturing targetubUglMultiDrawArraysIndirectr*  h)År+  }r,  (hj*  hUglMultiDrawArraysIndirecth	UQrender multiple sets of primitives from array data, taking parameters from memoryubUglBindImageTexturesr-  h)År.  }r/  (hj-  hUglBindImageTexturesh	UNbind one or more named texture images to a sequence of consecutive image unitsubUglGetStringr0  h)År1  }r2  (hj0  hUglGetStringh	U4return a string describing the current GL connectionubUglDetachShaderr3  h)År4  }r5  (hj3  hUglDetachShaderh	UFDetaches a shader object from a program object to which it is attachedubUglFramebufferParameterir6  h)År7  }r8  (hj6  hUglFramebufferParameterih	U&set a named parameter of a framebufferubUglGetProgramResourceNamer9  h)År:  }r;  (hj9  hUglGetProgramResourceNameh	U6query the name of an indexed resource within a programubUglGetProgramResourceLocationr<  h)År=  }r>  (hj<  hUglGetProgramResourceLocationh	U7query the location of a named resource within a programubUglDeleteTexturesr?  h)År@  }rA  (hj?  hUglDeleteTexturesh	Udelete named texturesubU glGetActiveAtomicCounterBufferivrB  h)ÅrC  }rD  (hjB  hU glGetActiveAtomicCounterBufferivh	UQretrieve information about the set of active atomic counter buffers for a programubUglStencilOpSeparaterE  h)ÅrF  }rG  (hjE  hUglStencilOpSeparateh	U*set front and/or back stencil test actionsubUglDeleteQueriesrH  h)ÅrI  }rJ  (hjH  hUglDeleteQueriesh	Udelete named query objectsubUglRenderbufferStoragerK  h)ÅrL  }rM  (hjK  hUglRenderbufferStorageh	UNestablish data storage, format and dimensions of a renderbuffer object's imageubUglBindBuffersBaserN  h)ÅrO  }rP  (hjN  hUglBindBuffersBaseh	UGbind one or more buffer objects to a sequence of indexed buffer targetsubUglBeginConditionalRenderrQ  h)ÅrR  }rS  (hjQ  hUglBeginConditionalRenderh	Ustart conditional renderingubUglDrawElementsBaseVertexrT  h)ÅrU  }rV  (hjT  hUglDrawElementsBaseVertexh	U;render primitives from array data with a per-element offsetubUglSampleCoveragerW  h)ÅrX  }rY  (hjW  hUglSampleCoverageh	U'specify multisample coverage parametersubUglClearBufferSubDatarZ  h)År[  }r\  (hjZ  hUglClearBufferSubDatah	UAfill all or part of buffer object's data store with a fixed valueubUglTexStorage1Dr]  h)År^  }r_  (hj]  hUglTexStorage1Dh	UJsimultaneously specify storage for all levels of a one-dimensional textureubUglUniform1fr`  h)Åra  }rb  (hj`  hhHh	hIubUglGetVertexAttribfvrc  h)Ård  }re  (hjc  hhÉh	hÑubUglDispatchComputerf  h)Årg  }rh  (hjf  hUglDispatchComputeh	U&launch one or more compute work groupsubUglGetCompressedTexImageri  h)Årj  }rk  (hji  hUglGetCompressedTexImageh	U!return a compressed texture imageubUglUniform1irl  h)Årm  }rn  (hjl  hhHh	hIubUglGetActiveAttribro  h)Årp  }rq  (hjo  hUglGetActiveAttribh	UWReturns information about an active attribute variable for the specified program objectubUglGetTexParameterrr  h)Års  }rt  (hjr  hUglGetTexParameterh	Ureturn texture parameter valuesubUglTexSubImage2Dru  h)Årv  }rw  (hju  hUglTexSubImage2Dh	U*specify a two-dimensional texture subimageubUglGetUniformivrx  h)Åry  }rz  (hjx  hjè  h	jê  ubU	glLogicOpr{  h)År|  }r}  (hj{  hU	glLogicOph	U/specify a logical pixel operation for renderingubUglProgramUniformMatrix3x4fvr~  h)År  }rÄ  (hj~  hh=h	h>ubUglProgramUniform4uivrÅ  h)ÅrÇ  }rÉ  (hjÅ  hh=h	h>ubUglUniform4uirÑ  h)ÅrÖ  }rÜ  (hjÑ  hhHh	hIubUglBindFramebufferrá  h)Årà  }râ  (hjá  hUglBindFramebufferh	U*bind a framebuffer to a framebuffer targetubU
glCullFacerä  h)Årã  }rå  (hjä  hU
glCullFaceh	U:specify whether front- or back-facing facets can be culledubUglProgramUniform4irç  h)Åré  }rè  (hjç  hh=h	h>ubUglProgramUniform4frê  h)Årë  }rí  (hjê  hh=h	h>ubUglUniformSubroutinesrì  h)Årî  }rï  (hjì  hUglUniformSubroutinesh	Uload active subroutine uniformsubUglScissorIndexedrñ  h)Åró  }rò  (hjñ  hUglScissorIndexedh	U.define the scissor box for a specific viewportubUglDrawTransformFeedbackStreamrô  h)Årö  }rõ  (hjô  hUglDrawTransformFeedbackStreamh	U]render primitives using a count derived from a specifed stream of a transform feedback objectubUglAttachShaderrú  h)Årù  }rû  (hjú  hUglAttachShaderh	U,Attaches a shader object to a program objectubUglQueryCounterrü  h)År†  }r°  (hjü  hUglQueryCounterh	UÑrecord the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.ubUglProvokingVertexr¢  h)År£  }r§  (hj¢  hUglProvokingVertexh	UMspecifiy the vertex to be used as the source of data for flat shaded varyingsubUglShaderBinaryr•  h)År¶  }rß  (hj•  hUglShaderBinaryh	U!load pre-compiled shader binariesubUglDrawElementsr®  h)År©  }r™  (hj®  hUglDrawElementsh	U!render primitives from array dataubUglViewportIndexedr´  h)År¨  }r≠  (hj´  hUglViewportIndexedh	Uset a specified viewportubU&glDrawTransformFeedbackStreamInstancedrÆ  h)ÅrØ  }r∞  (hjÆ  hU&glDrawTransformFeedbackStreamInstancedh	Usrender multiple instances of primitives using a count derived from a specifed stream of a transform feedback objectubUglCreateShaderProgramvr±  h)År≤  }r≥  (hj±  hUglCreateShaderProgramh	UQcreate a stand-alone program from an array of null-terminated source code stringsubUglReadBufferr¥  h)Årµ  }r∂  (hj¥  hUglReadBufferh	U'select a color buffer source for pixelsubUglDrawArraysInstancedr∑  h)År∏  }rπ  (hj∑  hUglDrawArraysInstancedh	U.draw multiple instances of a range of elementsubUglGenerateMipmapr∫  h)Årª  }rº  (hj∫  hUglGenerateMipmaph	U/generate mipmaps for a specified texture targetubUglProgramUniformMatrix2fvrΩ  h)Åræ  }rø  (hjΩ  hh=h	h>ubUglBlendColorr¿  h)År¡  }r¬  (hj¿  hUglBlendColorh	Uset the blend colorubUglProgramUniform1ivr√  h)Årƒ  }r≈  (hj√  hh=h	h>ubUglBindRenderbufferr∆  h)År«  }r»  (hj∆  hUglBindRenderbufferh	U,bind a renderbuffer to a renderbuffer targetubUglIsProgramr…  h)År   }rÀ  (hj…  hUglIsProgramh	U4Determines if a name corresponds to a program objectubUglIsTransformFeedbackrÃ  h)ÅrÕ  }rŒ  (hjÃ  hUglIsTransformFeedbackh	U>determine if a name corresponds to a transform feedback objectubUglUniform4irœ  h)År–  }r—  (hjœ  hhHh	hIubUglActiveTexturer“  h)År”  }r‘  (hj“  hUglActiveTextureh	Uselect active texture unitubUglEnableVertexAttribArrayr’  h)År÷  }r◊  (hj’  hhÕh	hŒubUglIsProgramPipelinerÿ  h)ÅrŸ  }r⁄  (hjÿ  hUglIsProgramPipelineh	U<determine if a name corresponds to a program pipeline objectubUglReadPixelsr€  h)År‹  }r›  (hj€  hUglReadPixelsh	U,read a block of pixels from the frame bufferubUglUniform4frﬁ  h)Årﬂ  }r‡  (hjﬁ  hhHh	hIubU glRenderbufferStorageMultisampler·  h)År‚  }r„  (hj·  hU glRenderbufferStorageMultisampleh	U\establish data storage, format, dimensions and sample count of a renderbuffer object's imageubUglGenVertexArraysr‰  h)ÅrÂ  }rÊ  (hj‰  hUglGenVertexArraysh	U"generate vertex array object namesubUglUniformMatrix3fvrÁ  h)ÅrË  }rÈ  (hjÁ  hhHh	hIubU!glDrawElementsInstancedBaseVertexrÍ  h)ÅrÎ  }rÏ  (hjÍ  hU!glDrawElementsInstancedBaseVertexh	UZrender multiple instances of a set of primitives from array data with a per-element offsetubUglUniform1ivrÌ  h)ÅrÓ  }rÔ  (hjÌ  hhHh	hIubUglGetActiveSubroutineNamer  h)ÅrÒ  }rÚ  (hj  hUglGetActiveSubroutineNameh	U-query the name of an active shader subroutineubUglStencilFuncrÛ  h)ÅrÙ  }rı  (hjÛ  hUglStencilFunch	UCset front and back function and reference value for stencil testingubUglPopDebugGrouprˆ  h)År˜  }r¯  (hjˆ  hUglPopDebugGrouph	Upop the active debug groupubUglUniformBlockBindingr˘  h)År˙  }r˚  (hj˘  hUglUniformBlockBindingh	U1assign a binding point to an active uniform blockubUglProgramUniform3ir¸  h)År˝  }r˛  (hj¸  hh=h	h>ubUglUseProgramStagesrˇ  h)År   }r  (hjˇ  hUglUseProgramStagesh	U5bind stages of a program object to a program pipelineubUglViewportArrayr  h)År  }r  (hj  hUglViewportArrayh	Uset multiple viewportsubUglProgramUniformMatrix3x2fvr  h)År  }r  (hj  hh=h	h>ubUglGetQueryIndexedivr  h)År	  }r
  (hj  hUglGetQueryIndexedh	U3return parameters of an indexed query object targetubUglGetShaderInfoLogr  h)År  }r  (hj  hUglGetShaderInfoLogh	U/Returns the information log for a shader objectubUglObjectLabelr  h)År  }r  (hj  hUglObjectLabelh	U2label a named object identified within a namespaceubUglGetBufferSubDatar  h)År  }r  (hj  hUglGetBufferSubDatah	U0returns a subset of a buffer object's data storeubUglGetVertexAttribLdvr  h)År  }r  (hj  hhÉh	hÑubUglBlendEquationSeparater  h)År  }r  (hj  hUglBlendEquationSeparateh	UBset the RGB blend equation and the alpha blend equation separatelyubUglGenBuffersr  h)År  }r  (hj  hUglGenBuffersh	Ugenerate buffer object namesubUglGetSubroutineIndexr  h)År  }r  (hj  hUglGetSubroutineIndexh	USretrieve the index of a subroutine uniform of a given shader stage within a programubUglBlendFuncr   h)År!  }r"  (hj   hUglBlendFunch	Uspecify pixel arithmeticubUglCreateProgramr#  h)År$  }r%  (hj#  hUglCreateProgramh	UCreates a program objectubUglTexImage3Dr&  h)År'  }r(  (hj&  hUglTexImage3Dh	U)specify a three-dimensional texture imageubUglIsFramebufferr)  h)År*  }r+  (hj)  hUglIsFramebufferh	U7determine if a name corresponds to a framebuffer objectubUglPrimitiveRestartIndexr,  h)År-  }r.  (hj,  hUglPrimitiveRestartIndexh	U#specify the primitive restart indexubUglInvalidateTexSubImager/  h)År0  }r1  (hj/  hUglInvalidateTexSubImageh	U&invalidate a region of a texture imageubUglPointParameterr2  h)År3  }r4  (hj2  hUglPointParameterh	Uspecify point parametersubUglBindProgramPipeliner5  h)År6  }r7  (hj5  hUglBindProgramPipelineh	U.bind a program pipeline to the current contextubU	glScissorr8  h)År9  }r:  (hj8  hU	glScissorh	Udefine the scissor boxubUglUniform3uivr;  h)År<  }r=  (hj;  hhHh	hIubUglClearColorr>  h)År?  }r@  (hj>  hUglClearColorh	U*specify clear values for the color buffersubUglGetUniformBlockIndexrA  h)ÅrB  }rC  (hjA  hUglGetUniformBlockIndexh	U+retrieve the index of a named uniform blockubUglProgramParameterrD  h)ÅrE  }rF  (hjD  hUglProgramParameterh	U(specify a parameter for a program objectubUglUniform3uirG  h)ÅrH  }rI  (hjG  hhHh	hIubUglProgramUniform3uivrJ  h)ÅrK  }rL  (hjJ  hh=h	h>ubUglGetQueryObjectrM  h)ÅrN  }rO  (hjM  hUglGetQueryObjecth	U#return parameters of a query objectubUglIsEnabled, glIsEnabledirP  h)ÅrQ  }rR  (hjP  hUglIsEnabledh	U$test whether a capability is enabledubUglUniform2fvrS  h)ÅrT  }rU  (hjS  hhHh	hIubU glGetActiveSubroutineUniformNamerV  h)ÅrW  }rX  (hjV  hU glGetActiveSubroutineUniformNameh	U5query the name of an active shader subroutine uniformubUglGetProgramResourceIndexrY  h)ÅrZ  }r[  (hjY  hUglGetProgramResourceIndexh	U4query the index of a named resource within a programubUglDispatchComputeIndirectr\  h)År]  }r^  (hj\  hUglDispatchComputeIndirecth	UJlaunch one or more compute work groups using parameters stored in a bufferubUglBindBufferRanger_  h)År`  }ra  (hj_  hUglBindBufferRangeh	U?bind a range within a buffer object to an indexed buffer targetubUglUniformMatrix2x3fvrb  h)Årc  }rd  (hjb  hhHh	hIubUglGenTransformFeedbacksre  h)Årf  }rg  (hje  hUglGenTransformFeedbacksh	U'reserve transform feedback object namesubUglGetVertexAttribIuivrh  h)Åri  }rj  (hjh  hhÉh	hÑubUglDepthFuncrk  h)Årl  }rm  (hjk  hUglDepthFunch	U3specify the value used for depth buffer comparisonsubUglCompressedTexSubImage2Drn  h)Åro  }rp  (hjn  hUglCompressedTexSubImage2Dh	UAspecify a two-dimensional texture subimage in a compressed formatubUglProgramBinaryrq  h)Årr  }rs  (hjq  hUglProgramBinaryh	U+load a program object with a program binaryubUglBufferStoragert  h)Åru  }rv  (hjt  hUglBufferStorageh	U>creates and initializes a buffer object's immutable data storeubUglVertexAttribrw  h)Årx  }ry  (hjw  hUglVertexAttribh	U1Specifies the value of a generic vertex attributeubUglClientWaitSyncrz  h)År{  }r|  (hjz  hUglClientWaitSynch	U3block and wait for a sync object to become signaledubUglBlendEquationr}  h)År~  }r  (hj}  hUglBlendEquationh	UVspecify the equation used for both the RGB blend equation and the Alpha blend equationubUglGetUniformLocationrÄ  h)ÅrÅ  }rÇ  (hjÄ  hUglGetUniformLocationh	U*Returns the location of a uniform variableubUglCopyImageSubDatarÉ  h)ÅrÑ  }rÖ  (hjÉ  hUglCopyImageSubDatah	U*perform a raw data copy between two imagesubUglTexImage2DMultisamplerÜ  h)Årá  }rà  (hjÜ  hUglTexImage2DMultisampleh	Ufestablish the data storage, format, dimensions, and number of samples of a multisample texture's imageubUglBindVertexBufferrâ  h)Årä  }rã  (hjâ  hUglBindVertexBufferh	U+bind a buffer to a vertex buffer bind pointubUglDebugMessageInsertrå  h)Årç  }ré  (hjå  hUglDebugMessageInserth	UCinject an application-supplied message into the debug message queueubUglClearBufferDatarè  h)Årê  }rë  (hjè  hUglClearBufferDatah	U4fill a buffer object's data store with a fixed valueubUglBeginTransformFeedbackrí  h)Årì  }rî  (hjí  hUglBeginTransformFeedbackh	U"start transform feedback operationubUglIsSamplerrï  h)Årñ  }ró  (hjï  hUglIsSamplerh	U3determine if a name corresponds to a sampler objectubUglVertexAttribDivisorrò  h)Årô  }rö  (hjò  hUglVertexAttribDivisorh	UUmodify the rate at which generic vertex attributes advance during instanced renderingubUglBindSamplersrõ  h)Årú  }rù  (hjõ  hUglBindSamplersh	UQbind one or more named sampler objects to a sequence of consecutive sampler unitsubUglCompressedTexImage1Drû  h)Årü  }r†  (hjû  hUglCompressedTexImage1Dh	U>specify a one-dimensional texture image in a compressed formatubUglDeleteTransformFeedbacksr°  h)År¢  }r£  (hj°  hUglDeleteTransformFeedbacksh	U!delete transform feedback objectsubUglCopyTexSubImage1Dr§  h)År•  }r¶  (hj§  hUglCopyTexSubImage1Dh	U'copy a one-dimensional texture subimageubUglDrawRangeElementsBaseVertexrß  h)År®  }r©  (hjß  hUglDrawRangeElementsBaseVertexh	U;render primitives from array data with a per-element offsetubUglCheckFramebufferStatusr™  h)År´  }r¨  (hj™  hUglCheckFramebufferStatush	U.check the completeness status of a framebufferubUglBindAttribLocationr≠  h)ÅrÆ  }rØ  (hj≠  hUglBindAttribLocationh	UKAssociates a generic vertex attribute index with a named attribute variableubUglUniformMatrix4x2fvr∞  h)År±  }r≤  (hj∞  hhHh	hIubUglProgramUniform2uivr≥  h)År¥  }rµ  (hj≥  hh=h	h>ubUglDrawRangeElementsr∂  h)År∑  }r∏  (hj∂  hUglDrawRangeElementsh	U!render primitives from array dataubUglColorMask, glColorMaskirπ  h)År∫  }rª  (hjπ  hUglColorMaskh	U;enable and disable writing of frame buffer color componentsubUglBindBufferBaserº  h)ÅrΩ  }ræ  (hjº  hUglBindBufferBaseh	U0bind a buffer object to an indexed buffer targetubUglBufferSubDatarø  h)År¿  }r¡  (hjø  hUglBufferSubDatah	U0updates a subset of a buffer object's data storeubUglMapBufferRanger¬  h)År√  }rƒ  (hj¬  hUglMapBufferRangeh	U-map a section of a buffer object's data storeubUglFramebufferTexturer≈  h)År∆  }r«  (hj≈  hUglFramebufferTextureh	U`attach a level of a texture object as a logical buffer to the currently bound framebuffer objectubUglProgramUniformMatrix4x2fvr»  h)År…  }r   (hj»  hh=h	h>ubUglMultiDrawArraysrÀ  h)ÅrÃ  }rÕ  (hjÀ  hUglMultiDrawArraysh	U2render multiple sets of primitives from array dataubUglGetProgramResourcerŒ  h)Årœ  }r–  (hjŒ  hUglGetProgramResourceh	U[retrieve values for multiple properties of a single active resource within a program objectubUglGetShaderPrecisionFormatr—  h)År“  }r”  (hj—  hUglGetShaderPrecisionFormath	UUretrieve the range and precision for numeric formats supported by the shader compilerubUglTextureViewr‘  h)År’  }r÷  (hj‘  hUglTextureViewh	UDinitialize a texture as a data alias of another texture's data storeubUglProgramUniformMatrix2x4fvr◊  h)Årÿ  }rŸ  (hj◊  hh=h	h>ubUglCopyBufferSubDatar⁄  h)År€  }r‹  (hj⁄  hUglCopyBufferSubDatah	UYcopy part of the data store of a buffer object to the data store of another buffer objectubUglShaderSourcer›  h)Årﬁ  }rﬂ  (hj›  hUglShaderSourceh	U+Replaces the source code in a shader objectubUglGetActiveUniformBlockNamer‡  h)År·  }r‚  (hj‡  hUglGetActiveUniformBlockNameh	U,retrieve the name of an active uniform blockubUglReleaseShaderCompilerr„  h)År‰  }rÂ  (hj„  hUglReleaseShaderCompilerh	UBrelease resources consumed by the implementation's shader compilerubUglGetSamplerParameterrÊ  h)ÅrÁ  }rË  (hjÊ  hUglGetSamplerParameterh	Ureturn sampler parameter valuesubUglGetSyncivrÈ  h)ÅrÍ  }rÎ  (hjÈ  hU	glGetSynch	U%query the properties of a sync objectubUglGetrÏ  h)ÅrÌ  }rÓ  (hjÏ  hUglGeth	U2return the value or values of a selected parameterubUglProgramUniform2irÔ  h)År  }rÒ  (hjÔ  hh=h	h>ubUglBeginQueryrÚ  h)ÅrÛ  }rÙ  (hjÚ  hUglBeginQueryh	U(delimit the boundaries of a query objectubUglScissorArrayrı  h)Årˆ  }r˜  (hjı  hUglScissorArrayh	U-define the scissor box for multiple viewportsubUglBindBufferr¯  h)År˘  }r˙  (hj¯  hUglBindBufferh	Ubind a named buffer objectubUglClearDepthr˚  h)År¸  }r˝  (hj˚  hUglClearDepthh	U,specify the clear value for the depth bufferubUglGetFramebufferParameterr˛  h)Årˇ  }r   (hj˛  hUglGetFramebufferParameterh	U-retrieve a named parameter from a framebufferubUglProgramUniform2fr  h)År  }r  (hj  hh=h	h>ubUglUniformMatrix2fvr  h)År  }r  (hj  hhHh	hIubUglUniformMatrix2x4fvr  h)År  }r	  (hj  hhHh	hIubUglBufferDatar
  h)År  }r  (hj
  hUglBufferDatah	U4creates and initializes a buffer object's data storeubUglDepthRangeIndexedr  h)År  }r  (hj  hUglDepthRangeIndexedh	Uqspecify mapping of depth values from normalized device coordinates to window coordinates for a specified viewportubUglPauseTransformFeedbackr  h)År  }r  (hj  hUglPauseTransformFeedbackh	U#pause transform feedback operationsubU
glGetErrorr  h)År  }r  (hj  hU
glGetErrorh	Ureturn error informationubUglTexSubImage1Dr  h)År  }r  (hj  hUglTexSubImage1Dh	U*specify a one-dimensional texture subimageubUglGetBufferPointervr  h)År  }r  (hj  hUglGetBufferPointervh	U9return the pointer to a mapped buffer object's data storeubU	glIsQueryr  h)År  }r  (hj  hU	glIsQueryh	U1determine if a name corresponds to a query objectubU%glGetFramebufferAttachmentParameterivr  h)År   }r!  (hj  hU#glGetFramebufferAttachmentParameterh	UDretrieve information about attachments of a bound framebuffer objectubUglProgramUniform4uir"  h)År#  }r$  (hj"  hh=h	h>ubUglTexImage2Dr%  h)År&  }r'  (hj%  hUglTexImage2Dh	U'specify a two-dimensional texture imageubUglStencilMaskr(  h)År)  }r*  (hj(  hUglStencilMaskh	UKcontrol the front and back writing of individual bits in the stencil planesubUglIsTexturer+  h)År,  }r-  (hj+  hUglIsTextureh	U,determine if a name corresponds to a textureubUglUniform1fvr.  h)År/  }r0  (hj.  hhHh	hIubUglSamplerParameterr1  h)År2  }r3  (hj1  hUglSamplerParameterh	Uset sampler parametersubUglProgramUniform3fvr4  h)År5  }r6  (hj4  hh=h	h>ubUglGetSubroutineUniformLocationr7  h)År8  }r9  (hj7  hUglGetSubroutineUniformLocationh	UVretrieve the location of a subroutine uniform of a given shader stage within a programubUglHintr:  h)År;  }r<  (hj:  hUglHinth	U%specify implementation-specific hintsubUglGetTexLevelParameterr=  h)År>  }r?  (hj=  hUglGetTexLevelParameterh	U>return texture parameter values for a specific level of detailubUglGetActiveUniformBlockr@  h)ÅrA  }rB  (hj@  hUglGetActiveUniformBlockh	U/query information about an active uniform blockubUglTexImage1DrC  h)ÅrD  }rE  (hjC  hUglTexImage1Dh	U'specify a one-dimensional texture imageubUglInvalidateFramebufferrF  h)ÅrG  }rH  (hjF  hUglInvalidateFramebufferh	UHinvalidate the content some or all of a framebuffer object's attachmentsubUglDepthMaskrI  h)ÅrJ  }rK  (hjI  hUglDepthMaskh	U/enable or disable writing into the depth bufferubUglTexImage3DMultisamplerL  h)ÅrM  }rN  (hjL  hUglTexImage3DMultisampleh	Ufestablish the data storage, format, dimensions, and number of samples of a multisample texture's imageubUglProgramUniform1fvrO  h)ÅrP  }rQ  (hjO  hh=h	h>ubUglUniformMatrix4fvrR  h)ÅrS  }rT  (hjR  hhHh	hIubUglUniform4fvrU  h)ÅrV  }rW  (hjU  hhHh	hIubUglGetActiveUniformrX  h)ÅrY  }rZ  (hjX  hUglGetActiveUniformh	UUReturns information about an active uniform variable for the specified program objectubUglFrontFacer[  h)År\  }r]  (hj[  hUglFrontFaceh	U&define front- and back-facing polygonsubUglTexBufferRanger^  h)År_  }r`  (hj^  hUglTexBufferRangeh	U9bind a range of a buffer's data store to a buffer textureubU!glDrawArraysInstancedBaseInstancera  h)Årb  }rc  (hja  hU!glDrawArraysInstancedBaseInstanceh	UZdraw multiple instances of a range of elements with offset applied to instanced attributesubUglDeleteProgramPipelinesrd  h)Åre  }rf  (hjd  hUglDeleteProgramPipelinesh	Udelete program pipeline objectsubu}rg  Unamerh  Uman4sb.