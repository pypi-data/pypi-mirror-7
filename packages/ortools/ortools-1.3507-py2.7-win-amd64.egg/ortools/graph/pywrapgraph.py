# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pywrapgraph', [dirname(__file__)])
        except ImportError:
            import _pywrapgraph
            return _pywrapgraph
        if fp is not None:
            try:
                _mod = imp.load_module('_pywrapgraph', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pywrapgraph = swig_import_helper()
    del swig_import_helper
else:
    import _pywrapgraph
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapgraph.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _pywrapgraph.SwigPyIterator_value(self)
    def incr(self, n=1): return _pywrapgraph.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _pywrapgraph.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _pywrapgraph.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _pywrapgraph.SwigPyIterator_equal(self, *args)
    def copy(self): return _pywrapgraph.SwigPyIterator_copy(self)
    def next(self): return _pywrapgraph.SwigPyIterator_next(self)
    def __next__(self): return _pywrapgraph.SwigPyIterator___next__(self)
    def previous(self): return _pywrapgraph.SwigPyIterator_previous(self)
    def advance(self, *args): return _pywrapgraph.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _pywrapgraph.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _pywrapgraph.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _pywrapgraph.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _pywrapgraph.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _pywrapgraph.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _pywrapgraph.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _pywrapgraph.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class LinearSumAssignment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearSumAssignment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinearSumAssignment, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pywrapgraph.new_LinearSumAssignment()
        try: self.this.append(this)
        except: self.this = this
    def AddArcWithCost(self, *args): return _pywrapgraph.LinearSumAssignment_AddArcWithCost(self, *args)
    def NumNodes(self): return _pywrapgraph.LinearSumAssignment_NumNodes(self)
    def NumArcs(self): return _pywrapgraph.LinearSumAssignment_NumArcs(self)
    def LeftNode(self, *args): return _pywrapgraph.LinearSumAssignment_LeftNode(self, *args)
    def RightNode(self, *args): return _pywrapgraph.LinearSumAssignment_RightNode(self, *args)
    def Cost(self, *args): return _pywrapgraph.LinearSumAssignment_Cost(self, *args)
    OPTIMAL = _pywrapgraph.LinearSumAssignment_OPTIMAL
    INFEASIBLE = _pywrapgraph.LinearSumAssignment_INFEASIBLE
    POSSIBLE_OVERFLOW = _pywrapgraph.LinearSumAssignment_POSSIBLE_OVERFLOW
    def Solve(self): return _pywrapgraph.LinearSumAssignment_Solve(self)
    def OptimalCost(self): return _pywrapgraph.LinearSumAssignment_OptimalCost(self)
    def RightMate(self, *args): return _pywrapgraph.LinearSumAssignment_RightMate(self, *args)
    def AssignmentCost(self, *args): return _pywrapgraph.LinearSumAssignment_AssignmentCost(self, *args)
    __swig_destroy__ = _pywrapgraph.delete_LinearSumAssignment
    __del__ = lambda self : None;
LinearSumAssignment_swigregister = _pywrapgraph.LinearSumAssignment_swigregister
LinearSumAssignment_swigregister(LinearSumAssignment)

class SimpleMaxFlow(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleMaxFlow, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleMaxFlow, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pywrapgraph.new_SimpleMaxFlow()
        try: self.this.append(this)
        except: self.this = this
    def AddArcWithCapacity(self, *args): return _pywrapgraph.SimpleMaxFlow_AddArcWithCapacity(self, *args)
    def NumNodes(self): return _pywrapgraph.SimpleMaxFlow_NumNodes(self)
    def NumArcs(self): return _pywrapgraph.SimpleMaxFlow_NumArcs(self)
    def Tail(self, *args): return _pywrapgraph.SimpleMaxFlow_Tail(self, *args)
    def Head(self, *args): return _pywrapgraph.SimpleMaxFlow_Head(self, *args)
    def Capacity(self, *args): return _pywrapgraph.SimpleMaxFlow_Capacity(self, *args)
    OPTIMAL = _pywrapgraph.SimpleMaxFlow_OPTIMAL
    POSSIBLE_OVERFLOW = _pywrapgraph.SimpleMaxFlow_POSSIBLE_OVERFLOW
    BAD_INPUT = _pywrapgraph.SimpleMaxFlow_BAD_INPUT
    BAD_RESULT = _pywrapgraph.SimpleMaxFlow_BAD_RESULT
    def Solve(self, *args): return _pywrapgraph.SimpleMaxFlow_Solve(self, *args)
    def OptimalFlow(self): return _pywrapgraph.SimpleMaxFlow_OptimalFlow(self)
    def Flow(self, *args): return _pywrapgraph.SimpleMaxFlow_Flow(self, *args)
    def GetSourceSideMinCut(self): return _pywrapgraph.SimpleMaxFlow_GetSourceSideMinCut(self)
    def GetSinkSideMinCut(self): return _pywrapgraph.SimpleMaxFlow_GetSinkSideMinCut(self)
    __swig_destroy__ = _pywrapgraph.delete_SimpleMaxFlow
    __del__ = lambda self : None;
SimpleMaxFlow_swigregister = _pywrapgraph.SimpleMaxFlow_swigregister
SimpleMaxFlow_swigregister(SimpleMaxFlow)

class MaxFlowStatusClass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaxFlowStatusClass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MaxFlowStatusClass, name)
    __repr__ = _swig_repr
    NOT_SOLVED = _pywrapgraph.MaxFlowStatusClass_NOT_SOLVED
    OPTIMAL = _pywrapgraph.MaxFlowStatusClass_OPTIMAL
    POSSIBLE_OVERFLOW = _pywrapgraph.MaxFlowStatusClass_POSSIBLE_OVERFLOW
    BAD_INPUT = _pywrapgraph.MaxFlowStatusClass_BAD_INPUT
    BAD_RESULT = _pywrapgraph.MaxFlowStatusClass_BAD_RESULT
    def __init__(self): 
        this = _pywrapgraph.new_MaxFlowStatusClass()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapgraph.delete_MaxFlowStatusClass
    __del__ = lambda self : None;
MaxFlowStatusClass_swigregister = _pywrapgraph.MaxFlowStatusClass_swigregister
MaxFlowStatusClass_swigregister(MaxFlowStatusClass)

class MinCostFlowBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinCostFlowBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinCostFlowBase, name)
    __repr__ = _swig_repr
    NOT_SOLVED = _pywrapgraph.MinCostFlowBase_NOT_SOLVED
    OPTIMAL = _pywrapgraph.MinCostFlowBase_OPTIMAL
    FEASIBLE = _pywrapgraph.MinCostFlowBase_FEASIBLE
    INFEASIBLE = _pywrapgraph.MinCostFlowBase_INFEASIBLE
    UNBALANCED = _pywrapgraph.MinCostFlowBase_UNBALANCED
    BAD_RESULT = _pywrapgraph.MinCostFlowBase_BAD_RESULT
    BAD_COST_RANGE = _pywrapgraph.MinCostFlowBase_BAD_COST_RANGE
    def __init__(self): 
        this = _pywrapgraph.new_MinCostFlowBase()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapgraph.delete_MinCostFlowBase
    __del__ = lambda self : None;
MinCostFlowBase_swigregister = _pywrapgraph.MinCostFlowBase_swigregister
MinCostFlowBase_swigregister(MinCostFlowBase)

class SimpleMinCostFlow(MinCostFlowBase):
    __swig_setmethods__ = {}
    for _s in [MinCostFlowBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleMinCostFlow, name, value)
    __swig_getmethods__ = {}
    for _s in [MinCostFlowBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleMinCostFlow, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pywrapgraph.new_SimpleMinCostFlow()
        try: self.this.append(this)
        except: self.this = this
    def AddArcWithCapacityAndUnitCost(self, *args): return _pywrapgraph.SimpleMinCostFlow_AddArcWithCapacityAndUnitCost(self, *args)
    def SetNodeSupply(self, *args): return _pywrapgraph.SimpleMinCostFlow_SetNodeSupply(self, *args)
    def Solve(self): return _pywrapgraph.SimpleMinCostFlow_Solve(self)
    def SolveMaxFlowWithMinCost(self): return _pywrapgraph.SimpleMinCostFlow_SolveMaxFlowWithMinCost(self)
    def OptimalCost(self): return _pywrapgraph.SimpleMinCostFlow_OptimalCost(self)
    def MaximumFlow(self): return _pywrapgraph.SimpleMinCostFlow_MaximumFlow(self)
    def Flow(self, *args): return _pywrapgraph.SimpleMinCostFlow_Flow(self, *args)
    def NumNodes(self): return _pywrapgraph.SimpleMinCostFlow_NumNodes(self)
    def NumArcs(self): return _pywrapgraph.SimpleMinCostFlow_NumArcs(self)
    def Tail(self, *args): return _pywrapgraph.SimpleMinCostFlow_Tail(self, *args)
    def Head(self, *args): return _pywrapgraph.SimpleMinCostFlow_Head(self, *args)
    def Capacity(self, *args): return _pywrapgraph.SimpleMinCostFlow_Capacity(self, *args)
    def Supply(self, *args): return _pywrapgraph.SimpleMinCostFlow_Supply(self, *args)
    def UnitCost(self, *args): return _pywrapgraph.SimpleMinCostFlow_UnitCost(self, *args)
    __swig_destroy__ = _pywrapgraph.delete_SimpleMinCostFlow
    __del__ = lambda self : None;
SimpleMinCostFlow_swigregister = _pywrapgraph.SimpleMinCostFlow_swigregister
SimpleMinCostFlow_swigregister(SimpleMinCostFlow)

class StarStarGraphBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StarStarGraphBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StarStarGraphBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def num_nodes(self): return _pywrapgraph.StarStarGraphBase_num_nodes(self)
    def num_arcs(self): return _pywrapgraph.StarStarGraphBase_num_arcs(self)
    def end_node_index(self): return _pywrapgraph.StarStarGraphBase_end_node_index(self)
    def end_arc_index(self): return _pywrapgraph.StarStarGraphBase_end_arc_index(self)
    def max_num_nodes(self): return _pywrapgraph.StarStarGraphBase_max_num_nodes(self)
    def max_num_arcs(self): return _pywrapgraph.StarStarGraphBase_max_num_arcs(self)
    def max_end_node_index(self): return _pywrapgraph.StarStarGraphBase_max_end_node_index(self)
    def max_end_arc_index(self): return _pywrapgraph.StarStarGraphBase_max_end_arc_index(self)
    def IsNodeValid(self, *args): return _pywrapgraph.StarStarGraphBase_IsNodeValid(self, *args)
    def LookUpArc(self, *args): return _pywrapgraph.StarStarGraphBase_LookUpArc(self, *args)
    def Head(self, *args): return _pywrapgraph.StarStarGraphBase_Head(self, *args)
    def NodeDebugString(self, *args): return _pywrapgraph.StarStarGraphBase_NodeDebugString(self, *args)
    def ArcDebugString(self, *args): return _pywrapgraph.StarStarGraphBase_ArcDebugString(self, *args)
StarStarGraphBase_swigregister = _pywrapgraph.StarStarGraphBase_swigregister
StarStarGraphBase_swigregister(StarStarGraphBase)
cvar = _pywrapgraph.cvar
StarStarGraphBase.kNilNode = _pywrapgraph.cvar.StarStarGraphBase_kNilNode
StarStarGraphBase.kNilArc = _pywrapgraph.cvar.StarStarGraphBase_kNilArc
StarStarGraphBase.kFirstNode = _pywrapgraph.cvar.StarStarGraphBase_kFirstNode
StarStarGraphBase.kFirstArc = _pywrapgraph.cvar.StarStarGraphBase_kFirstArc
StarStarGraphBase.kMaxNumNodes = _pywrapgraph.cvar.StarStarGraphBase_kMaxNumNodes
StarStarGraphBase.kMaxNumArcs = _pywrapgraph.cvar.StarStarGraphBase_kMaxNumArcs

class StarGraphCore(StarStarGraphBase):
    __swig_setmethods__ = {}
    for _s in [StarStarGraphBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StarGraphCore, name, value)
    __swig_getmethods__ = {}
    for _s in [StarStarGraphBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StarGraphCore, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Reserve(self, *args): return _pywrapgraph.StarGraphCore_Reserve(self, *args)
    def AddArc(self, *args): return _pywrapgraph.StarGraphCore_AddArc(self, *args)
StarGraphCore_swigregister = _pywrapgraph.StarGraphCore_swigregister
StarGraphCore_swigregister(StarGraphCore)

class StarGraph(StarGraphCore):
    __swig_setmethods__ = {}
    for _s in [StarGraphCore]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StarGraph, name, value)
    __swig_getmethods__ = {}
    for _s in [StarGraphCore]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StarGraph, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pywrapgraph.new_StarGraph(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapgraph.delete_StarGraph
    __del__ = lambda self : None;
    def CheckArcBounds(self, *args): return _pywrapgraph.StarGraph_CheckArcBounds(self, *args)
    def CheckArcValidity(self, *args): return _pywrapgraph.StarGraph_CheckArcValidity(self, *args)
    def Tail(self, *args): return _pywrapgraph.StarGraph_Tail(self, *args)
    def DirectArcTail(self, *args): return _pywrapgraph.StarGraph_DirectArcTail(self, *args)
    def DirectArcHead(self, *args): return _pywrapgraph.StarGraph_DirectArcHead(self, *args)
    def DirectArc(self, *args): return _pywrapgraph.StarGraph_DirectArc(self, *args)
    def ReverseArc(self, *args): return _pywrapgraph.StarGraph_ReverseArc(self, *args)
    def Opposite(self, *args): return _pywrapgraph.StarGraph_Opposite(self, *args)
    def IsDirect(self, *args): return _pywrapgraph.StarGraph_IsDirect(self, *args)
    def IsReverse(self, *args): return _pywrapgraph.StarGraph_IsReverse(self, *args)
    def IsIncident(self, *args): return _pywrapgraph.StarGraph_IsIncident(self, *args)
    def IsIncoming(self, *args): return _pywrapgraph.StarGraph_IsIncoming(self, *args)
    def IsOutgoing(self, *args): return _pywrapgraph.StarGraph_IsOutgoing(self, *args)
    def BuildRepresentation(self): return _pywrapgraph.StarGraph_BuildRepresentation(self)
    def DebugString(self): return _pywrapgraph.StarGraph_DebugString(self)
StarGraph_swigregister = _pywrapgraph.StarGraph_swigregister
StarGraph_swigregister(StarGraph)

class ForwardStarStarGraphBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ForwardStarStarGraphBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ForwardStarStarGraphBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def num_nodes(self): return _pywrapgraph.ForwardStarStarGraphBase_num_nodes(self)
    def num_arcs(self): return _pywrapgraph.ForwardStarStarGraphBase_num_arcs(self)
    def end_node_index(self): return _pywrapgraph.ForwardStarStarGraphBase_end_node_index(self)
    def end_arc_index(self): return _pywrapgraph.ForwardStarStarGraphBase_end_arc_index(self)
    def max_num_nodes(self): return _pywrapgraph.ForwardStarStarGraphBase_max_num_nodes(self)
    def max_num_arcs(self): return _pywrapgraph.ForwardStarStarGraphBase_max_num_arcs(self)
    def max_end_node_index(self): return _pywrapgraph.ForwardStarStarGraphBase_max_end_node_index(self)
    def max_end_arc_index(self): return _pywrapgraph.ForwardStarStarGraphBase_max_end_arc_index(self)
    def IsNodeValid(self, *args): return _pywrapgraph.ForwardStarStarGraphBase_IsNodeValid(self, *args)
    def LookUpArc(self, *args): return _pywrapgraph.ForwardStarStarGraphBase_LookUpArc(self, *args)
    def Head(self, *args): return _pywrapgraph.ForwardStarStarGraphBase_Head(self, *args)
    def NodeDebugString(self, *args): return _pywrapgraph.ForwardStarStarGraphBase_NodeDebugString(self, *args)
    def ArcDebugString(self, *args): return _pywrapgraph.ForwardStarStarGraphBase_ArcDebugString(self, *args)
ForwardStarStarGraphBase_swigregister = _pywrapgraph.ForwardStarStarGraphBase_swigregister
ForwardStarStarGraphBase_swigregister(ForwardStarStarGraphBase)
ForwardStarStarGraphBase.kNilNode = _pywrapgraph.cvar.ForwardStarStarGraphBase_kNilNode
ForwardStarStarGraphBase.kNilArc = _pywrapgraph.cvar.ForwardStarStarGraphBase_kNilArc
ForwardStarStarGraphBase.kFirstNode = _pywrapgraph.cvar.ForwardStarStarGraphBase_kFirstNode
ForwardStarStarGraphBase.kFirstArc = _pywrapgraph.cvar.ForwardStarStarGraphBase_kFirstArc
ForwardStarStarGraphBase.kMaxNumNodes = _pywrapgraph.cvar.ForwardStarStarGraphBase_kMaxNumNodes
ForwardStarStarGraphBase.kMaxNumArcs = _pywrapgraph.cvar.ForwardStarStarGraphBase_kMaxNumArcs

class ForwardStarGraphCore(ForwardStarStarGraphBase):
    __swig_setmethods__ = {}
    for _s in [ForwardStarStarGraphBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ForwardStarGraphCore, name, value)
    __swig_getmethods__ = {}
    for _s in [ForwardStarStarGraphBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ForwardStarGraphCore, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Reserve(self, *args): return _pywrapgraph.ForwardStarGraphCore_Reserve(self, *args)
    def AddArc(self, *args): return _pywrapgraph.ForwardStarGraphCore_AddArc(self, *args)
ForwardStarGraphCore_swigregister = _pywrapgraph.ForwardStarGraphCore_swigregister
ForwardStarGraphCore_swigregister(ForwardStarGraphCore)

class ForwardStarGraph(ForwardStarGraphCore):
    __swig_setmethods__ = {}
    for _s in [ForwardStarGraphCore]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ForwardStarGraph, name, value)
    __swig_getmethods__ = {}
    for _s in [ForwardStarGraphCore]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ForwardStarGraph, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pywrapgraph.new_ForwardStarGraph(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapgraph.delete_ForwardStarGraph
    __del__ = lambda self : None;
    def CheckArcBounds(self, *args): return _pywrapgraph.ForwardStarGraph_CheckArcBounds(self, *args)
    def CheckArcValidity(self, *args): return _pywrapgraph.ForwardStarGraph_CheckArcValidity(self, *args)
    def CheckTailIndexValidity(self, *args): return _pywrapgraph.ForwardStarGraph_CheckTailIndexValidity(self, *args)
    def Tail(self, *args): return _pywrapgraph.ForwardStarGraph_Tail(self, *args)
    def IsIncoming(self, *args): return _pywrapgraph.ForwardStarGraph_IsIncoming(self, *args)
    def BuildRepresentation(self): return _pywrapgraph.ForwardStarGraph_BuildRepresentation(self)
    def BuildTailArray(self): return _pywrapgraph.ForwardStarGraph_BuildTailArray(self)
    def ReleaseTailArray(self): return _pywrapgraph.ForwardStarGraph_ReleaseTailArray(self)
    def TailArrayComplete(self): return _pywrapgraph.ForwardStarGraph_TailArrayComplete(self)
    def DebugString(self): return _pywrapgraph.ForwardStarGraph_DebugString(self)
ForwardStarGraph_swigregister = _pywrapgraph.ForwardStarGraph_swigregister
ForwardStarGraph_swigregister(ForwardStarGraph)

class ForwardStarStaticStarGraphBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ForwardStarStaticStarGraphBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ForwardStarStaticStarGraphBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def num_nodes(self): return _pywrapgraph.ForwardStarStaticStarGraphBase_num_nodes(self)
    def num_arcs(self): return _pywrapgraph.ForwardStarStaticStarGraphBase_num_arcs(self)
    def end_node_index(self): return _pywrapgraph.ForwardStarStaticStarGraphBase_end_node_index(self)
    def end_arc_index(self): return _pywrapgraph.ForwardStarStaticStarGraphBase_end_arc_index(self)
    def max_num_nodes(self): return _pywrapgraph.ForwardStarStaticStarGraphBase_max_num_nodes(self)
    def max_num_arcs(self): return _pywrapgraph.ForwardStarStaticStarGraphBase_max_num_arcs(self)
    def max_end_node_index(self): return _pywrapgraph.ForwardStarStaticStarGraphBase_max_end_node_index(self)
    def max_end_arc_index(self): return _pywrapgraph.ForwardStarStaticStarGraphBase_max_end_arc_index(self)
    def IsNodeValid(self, *args): return _pywrapgraph.ForwardStarStaticStarGraphBase_IsNodeValid(self, *args)
    def LookUpArc(self, *args): return _pywrapgraph.ForwardStarStaticStarGraphBase_LookUpArc(self, *args)
    def Head(self, *args): return _pywrapgraph.ForwardStarStaticStarGraphBase_Head(self, *args)
    def NodeDebugString(self, *args): return _pywrapgraph.ForwardStarStaticStarGraphBase_NodeDebugString(self, *args)
    def ArcDebugString(self, *args): return _pywrapgraph.ForwardStarStaticStarGraphBase_ArcDebugString(self, *args)
ForwardStarStaticStarGraphBase_swigregister = _pywrapgraph.ForwardStarStaticStarGraphBase_swigregister
ForwardStarStaticStarGraphBase_swigregister(ForwardStarStaticStarGraphBase)
ForwardStarStaticStarGraphBase.kNilNode = _pywrapgraph.cvar.ForwardStarStaticStarGraphBase_kNilNode
ForwardStarStaticStarGraphBase.kNilArc = _pywrapgraph.cvar.ForwardStarStaticStarGraphBase_kNilArc
ForwardStarStaticStarGraphBase.kFirstNode = _pywrapgraph.cvar.ForwardStarStaticStarGraphBase_kFirstNode
ForwardStarStaticStarGraphBase.kFirstArc = _pywrapgraph.cvar.ForwardStarStaticStarGraphBase_kFirstArc
ForwardStarStaticStarGraphBase.kMaxNumNodes = _pywrapgraph.cvar.ForwardStarStaticStarGraphBase_kMaxNumNodes
ForwardStarStaticStarGraphBase.kMaxNumArcs = _pywrapgraph.cvar.ForwardStarStaticStarGraphBase_kMaxNumArcs

class ForwardStarStaticGraph(ForwardStarStaticStarGraphBase):
    __swig_setmethods__ = {}
    for _s in [ForwardStarStaticStarGraphBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ForwardStarStaticGraph, name, value)
    __swig_getmethods__ = {}
    for _s in [ForwardStarStaticStarGraphBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ForwardStarStaticGraph, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pywrapgraph.new_ForwardStarStaticGraph(*args)
        try: self.this.append(this)
        except: self.this = this
    def Tail(self, *args): return _pywrapgraph.ForwardStarStaticGraph_Tail(self, *args)
    def IsIncoming(self, *args): return _pywrapgraph.ForwardStarStaticGraph_IsIncoming(self, *args)
    def CheckArcBounds(self, *args): return _pywrapgraph.ForwardStarStaticGraph_CheckArcBounds(self, *args)
    def CheckArcValidity(self, *args): return _pywrapgraph.ForwardStarStaticGraph_CheckArcValidity(self, *args)
    def CheckTailIndexValidity(self, *args): return _pywrapgraph.ForwardStarStaticGraph_CheckTailIndexValidity(self, *args)
    def NextOutgoingArc(self, *args): return _pywrapgraph.ForwardStarStaticGraph_NextOutgoingArc(self, *args)
    def DebugString(self): return _pywrapgraph.ForwardStarStaticGraph_DebugString(self)
    def BuildTailArray(self): return _pywrapgraph.ForwardStarStaticGraph_BuildTailArray(self)
    def ReleaseTailArray(self): return _pywrapgraph.ForwardStarStaticGraph_ReleaseTailArray(self)
    def TailArrayComplete(self): return _pywrapgraph.ForwardStarStaticGraph_TailArrayComplete(self)
    __swig_destroy__ = _pywrapgraph.delete_ForwardStarStaticGraph
    __del__ = lambda self : None;
ForwardStarStaticGraph_swigregister = _pywrapgraph.ForwardStarStaticGraph_swigregister
ForwardStarStaticGraph_swigregister(ForwardStarStaticGraph)

class MaxFlow(MaxFlowStatusClass):
    __swig_setmethods__ = {}
    for _s in [MaxFlowStatusClass]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaxFlow, name, value)
    __swig_getmethods__ = {}
    for _s in [MaxFlowStatusClass]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaxFlow, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pywrapgraph.new_MaxFlow(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pywrapgraph.delete_MaxFlow
    __del__ = lambda self : None;
    def graph(self): return _pywrapgraph.MaxFlow_graph(self)
    def status(self): return _pywrapgraph.MaxFlow_status(self)
    def GetSourceNodeIndex(self): return _pywrapgraph.MaxFlow_GetSourceNodeIndex(self)
    def GetSinkNodeIndex(self): return _pywrapgraph.MaxFlow_GetSinkNodeIndex(self)
    def SetArcCapacity(self, *args): return _pywrapgraph.MaxFlow_SetArcCapacity(self, *args)
    def SetArcFlow(self, *args): return _pywrapgraph.MaxFlow_SetArcFlow(self, *args)
    def Solve(self): return _pywrapgraph.MaxFlow_Solve(self)
    def GetOptimalFlow(self): return _pywrapgraph.MaxFlow_GetOptimalFlow(self)
    def Flow(self, *args): return _pywrapgraph.MaxFlow_Flow(self, *args)
    def Capacity(self, *args): return _pywrapgraph.MaxFlow_Capacity(self, *args)
    def GetSourceSideMinCut(self, *args): return _pywrapgraph.MaxFlow_GetSourceSideMinCut(self, *args)
    def GetSinkSideMinCut(self, *args): return _pywrapgraph.MaxFlow_GetSinkSideMinCut(self, *args)
    def CheckInputConsistency(self): return _pywrapgraph.MaxFlow_CheckInputConsistency(self)
    def CheckResult(self): return _pywrapgraph.MaxFlow_CheckResult(self)
    def SetUseGlobalUpdate(self, *args): return _pywrapgraph.MaxFlow_SetUseGlobalUpdate(self, *args)
    def SetUseTwoPhaseAlgorithm(self, *args): return _pywrapgraph.MaxFlow_SetUseTwoPhaseAlgorithm(self, *args)
    def SetCheckInput(self, *args): return _pywrapgraph.MaxFlow_SetCheckInput(self, *args)
    def SetCheckResult(self, *args): return _pywrapgraph.MaxFlow_SetCheckResult(self, *args)
    def ProcessNodeByHeight(self, *args): return _pywrapgraph.MaxFlow_ProcessNodeByHeight(self, *args)
MaxFlow_swigregister = _pywrapgraph.MaxFlow_swigregister
MaxFlow_swigregister(MaxFlow)

class MinCostFlow(MinCostFlowBase):
    __swig_setmethods__ = {}
    for _s in [MinCostFlowBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinCostFlow, name, value)
    __swig_getmethods__ = {}
    for _s in [MinCostFlowBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MinCostFlow, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pywrapgraph.new_MinCostFlow(*args)
        try: self.this.append(this)
        except: self.this = this
    def graph(self): return _pywrapgraph.MinCostFlow_graph(self)
    def status(self): return _pywrapgraph.MinCostFlow_status(self)
    def SetNodeSupply(self, *args): return _pywrapgraph.MinCostFlow_SetNodeSupply(self, *args)
    def SetArcUnitCost(self, *args): return _pywrapgraph.MinCostFlow_SetArcUnitCost(self, *args)
    def SetArcCapacity(self, *args): return _pywrapgraph.MinCostFlow_SetArcCapacity(self, *args)
    def SetArcFlow(self, *args): return _pywrapgraph.MinCostFlow_SetArcFlow(self, *args)
    def Solve(self): return _pywrapgraph.MinCostFlow_Solve(self)
    def CheckFeasibility(self, *args): return _pywrapgraph.MinCostFlow_CheckFeasibility(self, *args)
    def MakeFeasible(self): return _pywrapgraph.MinCostFlow_MakeFeasible(self)
    def GetOptimalCost(self): return _pywrapgraph.MinCostFlow_GetOptimalCost(self)
    def Flow(self, *args): return _pywrapgraph.MinCostFlow_Flow(self, *args)
    def Capacity(self, *args): return _pywrapgraph.MinCostFlow_Capacity(self, *args)
    def UnitCost(self, *args): return _pywrapgraph.MinCostFlow_UnitCost(self, *args)
    def Supply(self, *args): return _pywrapgraph.MinCostFlow_Supply(self, *args)
    def InitialSupply(self, *args): return _pywrapgraph.MinCostFlow_InitialSupply(self, *args)
    def FeasibleSupply(self, *args): return _pywrapgraph.MinCostFlow_FeasibleSupply(self, *args)
    def SetUseUpdatePrices(self, *args): return _pywrapgraph.MinCostFlow_SetUseUpdatePrices(self, *args)
    def SetCheckFeasibility(self, *args): return _pywrapgraph.MinCostFlow_SetCheckFeasibility(self, *args)
    __swig_destroy__ = _pywrapgraph.delete_MinCostFlow
    __del__ = lambda self : None;
MinCostFlow_swigregister = _pywrapgraph.MinCostFlow_swigregister
MinCostFlow_swigregister(MinCostFlow)

# This file is compatible with both classic and new-style classes.


