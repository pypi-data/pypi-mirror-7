

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>What’s new in MyHDL 0.6 &mdash; MyHDL 0.8 documentation</title>
    
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="MyHDL 0.8 documentation" href="../index.html" />
    <link rel="prev" title="What’s new in MyHDL 0.7" href="0.7.html" /> 
  </head>
  <body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="0.7.html" title="What’s new in MyHDL 0.7"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">MyHDL 0.8 documentation</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">What&#8217;s new in MyHDL 0.6</a><ul>
<li><a class="reference internal" href="#conversion-to-vhdl">Conversion to VHDL</a><ul>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#advantages">Advantages</a></li>
<li><a class="reference internal" href="#solution-description">Solution description</a><ul>
<li><a class="reference internal" href="#approach">Approach</a></li>
<li><a class="reference internal" href="#user-interface">User interface</a></li>
<li><a class="reference internal" href="#type-mapping">Type mapping</a></li>
<li><a class="reference internal" href="#template-transformation">Template transformation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#conversion-of-lists-of-signals">Conversion of lists of signals</a></li>
<li><a class="reference internal" href="#conversion-of-test-benches">Conversion of test benches</a><ul>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#print-statement">Print statement</a></li>
<li><a class="reference internal" href="#assert-statement">Assert statement</a></li>
<li><a class="reference internal" href="#delay-objects">Delay objects</a></li>
<li><a class="reference internal" href="#methodology-notes">Methodology notes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conversion-output-verification">Conversion output verification</a><ul>
<li><a class="reference internal" href="#id1">Approach</a></li>
<li><a class="reference internal" href="#verification-interface">Verification interface</a></li>
<li><a class="reference internal" href="#hdl-simulator-registration">HDL simulator registration</a><ul>
<li><a class="reference internal" href="#example-preregistered-hdl-simulators">Example: preregistered HDL simulators</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#new-modeling-features">New modeling features</a><ul>
<li><a class="reference internal" href="#new-signed-method-for-intbv">New signed() method for intbv</a></li>
<li><a class="reference internal" href="#always-comb-and-list-of-signals">always_comb and list of signals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-incompatible-changes">Backwards incompatible changes</a><ul>
<li><a class="reference internal" href="#decorator-usage">Decorator usage</a></li>
<li><a class="reference internal" href="#instances-function">instances() function</a></li>
<li><a class="reference internal" href="#conversion-of-printing-without-a-newline">Conversion of printing without a newline</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="0.7.html"
                        title="previous chapter">What&#8217;s new in MyHDL 0.7</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/whatsnew/0.6.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="what-s-new-in-myhdl-0-6">
<span id="new06"></span><h1>What&#8217;s new in MyHDL 0.6<a class="headerlink" href="#what-s-new-in-myhdl-0-6" title="Permalink to this headline">¶</a></h1>
<div class="section" id="conversion-to-vhdl">
<h2>Conversion to VHDL<a class="headerlink" href="#conversion-to-vhdl" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rationale">
<h3>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h3>
<p>Since the MyHDL to Verilog conversion has been developed, a path to
implementation from MyHDL is available. Given the widespread support
for Verilog, it could thus be argued that there was no real need for a
convertor to VHDL.</p>
<p>However, it turns out that VHDL is still very much alive and will
remain so for the forseeable future. This is especially true for the
FPGA market, which is especially interesting for MyHDL. It seems much
more dynamic than the ASIC market. Moreover, because of the nature of
FPGA&#8217;s, FPGA designers may be more willing to try out new ideas.</p>
<p>To convince designers to use a new tool, it should integrate with
their current design flow. That is why the MyHDL to VHDL convertor is
needed. It should lower the threshold for VHDL designers to start
using MyHDL.</p>
</div>
<div class="section" id="advantages">
<h3>Advantages<a class="headerlink" href="#advantages" title="Permalink to this headline">¶</a></h3>
<p>MyHDL to VHDL conversion offers the following advantages:</p>
<dl class="docutils">
<dt>MyHDL integration in a VHDL-based design flow</dt>
<dd>Designers can start using MyHDL and benefit from its power and
flexibility, within the context of their proven design flow.</dd>
<dt>The convertor automates a number of hard tasks</dt>
<dd>The convertor automates a number of tasks that are hard to do in
VHDL directly. For example, when mixing <tt class="docutils literal"><span class="pre">unsigned</span></tt> and <tt class="docutils literal"><span class="pre">signed</span></tt>
types it can be difficult to describe the desired behavior
correctly.  In contrast, a MyHDL designer can use the high-level
<tt class="docutils literal"><span class="pre">intbv</span></tt> type, and let the convertor deal with type
conversions and resizings.</dd>
<dt>MyHDL as an IP development platform</dt>
<dd>The possibility to convert the same MyHDL source to equivalent
Verilog and VHDL creates a novel application: using MyHDL as an IP
development platform. IP developers can serve customers for both
target languages from a single MyHDL code base. Moreover, MyHDL&#8217;s
flexibility and parametrizability make it ideally suited to this
application.</dd>
</dl>
</div>
<div class="section" id="solution-description">
<h3>Solution description<a class="headerlink" href="#solution-description" title="Permalink to this headline">¶</a></h3>
<div class="section" id="approach">
<h4>Approach<a class="headerlink" href="#approach" title="Permalink to this headline">¶</a></h4>
<p>The approach followed to convert MyHDL code to VHDL is identical to
the one followed for conversion to Verilog in previous MyHDL releases.</p>
<p>In particular, the MyHDL code analyzer in the convertor is identical
for both target languages. The goal is that all MyHDL code that can be
converted to Verilog can be converted to VHDL also, and
vice versa. This has been achieved except for a few minor issues due
to limitations of the target languages.</p>
</div>
<div class="section" id="user-interface">
<h4>User interface<a class="headerlink" href="#user-interface" title="Permalink to this headline">¶</a></h4>
<p>Conversion to VHDL is implemented by the following function in the <tt class="docutils literal"><span class="pre">myhdl</span></tt> package:</p>
<dl class="function">
<dt>
<tt class="descname">toVHDL</tt><big>(</big><em>func[, *args][, **kwargs]</em><big>)</big></dt>
<dd><p>Converts a MyHDL design instance to equivalent VHDL
code. <em>func</em> is a function that returns an instance. <a class="reference internal" href="../manual/reference.html#myhdl.toVHDL" title="myhdl.toVHDL"><tt class="xref py py-func docutils literal"><span class="pre">toVHDL()</span></tt></a>
calls <em>func</em> under its control and passes <em>*args</em> and
<em>**kwargs</em> to the call.</p>
<p>The return value is the same as the one returned by the call
<tt class="docutils literal"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></tt>. It can be assigned to an instance name.
The top-level instance name and the basename of the Verilog
output filename is <tt class="docutils literal"><span class="pre">func.func_name</span></tt> by default.</p>
</dd></dl>

<p><a class="reference internal" href="../manual/reference.html#myhdl.toVHDL" title="myhdl.toVHDL"><tt class="xref py py-func docutils literal"><span class="pre">toVHDL()</span></tt></a> has the following attributes:</p>
<dl class="attribute">
<dt id="myhdl.toVHDL.name">
<tt class="descclassname">toVHDL.</tt><tt class="descname">name</tt><a class="headerlink" href="#myhdl.toVHDL.name" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute is used to overwrite the default top-level
instance name and the basename of the VHDL output.</p>
</dd></dl>

<dl class="attribute">
<dt id="myhdl.toVHDL.component_declarations">
<tt class="descclassname">toVHDL.</tt><tt class="descname">component_declarations</tt><a class="headerlink" href="#myhdl.toVHDL.component_declarations" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute can be used to add component declarations to the
VHDL output. When a string is assigned to it, it will be copied
to the appropriate place in the output file.</p>
</dd></dl>

</div>
<div class="section" id="type-mapping">
<h4>Type mapping<a class="headerlink" href="#type-mapping" title="Permalink to this headline">¶</a></h4>
<p>In contrast to Verilog, VHDL is a strongly typed language. The
convertor has to carefully perform type inferencing, and handle type
conversions and resizings appropriately. To do this right, a
well-chosen mapping from MyHDL types to VHDL types is crucial.</p>
<p>MyHDL types are mapped to VHDL types according to the following table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="39%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">MyHDL type</th>
<th class="head">VHDL type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">int</span></tt></td>
<td><tt class="docutils literal"><span class="pre">integer</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">bool</span></tt></td>
<td><tt class="docutils literal"><span class="pre">std_logic</span></tt></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">intbv</span></tt> with <tt class="docutils literal"><span class="pre">min</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">unsigned</span></tt></td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">intbv</span></tt> with  <tt class="docutils literal"><span class="pre">min</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">signed</span></tt></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">enum</span></tt></td>
<td>dedicated enumeration type</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">tuple</span></tt> of <tt class="docutils literal"><span class="pre">int</span></tt></td>
<td>mapped to case statement</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">list</span></tt> of <tt class="docutils literal"><span class="pre">bool</span></tt></td>
<td><tt class="docutils literal"><span class="pre">array</span> <span class="pre">of</span> <span class="pre">std_logic</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">list</span></tt> of <tt class="docutils literal"><span class="pre">intbv</span></tt> with <tt class="docutils literal"><span class="pre">min</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">array</span> <span class="pre">of</span> <span class="pre">unsigned</span></tt></td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">list</span></tt> of <tt class="docutils literal"><span class="pre">intbv</span></tt> with <tt class="docutils literal"><span class="pre">min</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">array</span> <span class="pre">of</span> <span class="pre">signed</span></tt></td>
<td>(4)</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic simple">
<li>The VHDL <tt class="docutils literal"><span class="pre">std_logic</span></tt> type is defined in the standard VHDL package
<tt class="docutils literal"><span class="pre">IEEE.std_logic_1164</span></tt>.</li>
<li>The VHDL <tt class="docutils literal"><span class="pre">unsigned</span></tt> and <tt class="docutils literal"><span class="pre">signed</span></tt> types used are those from the
standard VHDL packages <tt class="docutils literal"><span class="pre">IEEE.numeric_std</span></tt>.</li>
<li>A MyHDL <tt class="docutils literal"><span class="pre">tuple</span></tt> of <tt class="docutils literal"><span class="pre">int</span></tt> is used for ROM inference, and can only be
used in a very specific way: an indexing operation into the tuple
should be the rhs of an assignment.</li>
<li>All list members should have identical value constraints.</li>
</ol>
<p>The table as presented applies to MyHDL variables. They are mapped to
VHDL variables (except for the case of a <tt class="docutils literal"><span class="pre">tuple</span></tt> of <tt class="docutils literal"><span class="pre">int</span></tt>).</p>
<p>The convertor also supports MyHDL signals that use <tt class="docutils literal"><span class="pre">bool</span></tt>,
<tt class="docutils literal"><span class="pre">intbv</span></tt> or <tt class="docutils literal"><span class="pre">enum</span></tt> objects as their underlying type. These are mapped to
VHDL signals with a type as specified in the table above.</p>
<p>The convertor supports MyHDL list of signals provided the underlying
signal type is either <tt class="docutils literal"><span class="pre">bool</span></tt> or <tt class="docutils literal"><span class="pre">intbv</span></tt>. They may be mapped to a VHDL
signal with a VHDL type as specified in the table.
However, list of signals are not always mapped to a corresponding VHDL
signal. See <a class="reference internal" href="#new06-listofsigs"><em>Conversion of lists of signals</em></a> for more info.</p>
</div>
<div class="section" id="template-transformation">
<h4>Template transformation<a class="headerlink" href="#template-transformation" title="Permalink to this headline">¶</a></h4>
<p>There is a difference between VHDL and Verilog in the way in which
sensitivity to signal edges is specified. In Verilog, edge specifiers
can be used directly in the sensitivity list. In VHDL, this is not
possible: only signals can be used in the sensitivity list. To check
for an edge, one uses the <tt class="docutils literal"><span class="pre">rising_edge()</span></tt> or <tt class="docutils literal"><span class="pre">falling_edge()</span></tt>
functions in the code.</p>
<p>MyHDL follows the Verilog scheme to specify edges in the sensitivity
list. Consequently, when mapping such code to VHDL, it needs to be
transformed to equivalent VHDL. This is an important issue because it
affects all synthesizable templates that infer sequential logic.</p>
<p>We will illustrate this feature with some examples. This is the MyHDL
code for a D flip-flop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
    <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">d</span>
</pre></div>
</div>
<p>It is converted to VHDL as follows:</p>
<div class="highlight-python"><pre>DFF_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        q &lt;= d;
    end if;
end process DFF_LOGIC;</pre>
</div>
<p>The convertor can handle the more general case. For example, this is
MyHDL code for a D flip-flop with asynchronous set, asynchronous
reset, and preference of set over reset:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">,</span> <span class="nb">set</span><span class="o">.</span><span class="n">negedge</span><span class="p">,</span> <span class="n">rst</span><span class="o">.</span><span class="n">negedge</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">set</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">rst</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">d</span>
</pre></div>
</div>
<p>This is converted to VHDL as follows:</p>
<div class="highlight-python"><pre>DFFSR_LOGIC: process (clk, set, rst) is
begin
    if (set = '0') then
        q &lt;= '1';
    elsif (rst = '0') then
        q &lt;= '0';
    elsif rising_edge(clk) then
        q &lt;= d;
    end if;
end process DFFSR_LOGIC;</pre>
</div>
<p>All cases with practical utility can be handled in this way. However,
there are other cases that cannot be transformed to equivalent
VHDL. The convertor will detect those cases and give an error.</p>
</div>
</div>
</div>
<div class="section" id="conversion-of-lists-of-signals">
<span id="new06-listofsigs"></span><h2>Conversion of lists of signals<a class="headerlink" href="#conversion-of-lists-of-signals" title="Permalink to this headline">¶</a></h2>
<p>Lists of signals are useful for many purposes. For example, they make
it easy to create a repetitive structure. Another application is the
description of memory behavior.</p>
<p>The convertor output is non-hierarchical. That implies that all
signals are declared at the top-level in VHDL or Verilog (as VHDL
signals, or Verilog regs and wires.)  However, some signals that are a
list member at some level in the design hierarchy may be used as
a plain signal at a lower level. For such signals, a choice has to be
made whether to declare a Verilog memory or VHDL array, or a number of
plain signal names.</p>
<p>If possible, plain signal declarations are preferred, because Verilog
memories and arrays have some restrictions in usage and tool support.
This is possible if the list syntax is strictly used outside generator
code, for example when lists of signals are used to describe
structure.</p>
<p>Conversely, when list syntax is used in some generator, then a Verilog
memory or VHDL array will be declared. The typical example is the
description of RAM memories.</p>
<p>The convertor in the previous MyHDL release had a severe restriction
on the latter case: it didn&#8217;t allow that, for a certain signal, list
syntax was used in some generator, and plain signal syntax in another.
This restriction, together with its rather obscure error message, has
caused regular user complaints. In this release, this restriction has
been lifted.</p>
</div>
<div class="section" id="conversion-of-test-benches">
<span id="new06-test"></span><h2>Conversion of test benches<a class="headerlink" href="#conversion-of-test-benches" title="Permalink to this headline">¶</a></h2>
<div class="section" id="background">
<h3>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h3>
<p>After conversion, we obviously want to verify that the VHDL or Verilog
code works correctly. In previous MyHDL versions, the proposed
verification technique was co-simulation: use the same MyHDL test
bench to simulate the converted Verilog code and the original MyHDL
code. While co-simulation works well, there are a number of issues
with it:</p>
<ul class="simple">
<li>Co-simulation requires that the HDL simulator has an interface to
its internal workings, such as <tt class="docutils literal"><span class="pre">vpi</span></tt> for Verilog and <tt class="docutils literal"><span class="pre">vhpi</span></tt> for
VHDL.</li>
<li><tt class="docutils literal"><span class="pre">vpi</span></tt> for Verilog is well-established and available for
open-source simulators such as Icarus and cver. However, <tt class="docutils literal"><span class="pre">vhpi</span></tt> for
VHDL is much less established; it is unclear whether there is an open
source solution that is powerful enough for MyHDL&#8217;s purposes.</li>
<li>Even though <tt class="docutils literal"><span class="pre">vpi</span></tt> is a &#8220;standard&#8221;, there are differences between
various simulators. Therefore, some customization is typically required
per Verilog simulator.</li>
<li>MyHDL co-simulation uses unix-style interprocess communication
that doesn&#8217;t work on Windows natively. This is an exception to the
rest of MyHDL that should run on any Python platform.</li>
</ul>
<p>The conclusion is that co-simulation is probably not a viable solution
for the VHDL case, and it has some disadvantages for Verilog as well.</p>
<p>The proposed alternative is to convert the test bench itself, so that
both test bench and design can be run in the HDL simulator. Of course,
this is not a fully general solution either, as there are important
restrictions on the kind of code that can be converted. However, with
the additional features that have been developed, it should be a
useful solution for verifying converted code.</p>
</div>
<div class="section" id="print-statement">
<h3>Print statement<a class="headerlink" href="#print-statement" title="Permalink to this headline">¶</a></h3>
<p>In previous MyHDL versions, <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#print" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> statement conversion to Verilog was
supported in a quick and dirty way, by merely copying the format
string without checks. With the advent of VHDL conversion, this has
now been implemented more rigorously. This was necessary because VHDL
doesn&#8217;t work with format strings. Rather, the format string
specification has to be converted to a sequence of VHDL <tt class="docutils literal"><span class="pre">write</span></tt> and
<tt class="docutils literal"><span class="pre">writeline</span></tt> calls.</p>
<p>A <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#print" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> statement with multiple arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>is supported. However, there are restrictions on the arguments.
First, they should be of one of the following forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">arg</span>
<span class="n">formatstring</span> <span class="o">%</span> <span class="n">arg</span>
<span class="n">formatstring</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">arg</span></tt> is a <tt class="docutils literal"><span class="pre">bool</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">intbv</span></tt>, <tt class="docutils literal"><span class="pre">enum</span></tt>, or a
<tt class="docutils literal"><span class="pre">Signal</span></tt> of these types.</p>
<p>The <tt class="docutils literal"><span class="pre">formatstring</span></tt> contains ordinary characters and conversion
specifiers as in Python. However, the only supported conversion specifiers
are <tt class="docutils literal"><span class="pre">%s</span></tt> and <tt class="docutils literal"><span class="pre">%d</span></tt>.
Justification and width specification are thus not supported.</p>
<p>Printing without a newline:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">arg1</span> <span class="p">,</span>
</pre></div>
</div>
<p>is not supported. This is because the solution is based on
<tt class="docutils literal"><span class="pre">std.textio</span></tt>. In VHDL <tt class="docutils literal"><span class="pre">std.textio</span></tt>, subsequent <tt class="docutils literal"><span class="pre">write()</span></tt> calls to
a line are only printed upon a <tt class="docutils literal"><span class="pre">writeline()</span></tt> call. As a
normal <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#print" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> implies a newline, the correct behavior can be
guaranteed, but for a <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#print" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> without newline this is not
possible. In the future, other techniques may be used and this
restriction may be lifted.</p>
</div>
<div class="section" id="assert-statement">
<h3>Assert statement<a class="headerlink" href="#assert-statement" title="Permalink to this headline">¶</a></h3>
<p>An <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#assert" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">assert</span></tt></a> statement in Python looks as follow:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">assert</span> <span class="n">test_expression</span>
</pre></div>
</div>
<p>It can be converted provided <tt class="docutils literal"><span class="pre">test_expression</span></tt> is convertible.</p>
</div>
<div class="section" id="delay-objects">
<h3>Delay objects<a class="headerlink" href="#delay-objects" title="Permalink to this headline">¶</a></h3>
<p>Delay objects are constructed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">delay</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>with <tt class="docutils literal"><span class="pre">t</span></tt> an integer. They are used in <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#yield" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">yield</span></tt></a> statements and
as the argument of <a class="reference internal" href="../manual/reference.html#myhdl.always" title="myhdl.always"><tt class="xref py py-func docutils literal"><span class="pre">always()</span></tt></a> decorators, to specify delays.
They can now be converted.</p>
</div>
<div class="section" id="methodology-notes">
<h3>Methodology notes<a class="headerlink" href="#methodology-notes" title="Permalink to this headline">¶</a></h3>
<p>The question is whether the conversion restrictions permit to develop
sufficiently complex test benches. In this section, we present some
insights about this.</p>
<p>The most important restrictions are the types that can be used. These
remain &#8220;hardware-oriented&#8221; as before.</p>
<p>Even in the previous MyHDL release, the &#8220;convertible subset&#8221; was much
wider than the &#8220;synthesis subset&#8221;. For example, <a class="reference external" href="http://docs.python.org/reference/compound_stmts.html#while" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">while</span></tt></a> and
<a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#raise" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">raise</span></tt></a> statement were already convertible.</p>
<p>The support for <a class="reference internal" href="../manual/reference.html#myhdl.delay" title="myhdl.delay"><tt class="xref py py-func docutils literal"><span class="pre">delay()</span></tt></a> objects is the most important new feature
to write high-level models and test benches.</p>
<p>With the <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#print" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">print</span></tt></a> statement, simple debugging can be done.</p>
<p>Of particular interest is the <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#assert" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">assert</span></tt></a> statement. Originally,
<a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#assert" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">assert</span></tt></a> statements were only intended to insert debugging
assertions in code. Recently, there is a tendency to use them to write
self-checking unit tests, controlled by unit test frameworks such as
<tt class="docutils literal"><span class="pre">py.test</span></tt>. In particular, they are a powerful way to write
self-checking test benches for MyHDL designs. As <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#assert" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">assert</span></tt></a>
statements are now convertible, a whole test suite in MyHDL can be
converted to an equivalent test suite in Verilog and VHDL.</p>
<p>Finally, the same techniques as for synthesizable code can be used
to master complexity. In particular, any code outside generators
is executed during elaboration, and therefore not considered in
the conversion process. This feature can for example be used for
complex calculations that set up constants or expected results.
Furthermore, a tuple of ints can be used to hold a table of
values that will be mapped to a case statement in Verilog and VHDL.</p>
</div>
</div>
<div class="section" id="conversion-output-verification">
<h2>Conversion output verification<a class="headerlink" href="#conversion-output-verification" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This functionality is not needed in a typical
design flow. It is only relevant to debug the
MyHDL convertor itself.</p>
</div>
<div class="section" id="id1">
<h3>Approach<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>To verify the convertor output, a methodology has been developed and
implemented that doesn&#8217;t rely on co-simulation and works for both
Verilog and VHDL.</p>
<p>The solution builds on the features explained in section <a class="reference internal" href="#new06-test"><em>Conversion of test benches</em></a>.
The idea is basically to convert the test bench as well as the
functional code. In particular, <tt class="docutils literal"><span class="pre">print</span></tt> statements in MyHDL are
converted to equivalent statements in the HDL. The verification
process consists of running both the MyHDL and the HDL simulation,
comparing the simulation output, and reporting any differences.</p>
<p>The goal is to make the verification process as easy as possible. The
use of <tt class="docutils literal"><span class="pre">print</span></tt> statements to debug a design is a very common and
simple technique. The verification process itself is implemented in a
single function with an interface that is identical to <tt class="docutils literal"><span class="pre">toVHDL</span></tt> and
<tt class="docutils literal"><span class="pre">toVerilog</span></tt>.</p>
<p>As this is a native Python solution, it runs on any platform on which
the HDL simulator runs. Moreover, any HDL simulator can be used as no
<tt class="docutils literal"><span class="pre">vpi</span></tt> or <tt class="docutils literal"><span class="pre">vhpi</span></tt> capabilities are needed. Of course, per HDL
simulator some customization is required to define the details on how
it is used. This needs to be done once per HDL simulator and is fully
under user control.</p>
</div>
<div class="section" id="verification-interface">
<h3>Verification interface<a class="headerlink" href="#verification-interface" title="Permalink to this headline">¶</a></h3>
<p>All functions related to conversion verification are implemented in
the <tt class="docutils literal"><span class="pre">myhdl.conversion</span></tt> package. (To keep the <tt class="docutils literal"><span class="pre">myhdl</span></tt> namespace
clean, they are not available from the <tt class="docutils literal"><span class="pre">myhdl</span></tt> namespace directly.)</p>
<dl class="function">
<dt id="myhdl.verify">
<tt class="descname">verify</tt><big>(</big><em>func[, *args][, **kwargs]</em><big>)</big><a class="headerlink" href="#myhdl.verify" title="Permalink to this definition">¶</a></dt>
<dd><p>Used like <a class="reference internal" href="../manual/reference.html#myhdl.toVHDL" title="myhdl.toVHDL"><tt class="xref py py-func docutils literal"><span class="pre">toVHDL()</span></tt></a>. It converts MyHDL code,
simulates both the MyHDL code and the HDL code and reports any
differences. The default HDL simulator is GHDL.</p>
</dd></dl>

<dl class="function">
<dt id="myhdl.analyze">
<tt class="descname">analyze</tt><big>(</big><em>func[, *args][, **kwargs]</em><big>)</big><a class="headerlink" href="#myhdl.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Used like <a class="reference internal" href="../manual/reference.html#myhdl.toVHDL" title="myhdl.toVHDL"><tt class="xref py py-func docutils literal"><span class="pre">toVHDL()</span></tt></a>. It converts MyHDL code, and analyzes the
resulting HDL.
Used to verify whether the HDL output is syntactically correct.</p>
</dd></dl>

<p>The two previous functions have the following attribute:</p>
<dl class="attribute">
<dt id="myhdl.analyze.simulator">
<tt class="descclassname">analyze.</tt><tt class="descname">simulator</tt><a class="headerlink" href="#myhdl.analyze.simulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to set the name of the HDL analyzer. GHDL
is the default.</p>
</dd></dl>

<dl class="attribute">
<dt id="myhdl.verify.simulator">
<tt class="descclassname">verify.</tt><tt class="descname">simulator</tt><a class="headerlink" href="#myhdl.verify.simulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to set the name of the HDL simulator. GHDL
is the default.</p>
</dd></dl>

</div>
<div class="section" id="hdl-simulator-registration">
<h3>HDL simulator registration<a class="headerlink" href="#hdl-simulator-registration" title="Permalink to this headline">¶</a></h3>
<p>To be able to use a HDL simulator to verify conversions, it needs to
be registered first. This is needed once per simulator (or rather, per
set of analysis and simulation commands). Registering is done with the
following function:</p>
<dl class="function">
<dt id="myhdl.registerSimulator">
<tt class="descname">registerSimulator</tt><big>(</big><em>name=None</em>, <em>hdl=None</em>, <em>analyze=None</em>, <em>elaborate=None</em>, <em>simulate=None</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#myhdl.registerSimulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a particular HDL simulator to be used by  <a class="reference internal" href="#myhdl.verify" title="myhdl.verify"><tt class="xref py py-func docutils literal"><span class="pre">verify()</span></tt></a>
and <a class="reference internal" href="#myhdl.analyze" title="myhdl.analyze"><tt class="xref py py-func docutils literal"><span class="pre">analyze()</span></tt></a>. <em>name</em> is the name of the simulator.
<em>hdl</em> specifies the HDL: <tt class="docutils literal"><span class="pre">&quot;VHDL&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;Verilog&quot;</span></tt>.
<em>analyze</em> is a command string to analyze the HDL source code.
<em>elaborate</em> is a command string to elaborate the HDL
code. This command is optional.
<em>simulate</em> is a command string to simulate the HDL code.
<em>offset</em> is an integer specifying the number of initial lines to be ignored
from the HDL simulator output.</p>
<p>The command strings should be string templates that refer to the
<tt class="docutils literal"><span class="pre">topname</span></tt> variable that specifies the design name. The templates
can also use the <tt class="docutils literal"><span class="pre">unitname</span></tt> variable which is the lower case
version of <tt class="docutils literal"><span class="pre">topname</span></tt>.
The command strings can assume that a subdirectory called
<tt class="docutils literal"><span class="pre">work</span></tt> is available in the current working directory. Analysis and
elaboration results can be put there if desired.</p>
<p>The <a class="reference internal" href="#myhdl.analyze" title="myhdl.analyze"><tt class="xref py py-func docutils literal"><span class="pre">analyze()</span></tt></a> function runs the <em>analyze</em> command.
The <a class="reference internal" href="#myhdl.verify" title="myhdl.verify"><tt class="xref py py-func docutils literal"><span class="pre">verify()</span></tt></a> function runs the <em>analyze</em> command, then the
<em>elaborate</em> command if any, and then the <em>simulate</em> command.</p>
<p>The GHDL simulator is registered by default, but its
registration can be overwritten if required.</p>
</dd></dl>

<div class="section" id="example-preregistered-hdl-simulators">
<h4>Example: preregistered HDL simulators<a class="headerlink" href="#example-preregistered-hdl-simulators" title="Permalink to this headline">¶</a></h4>
<p>A number of open-source HDL simulators are preregistered in the
MyHDL distribution. If they are installed in the typical way, they
are readily available for conversion verification.
We will illustrate the registration process by showing the
registrations of these simulators.</p>
<p>GHDL registration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">registerSimulator</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;GHDL&quot;</span><span class="p">,</span>
    <span class="n">hdl</span><span class="o">=</span><span class="s">&quot;VHDL&quot;</span><span class="p">,</span>
    <span class="n">analyze</span><span class="o">=</span><span class="s">&quot;ghdl -a --workdir=work pck_myhdl_</span><span class="si">%(version)s</span><span class="s">.vhd </span><span class="si">%(topname)s</span><span class="s">.vhd&quot;</span><span class="p">,</span>
    <span class="n">elaborate</span><span class="o">=</span><span class="s">&quot;ghdl -e --workdir=work -o </span><span class="si">%(unitname)s</span><span class="s">_ghdl </span><span class="si">%(topname)s</span><span class="s">&quot;</span><span class="p">,</span>
    <span class="n">simulate</span><span class="o">=</span><span class="s">&quot;ghdl -r </span><span class="si">%(unitname)s</span><span class="s">_ghdl&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Icarus registration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">registerSimulator</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;icarus&quot;</span><span class="p">,</span>
    <span class="n">hdl</span><span class="o">=</span><span class="s">&quot;Verilog&quot;</span><span class="p">,</span>
    <span class="n">analyze</span><span class="o">=</span><span class="s">&quot;iverilog -o </span><span class="si">%(topname)s</span><span class="s">.o </span><span class="si">%(topname)s</span><span class="s">.v&quot;</span><span class="p">,</span>
    <span class="n">simulate</span><span class="o">=</span><span class="s">&quot;vvp </span><span class="si">%(topname)s</span><span class="s">.o&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>cver registration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">registerSimulator</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">&quot;cver&quot;</span><span class="p">,</span>
    <span class="n">hdl</span><span class="o">=</span><span class="s">&quot;Verilog&quot;</span><span class="p">,</span>
    <span class="n">analyze</span><span class="o">=</span><span class="s">&quot;cver -c -q </span><span class="si">%(topname)s</span><span class="s">.v&quot;</span><span class="p">,</span>
    <span class="n">simulate</span><span class="o">=</span><span class="s">&quot;cver -q </span><span class="si">%(topname)s</span><span class="s">.v&quot;</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">3</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="new-modeling-features">
<h2>New modeling features<a class="headerlink" href="#new-modeling-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="new-signed-method-for-intbv">
<h3>New signed() method for intbv<a class="headerlink" href="#new-signed-method-for-intbv" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><tt class="xref py py-class docutils literal"><span class="pre">intbv</span></tt></a> object has a new method <tt class="xref py py-meth docutils literal"><span class="pre">signed()</span></tt> that
implements sign extension. The extended bit is the msb bit of
the bit representation of the object.</p>
<p>Clearly, this method only has an effect for <a class="reference internal" href="../manual/reference.html#myhdl.intbv" title="myhdl.intbv"><tt class="xref py py-class docutils literal"><span class="pre">intbv</span></tt></a> objects
whose valid values are a finite range of positive integers.</p>
<p>This method can be converted to VHDL and Verilog.</p>
</div>
<div class="section" id="always-comb-and-list-of-signals">
<h3>always_comb and list of signals<a class="headerlink" href="#always-comb-and-list-of-signals" title="Permalink to this headline">¶</a></h3>
<p>In the previous MyHDL release, one could use lists of signals
in an <a class="reference internal" href="../manual/reference.html#myhdl.always_comb" title="myhdl.always_comb"><tt class="xref py py-func docutils literal"><span class="pre">always_comb()</span></tt></a> block, but they were not considered to infer
the sensitivity list. To several users, this was unexpected
behavior, or even a bug.</p>
<p>In the present release, lists of signals are considered and
the corresponding signals are added to the sensitivity list.
The convertor to Verilog and VHDL is adapted accordingly.</p>
</div>
</div>
<div class="section" id="backwards-incompatible-changes">
<h2>Backwards incompatible changes<a class="headerlink" href="#backwards-incompatible-changes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="decorator-usage">
<span id="new06-deco"></span><h3>Decorator usage<a class="headerlink" href="#decorator-usage" title="Permalink to this headline">¶</a></h3>
<p>The basic building block of a MyHDL design is a specialized Python
generator.</p>
<p>In MyHDL 0.5, decorators were introduced to make it easier to create
useful MyHDL generators. Moreover, they make the code clearer. As a
result, they are now the de facto standard to describe hardware
modules in MyHDL.</p>
<p>The implementation of certain tasks, such a signal tracing and
conversion, can be simplified significantly if decorators are used to
create the generators. These simplifications have now been adopted in
the code. This means that decorator usage is assumed.  Legacy code
written for the mentioned purposes without decorators, can always be
easily converted into code with decorators.</p>
<p>For pure modeling, it doesn&#8217;t matter how generators are created and
this will remain so. Therefore, designers can continue to experiment
with innovative modeling concepts in the fullest generality.</p>
</div>
<div class="section" id="instances-function">
<h3>instances() function<a class="headerlink" href="#instances-function" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../manual/reference.html#myhdl.instances" title="myhdl.instances"><tt class="xref py py-func docutils literal"><span class="pre">instances()</span></tt></a> function can be used to automatically lookup and
return the instances that are defined in a MyHDL module.  In accordance
with the section <a class="reference internal" href="#new06-deco"><em>Decorator usage</em></a>, its functionality has been
changed. Only generators created by decorators are considered when
looking up instances.</p>
</div>
<div class="section" id="conversion-of-printing-without-a-newline">
<h3>Conversion of printing without a newline<a class="headerlink" href="#conversion-of-printing-without-a-newline" title="Permalink to this headline">¶</a></h3>
<p>Printing without a newline (a print statement followed by a comma) is
no longer supported by the convertor to Verilog. This is done to be
compatible with the convertor to VHDL. Currently, the VHDL solution
relies on <tt class="docutils literal"><span class="pre">std.textio</span></tt> and this implies that printing without a
newline cannot be reliably converted.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="0.7.html" title="What’s new in MyHDL 0.7"
             >previous</a> |</li>
        <li><a href="../index.html">MyHDL 0.8 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Jan Decaluwe.
      Last updated on Apr 08, 2014.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>