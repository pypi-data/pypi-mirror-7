bobo main (default) application factory
=======================================

The bobo.main module provides a Paste Deployment application factory
that published module globals that have bobo_response methods. We
call these objects resources.

By default, the main application generated by the factory scans the
given modules for resources.  Let's create some resources in some test modules:

    >>> import bobo, webob, sys
    >>> class Resource:
    ...     def __init__(self, path):
    ...         self.path = path
    ...         self.bobo_order = bobo.order()
    ...     def bobo_response(self, request, path, method):
    ...         print('trying %s' % self.path)
    ...         if path == self.path:
    ...             return self(request)
    ...     def __call__(self, request, where='here'):
    ...         return webob.Response("%s %s!" % (self.path, where))
    ...     def bobo_reroute(self, route):
    ...         return Resource(route)


    >>> import bobo.testmodule1, bobo.testmodule2

    >>> for i in range(5):
    ...     setattr(bobo.testmodule1, 'v%sx' % i, Resource('/mod1/v%s' % i))
    ...     setattr(bobo.testmodule2, 'v%sx' % i, Resource('/mod2/v%s' % i))

Now, we'll create an application:

    >>> import webtest, sys
    >>> stdout = sys.stdout
    >>> def makeapp(*args, **kw):
    ...     app = bobo.Application(*args, **kw)
    ...     def work_around_webtest_duping_stdout(*appargs):
    ...         sys.stdout = stdout
    ...         return app(*appargs)
    ...     return webtest.TestApp(work_around_webtest_duping_stdout)

    >>> app = makeapp(bobo_resources='bobo.testmodule1\nbobo.testmodule2')

We can make requests of the application for our test paths:

    >>> print(app.get('/mod1/v0', status=200).text)
    trying /mod1/v0
    /mod1/v0 here!

    >>> print(app.get('/mod2/v3', status=200).text)
    trying /mod1/v0
    trying /mod1/v1
    trying /mod1/v2
    trying /mod1/v3
    trying /mod1/v4
    trying /mod2/v0
    trying /mod2/v1
    trying /mod2/v2
    trying /mod2/v3
    /mod2/v3 here!

If make requests for a path we don't have a resource for, we'll get a
non-found response:

    >>> print(app.get('/mod2', status=404).text)
    trying /mod1/v0
    trying /mod1/v1
    trying /mod1/v2
    trying /mod1/v3
    trying /mod1/v4
    trying /mod2/v0
    trying /mod2/v1
    trying /mod2/v2
    trying /mod2/v3
    trying /mod2/v4
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /mod2</body>
    </html>
    <BLANKLINE>

Route configuration
-------------------

Routes can be defined as part of the configuration:

    >>> app = makeapp(bobo_resources="""
    ...     /foo/bar -> bobo.testmodule1:v2x
    ...     /:where/x ->
    ...          bobo.testmodule1:v3x
    ...     """)

Now, with the new app, the old routes don't work, but the new ones do:

    >>> print(app.get('/mod2/v3', status=404).text)
    trying /foo/bar
    trying /:where/x
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /mod2/v3</body>
    </html>
    <BLANKLINE>

    >>> print(app.get('/foo/bar', status=200).text)
    trying /foo/bar
    /foo/bar here!

    >>> print(app.get('/there/x', status=404).text)
    trying /foo/bar
    trying /:where/x
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /there/x</body>
    </html>
    <BLANKLINE>

Note that in the last example, we didn't find the resource because our
test resource doesn't interpret route placeholders.

We can have resources that implement subroutes.  That is, they are
called to produce resources.

    >>> class SubRoute:
    ...     def __init__(self, request, **route_info):
    ...         self.route_info = route_info
    ...
    ...     def bobo_response(self, request, path, method):
    ...         if path == '/x/y/z':
    ...             return self(request)
    ...
    ...     def __call__(self, request):
    ...         return webob.Response(str(self.route_info))

    >>> bobo.testmodule2.SubRoute = SubRoute

    >>> app = makeapp(bobo_resources="""
    ...     /:where ->
    ...          bobo.testmodule2:SubRoute
    ...     """)

    >>> print(app.get('/there/x', status=404).text)
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /there/x</body>
    </html>
    <BLANKLINE>

    >>> print(app.get('/there/x/y/z', status=200).text)
    {'where': 'there'}

Note classes that define bobo_response instance methods aren't
found via module scanning:

    >>> app = makeapp(bobo_resources='bobo.testmodule2')
    >>> print(app.get('/xxx', status=404).text)
    trying /mod2/v0
    trying /mod2/v1
    trying /mod2/v2
    trying /mod2/v3
    trying /mod2/v4
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /xxx</body>
    </html>
    <BLANKLINE>

If the class had been found, calling it's unbound bobo_response
method would have caused an error. OTOH, classes with bobo_response
class methods will be found:

    >>> class C:
    ...     @classmethod
    ...     def bobo_response(self, request, path, method):
    ...         print('trying C')

    >>> bobo.testmodule2.C = C
    >>> app = makeapp(bobo_resources='bobo.testmodule2')
    >>> print(app.get('/xxx', status=404).text)
    trying /mod2/v0
    trying /mod2/v1
    trying /mod2/v2
    trying /mod2/v3
    trying /mod2/v4
    trying C
    <html>
    <head><title>Not Found</title></head>
    <body>Could not find: /xxx</body>
    </html>
    <BLANKLINE>

Configuration handlers
----------------------

    >>> import pprint
    >>> def config_handler(d):
    ...     print('handler1')
    ...     pprint.pprint(d, width=1)

    >>> bobo.testmodule1.config_handler = config_handler

    >>> import pprint
    >>> def config_handler(d):
    ...     print('handler2')
    ...     pprint.pprint(d, width=1)

    >>> bobo.testmodule2.config_handler = config_handler

    >>> app = makeapp(
    ...     dict(x=1, y=2),
    ...     bobo_resources='bobo.testmodule1',
    ...     bobo_configure=
    ...      'bobo.testmodule2:config_handler bobo.testmodule2:config_handler',
    ...     x=3) # doctest: +NORMALIZE_WHITESPACE
    handler2
    {'bobo_configure':
     'bobo.testmodule2:config_handler bobo.testmodule2:config_handler',
     'bobo_resources': 'bobo.testmodule1',
     'x': 3,
     'y': 2}
    handler2
    {'bobo_configure':
     'bobo.testmodule2:config_handler bobo.testmodule2:config_handler',
     'bobo_resources': 'bobo.testmodule1',
     'x': 3,
     'y': 2}

Scanning modules
----------------

When scanning a module, resources with the same routs are combined.

    >>> bobo.testmodule1.__dict__.clear()

    >>> @bobo.resource('/:y', 'GET')
    ... def gety(request, y):
    ...     return "B.gety %s %s" % (request.method, y)
    >>> @bobo.resource('', 'GET')
    ... def get(request):
    ...     return "B.get %s" % (request.method)
    >>> @bobo.resource('/:y', 'POST')
    ... def posty(request, y):
    ...     return "C.posty %s %s" % (request.method, y)
    >>> @bobo.resource('', 'POST')
    ... def post(request):
    ...     return "C.post %s" % (request.method)

    >>> bobo.testmodule1.get = get
    >>> bobo.testmodule1.gety = gety
    >>> bobo.testmodule1.post = post
    >>> bobo.testmodule1.posty = posty

    >>> app = makeapp(bobo_resources='bobo.testmodule1')

    >>> print(app.get('', status=200).text)
    B.get GET

    >>> print(app.post('', '', status=200).text)
    C.post POST

    >>> print(app.get('', extra_environ=dict(REQUEST_METHOD='HEAD'),
    ...               status=405))
    Response: 405 Method Not Allowed
    Allow: GET, POST
    Content-Type: text/html; charset=UTF-8
    <BLANKLINE>

    >>> print(app.get('/a', status=200).text)
    B.gety GET a

    >>> print(app.post('/a', '', status=200).text)
    C.posty POST a

    >>> print(app.delete('/a', status=405))
    Response: 405 Method Not Allowed
    Allow: GET, POST
    Content-Type: text/html; charset=UTF-8
    <html>
    <head><title>Method Not Allowed</title></head>
    <body>Invalid request method: DELETE</body>
    </html>


redirect
--------

    >>> response = bobo.redirect('http://www.python.org/')
    >>> response # doctest: +ELLIPSIS
    <Response at ... 302 Found>

    >>> print(str(response).lower())
    302 found
    location: http://www.python.org/
    content-type: text/html; charset=utf-8
    content-length: 26
    <BLANKLINE>
    see http://www.python.org/

    >>> response = bobo.redirect('http://www.python.org/', 301)
    >>> response # doctest: +ELLIPSIS
    <Response at ... 301 Moved Permanently>

Ordering
--------

    >>> l1 = bobo.late()
    >>> l2 = bobo.late()
    >>> o1 = bobo.order()
    >>> o2 = bobo.order()
    >>> e1 = bobo.early()
    >>> e2 = bobo.early()
    >>> e1 < e2 < o1 < o2 < l1 < l2
    True

    >>> bobo.testmodule1.__dict__.clear()

    >>> @bobo.query('/o', order=l1)
    ... def f1():
    ...     return 'f1'
    >>> bobo.testmodule1.f1 = f1

    >>> @bobo.query('/o')
    ... def f2():
    ...     return 'f2'
    >>> bobo.testmodule1.f2 = f2

    >>> app = makeapp(bobo_resources='bobo.testmodule1')
    >>> app.get('/o').text
    'f2'

    >>> @bobo.query('/o', order=bobo.early())
    ... def f3():
    ...     return 'f3'
    >>> bobo.testmodule1.f3 = f3

    >>> app = makeapp(bobo_resources='bobo.testmodule1')
    >>> app.get('/o').text
    'f3'
