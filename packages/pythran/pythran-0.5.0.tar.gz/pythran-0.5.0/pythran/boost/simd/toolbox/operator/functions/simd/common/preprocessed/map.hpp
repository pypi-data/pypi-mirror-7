namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , generic_< unspecified_<A0> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0> struct result<This(_Func, _A0)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef typename meta:: vector_of< rtype, meta::cardinal_of<A0>::value >::type type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(extract(a0, i)), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(extract(a0, i)); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 ) >::type operator()(Func const& f, _A0 & a0) { return result< implement( Func const& , _A0 & a0 ) >::impl_::call(f, a0); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1> struct result<This(_Func, _A0 , _A1)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef typename meta:: vector_of< rtype, meta::cardinal_of<A0>::value >::type type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(extract(a0, i) , extract(a1, i)), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(extract(a0, i) , extract(a1, i)); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 ) >::impl_::call(f, a0 , a1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , generic_< unspecified_<A2> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2> struct result<This(_Func, _A0 , _A1 , _A2)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef typename meta:: vector_of< rtype, meta::cardinal_of<A0>::value >::type type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 , typename dispatch::meta::as_ref<_A2>::type a2 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(extract(a0, i) , extract(a1, i) , extract(a2, i)), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 , typename dispatch::meta::as_ref<_A2>::type a2 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(extract(a0, i) , extract(a1, i) , extract(a2, i)); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1 , class _A2> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 ) >::impl_::call(f, a0 , a1 , a2); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , generic_< unspecified_<A2> > const , generic_< unspecified_<A3> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2 , class _A3> struct result<This(_Func, _A0 , _A1 , _A2 , _A3)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type , typename meta::scalar_of<_A3>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef typename meta:: vector_of< rtype, meta::cardinal_of<A0>::value >::type type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 , typename dispatch::meta::as_ref<_A2>::type a2 , typename dispatch::meta::as_ref<_A3>::type a3 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(extract(a0, i) , extract(a1, i) , extract(a2, i) , extract(a3, i)), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 , typename dispatch::meta::as_ref<_A2>::type a2 , typename dispatch::meta::as_ref<_A3>::type a3 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(extract(a0, i) , extract(a1, i) , extract(a2, i) , extract(a3, i)); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1 , class _A2 , class _A3> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 ) >::impl_::call(f, a0 , a1 , a2 , a3); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , generic_< unspecified_<A2> > const , generic_< unspecified_<A3> > const , generic_< unspecified_<A4> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2 , class _A3 , class _A4> struct result<This(_Func, _A0 , _A1 , _A2 , _A3 , _A4)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type , typename meta::scalar_of<_A3>::type , typename meta::scalar_of<_A4>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef typename meta:: vector_of< rtype, meta::cardinal_of<A0>::value >::type type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 , typename dispatch::meta::as_ref<_A2>::type a2 , typename dispatch::meta::as_ref<_A3>::type a3 , typename dispatch::meta::as_ref<_A4>::type a4 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(extract(a0, i) , extract(a1, i) , extract(a2, i) , extract(a3, i) , extract(a4, i)), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 , typename dispatch::meta::as_ref<_A2>::type a2 , typename dispatch::meta::as_ref<_A3>::type a3 , typename dispatch::meta::as_ref<_A4>::type a4 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(extract(a0, i) , extract(a1, i) , extract(a2, i) , extract(a3, i) , extract(a4, i)); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 ) >::impl_::call(f, a0 , a1 , a2 , a3 , a4); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > , generic_< unspecified_<A5> > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , generic_< unspecified_<A2> > const , generic_< unspecified_<A3> > const , generic_< unspecified_<A4> > const , generic_< unspecified_<A5> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > , generic_< unspecified_<A5> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > , generic_< unspecified_<A5> > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> struct result<This(_Func, _A0 , _A1 , _A2 , _A3 , _A4 , _A5)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type , typename meta::scalar_of<_A3>::type , typename meta::scalar_of<_A4>::type , typename meta::scalar_of<_A5>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef typename meta:: vector_of< rtype, meta::cardinal_of<A0>::value >::type type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 , typename dispatch::meta::as_ref<_A2>::type a2 , typename dispatch::meta::as_ref<_A3>::type a3 , typename dispatch::meta::as_ref<_A4>::type a4 , typename dispatch::meta::as_ref<_A5>::type a5 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(extract(a0, i) , extract(a1, i) , extract(a2, i) , extract(a3, i) , extract(a4, i) , extract(a5, i)), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , typename dispatch::meta::as_ref<_A0>::type a0 , typename dispatch::meta::as_ref<_A1>::type a1 , typename dispatch::meta::as_ref<_A2>::type a2 , typename dispatch::meta::as_ref<_A3>::type a3 , typename dispatch::meta::as_ref<_A4>::type a4 , typename dispatch::meta::as_ref<_A5>::type a5 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(extract(a0, i) , extract(a1, i) , extract(a2, i) , extract(a3, i) , extract(a4, i) , extract(a5, i)); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5 ) >::impl_::call(f, a0 , a1 , a2 , a3 , a4 , a5); } }; } } }
