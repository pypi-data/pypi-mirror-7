////////////////////////////////////////////////////////////////////////////////
// Register all tag and extension agnostic call for common code sharing
////////////////////////////////////////////////////////////////////////////////
namespace boost { namespace simd { namespace ext
{
  } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 > BOOST_FORCEINLINE typename boost::enable_if< mpl::not_< any <  mpl::or_< boost::proto::is_expr<mpl::_>, boost::dispatch::meta::is_proxy<mpl::_> > , A0 > > , :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> ) , tag::formal_ > >::type dispatching( elementwise_<Tag> , tag::formal_ , unspecified_<A0> const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> ) , tag::formal_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 > BOOST_FORCEINLINE typename boost::enable_if< mpl::not_< any <  mpl::or_< boost::proto::is_expr<mpl::_>, boost::dispatch::meta::is_proxy<mpl::_> > , A0 , A1 > > , :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> ) , tag::formal_ > >::type dispatching( elementwise_<Tag> , tag::formal_ , unspecified_<A0> const , unspecified_<A1> const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> ) , tag::formal_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 , class A2 > BOOST_FORCEINLINE typename boost::enable_if< mpl::not_< any <  mpl::or_< boost::proto::is_expr<mpl::_>, boost::dispatch::meta::is_proxy<mpl::_> > , A0 , A1 , A2 > > , :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> ) , tag::formal_ > >::type dispatching( elementwise_<Tag> , tag::formal_ , unspecified_<A0> const , unspecified_<A1> const , unspecified_<A2> const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> ) , tag::formal_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 , class A2 , class A3 > BOOST_FORCEINLINE typename boost::enable_if< mpl::not_< any <  mpl::or_< boost::proto::is_expr<mpl::_>, boost::dispatch::meta::is_proxy<mpl::_> > , A0 , A1 , A2 , A3 > > , :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> , unspecified_<A3> ) , tag::formal_ > >::type dispatching( elementwise_<Tag> , tag::formal_ , unspecified_<A0> const , unspecified_<A1> const , unspecified_<A2> const , unspecified_<A3> const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> , unspecified_<A3> ) , tag::formal_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 , class A2 , class A3 , class A4 > BOOST_FORCEINLINE typename boost::enable_if< mpl::not_< any <  mpl::or_< boost::proto::is_expr<mpl::_>, boost::dispatch::meta::is_proxy<mpl::_> > , A0 , A1 , A2 , A3 , A4 > > , :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> , unspecified_<A3> , unspecified_<A4> ) , tag::formal_ > >::type dispatching( elementwise_<Tag> , tag::formal_ , unspecified_<A0> const , unspecified_<A1> const , unspecified_<A2> const , unspecified_<A3> const , unspecified_<A4> const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> , unspecified_<A3> , unspecified_<A4> ) , tag::formal_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > BOOST_FORCEINLINE typename boost::enable_if< mpl::not_< any <  mpl::or_< boost::proto::is_expr<mpl::_>, boost::dispatch::meta::is_proxy<mpl::_> > , A0 , A1 , A2 , A3 , A4 , A5 > > , :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> , unspecified_<A3> , unspecified_<A4> , unspecified_<A5> ) , tag::formal_ > >::type dispatching( elementwise_<Tag> , tag::formal_ , unspecified_<A0> const , unspecified_<A1> const , unspecified_<A2> const , unspecified_<A3> const , unspecified_<A4> const , unspecified_<A5> const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> , unspecified_<A3> , unspecified_<A4> , unspecified_<A5> ) , tag::formal_ >(); } } } } namespace boost { namespace simd { namespace ext {
} } }
////////////////////////////////////////////////////////////////////////////////
// Generate all the common map calls over Tag using boost::simd::map
////////////////////////////////////////////////////////////////////////////////
namespace boost { namespace simd { namespace ext { template<class A0,class Tag, class Dummy> struct implement< elementwise_<Tag>( unspecified_<A0> ) , tag::formal_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0> struct result<This(_A0)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 ) > { }; template<class _A0> typename result<implement(_A0 & a0)>::type operator()(_A0 & a0) const { return boost::simd:: map( dispatch::functor<Tag>(), a0 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1,class Tag, class Dummy> struct implement< elementwise_<Tag>( unspecified_<A0> , unspecified_<A1> ) , tag::formal_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1> struct result<This(_A0 , _A1)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 ) > { }; template<class _A0 , class _A1> typename result<implement(_A0 & a0 , _A1 & a1)>::type operator()(_A0 & a0 , _A1 & a1) const { return boost::simd:: map( dispatch::functor<Tag>(), a0 , a1 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1 , class A2,class Tag, class Dummy> struct implement< elementwise_<Tag>( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> ) , tag::formal_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1 , class _A2> struct result<This(_A0 , _A1 , _A2)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 , _A2 ) > { }; template<class _A0 , class _A1 , class _A2> typename result<implement(_A0 & a0 , _A1 & a1 , _A2 & a2)>::type operator()(_A0 & a0 , _A1 & a1 , _A2 & a2) const { return boost::simd:: map( dispatch::functor<Tag>(), a0 , a1 , a2 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1 , class A2 , class A3,class Tag, class Dummy> struct implement< elementwise_<Tag>( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> , unspecified_<A3> ) , tag::formal_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1 , class _A2 , class _A3> struct result<This(_A0 , _A1 , _A2 , _A3)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 , _A2 , _A3 ) > { }; template<class _A0 , class _A1 , class _A2 , class _A3> typename result<implement(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3)>::type operator()(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3) const { return boost::simd:: map( dispatch::functor<Tag>(), a0 , a1 , a2 , a3 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1 , class A2 , class A3 , class A4,class Tag, class Dummy> struct implement< elementwise_<Tag>( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> , unspecified_<A3> , unspecified_<A4> ) , tag::formal_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1 , class _A2 , class _A3 , class _A4> struct result<This(_A0 , _A1 , _A2 , _A3 , _A4)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 , _A2 , _A3 , _A4 ) > { }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4> typename result<implement(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4)>::type operator()(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4) const { return boost::simd:: map( dispatch::functor<Tag>(), a0 , a1 , a2 , a3 , a4 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1 , class A2 , class A3 , class A4 , class A5,class Tag, class Dummy> struct implement< elementwise_<Tag>( unspecified_<A0> , unspecified_<A1> , unspecified_<A2> , unspecified_<A3> , unspecified_<A4> , unspecified_<A5> ) , tag::formal_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> struct result<This(_A0 , _A1 , _A2 , _A3 , _A4 , _A5)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 , _A2 , _A3 , _A4 , _A5 ) > { }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> typename result<implement(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5)>::type operator()(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5) const { return boost::simd:: map( dispatch::functor<Tag>(), a0 , a1 , a2 , a3 , a4 , a5 ); } }; } } }
