namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class A0 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_avx_sse_ ( simd_< double_ <A0>, boost::simd::tag::sse_ > , simd_< double_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_avx_sse_, boost::simd::tag::avx_ , simd_< double_ <A0>, boost::simd::tag::sse_ > const , simd_< double_ <A0>, boost::simd::tag::sse_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_avx_sse_ ( simd_< double_ <A0>, boost::simd::tag::sse_ > , simd_< double_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class A0 > struct implement< boost::simd::tag::map_avx_sse_ ( simd_< double_ <A0>, boost::simd::tag::sse_ > , simd_< double_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::avx_ > { typedef simd::native< typename meta::scalar_of<A0>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()(A0 const& a0, A0 const& a1) const { result_type that = _mm256_castpd128_pd256(a0()); that = _mm256_insertf128_pd(that(), a1(), 1); return that; } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< double_ <A0>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; a00 = _mm256_extractf128_pd(a0,0); a10 = _mm256_extractf128_pd(a0,1); r0 = f(a00 ); r1 = f(a10 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< double_ <A0>, boost::simd::tag::avx_ > const , simd_< double_ <A1>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; a00 = _mm256_extractf128_pd(a0,0); a10 = _mm256_extractf128_pd(a0,1); a01 = _mm256_extractf128_pd(a1,0); a11 = _mm256_extractf128_pd(a1,1); r0 = f(a00 , a01 ); r1 = f(a10 , a11 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< double_ <A0>, boost::simd::tag::avx_ > const , simd_< double_ <A1>, boost::simd::tag::avx_ > const , simd_< double_ <A2>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; a00 = _mm256_extractf128_pd(a0,0); a10 = _mm256_extractf128_pd(a0,1); a01 = _mm256_extractf128_pd(a1,0); a11 = _mm256_extractf128_pd(a1,1); a02 = _mm256_extractf128_pd(a2,0); a12 = _mm256_extractf128_pd(a2,1); r0 = f(a00 , a01 , a02 ); r1 = f(a10 , a11 , a12 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > , simd_< double_ <A3>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< double_ <A0>, boost::simd::tag::avx_ > const , simd_< double_ <A1>, boost::simd::tag::avx_ > const , simd_< double_ <A2>, boost::simd::tag::avx_ > const , simd_< double_ <A3>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > , simd_< double_ <A3>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > , simd_< double_ <A3>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> , simd::native<typename meta::scalar_of<A3>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; native<typename meta::scalar_of<A3>::type,tag::sse_> a03,a13; a00 = _mm256_extractf128_pd(a0,0); a10 = _mm256_extractf128_pd(a0,1); a01 = _mm256_extractf128_pd(a1,0); a11 = _mm256_extractf128_pd(a1,1); a02 = _mm256_extractf128_pd(a2,0); a12 = _mm256_extractf128_pd(a2,1); a03 = _mm256_extractf128_pd(a3,0); a13 = _mm256_extractf128_pd(a3,1); r0 = f(a00 , a01 , a02 , a03 ); r1 = f(a10 , a11 , a12 , a13 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > , simd_< double_ <A3>, boost::simd::tag::avx_ > , simd_< double_ <A4>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< double_ <A0>, boost::simd::tag::avx_ > const , simd_< double_ <A1>, boost::simd::tag::avx_ > const , simd_< double_ <A2>, boost::simd::tag::avx_ > const , simd_< double_ <A3>, boost::simd::tag::avx_ > const , simd_< double_ <A4>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > , simd_< double_ <A3>, boost::simd::tag::avx_ > , simd_< double_ <A4>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > , simd_< double_ <A3>, boost::simd::tag::avx_ > , simd_< double_ <A4>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> , simd::native<typename meta::scalar_of<A3>::type, tag::sse_> , simd::native<typename meta::scalar_of<A4>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; native<typename meta::scalar_of<A3>::type,tag::sse_> a03,a13; native<typename meta::scalar_of<A4>::type,tag::sse_> a04,a14; a00 = _mm256_extractf128_pd(a0,0); a10 = _mm256_extractf128_pd(a0,1); a01 = _mm256_extractf128_pd(a1,0); a11 = _mm256_extractf128_pd(a1,1); a02 = _mm256_extractf128_pd(a2,0); a12 = _mm256_extractf128_pd(a2,1); a03 = _mm256_extractf128_pd(a3,0); a13 = _mm256_extractf128_pd(a3,1); a04 = _mm256_extractf128_pd(a4,0); a14 = _mm256_extractf128_pd(a4,1); r0 = f(a00 , a01 , a02 , a03 , a04 ); r1 = f(a10 , a11 , a12 , a13 , a14 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > , simd_< double_ <A3>, boost::simd::tag::avx_ > , simd_< double_ <A4>, boost::simd::tag::avx_ > , simd_< double_ <A5>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< double_ <A0>, boost::simd::tag::avx_ > const , simd_< double_ <A1>, boost::simd::tag::avx_ > const , simd_< double_ <A2>, boost::simd::tag::avx_ > const , simd_< double_ <A3>, boost::simd::tag::avx_ > const , simd_< double_ <A4>, boost::simd::tag::avx_ > const , simd_< double_ <A5>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > , simd_< double_ <A3>, boost::simd::tag::avx_ > , simd_< double_ <A4>, boost::simd::tag::avx_ > , simd_< double_ <A5>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< double_ <A0>, boost::simd::tag::avx_ > , simd_< double_ <A1>, boost::simd::tag::avx_ > , simd_< double_ <A2>, boost::simd::tag::avx_ > , simd_< double_ <A3>, boost::simd::tag::avx_ > , simd_< double_ <A4>, boost::simd::tag::avx_ > , simd_< double_ <A5>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> , simd::native<typename meta::scalar_of<A3>::type, tag::sse_> , simd::native<typename meta::scalar_of<A4>::type, tag::sse_> , simd::native<typename meta::scalar_of<A5>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; native<typename meta::scalar_of<A3>::type,tag::sse_> a03,a13; native<typename meta::scalar_of<A4>::type,tag::sse_> a04,a14; native<typename meta::scalar_of<A5>::type,tag::sse_> a05,a15; a00 = _mm256_extractf128_pd(a0,0); a10 = _mm256_extractf128_pd(a0,1); a01 = _mm256_extractf128_pd(a1,0); a11 = _mm256_extractf128_pd(a1,1); a02 = _mm256_extractf128_pd(a2,0); a12 = _mm256_extractf128_pd(a2,1); a03 = _mm256_extractf128_pd(a3,0); a13 = _mm256_extractf128_pd(a3,1); a04 = _mm256_extractf128_pd(a4,0); a14 = _mm256_extractf128_pd(a4,1); a05 = _mm256_extractf128_pd(a5,0); a15 = _mm256_extractf128_pd(a5,1); r0 = f(a00 , a01 , a02 , a03 , a04 , a05 ); r1 = f(a10 , a11 , a12 , a13 , a14 , a15 ); return map_avx_sse(r0, r1); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class A0 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_avx_sse_ ( simd_< single_ <A0>, boost::simd::tag::sse_ > , simd_< single_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_avx_sse_, boost::simd::tag::avx_ , simd_< single_ <A0>, boost::simd::tag::sse_ > const , simd_< single_ <A0>, boost::simd::tag::sse_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_avx_sse_ ( simd_< single_ <A0>, boost::simd::tag::sse_ > , simd_< single_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class A0 > struct implement< boost::simd::tag::map_avx_sse_ ( simd_< single_ <A0>, boost::simd::tag::sse_ > , simd_< single_ <A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::avx_ > { typedef simd::native< typename meta::scalar_of<A0>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()(A0 const& a0, A0 const& a1) const { result_type that = _mm256_castps128_ps256(a0()); that = _mm256_insertf128_ps(that(), a1(), 1); return that; } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< single_ <A0>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; a00 = _mm256_extractf128_ps(a0,0); a10 = _mm256_extractf128_ps(a0,1); r0 = f(a00 ); r1 = f(a10 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< single_ <A0>, boost::simd::tag::avx_ > const , simd_< single_ <A1>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; a00 = _mm256_extractf128_ps(a0,0); a10 = _mm256_extractf128_ps(a0,1); a01 = _mm256_extractf128_ps(a1,0); a11 = _mm256_extractf128_ps(a1,1); r0 = f(a00 , a01 ); r1 = f(a10 , a11 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< single_ <A0>, boost::simd::tag::avx_ > const , simd_< single_ <A1>, boost::simd::tag::avx_ > const , simd_< single_ <A2>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; a00 = _mm256_extractf128_ps(a0,0); a10 = _mm256_extractf128_ps(a0,1); a01 = _mm256_extractf128_ps(a1,0); a11 = _mm256_extractf128_ps(a1,1); a02 = _mm256_extractf128_ps(a2,0); a12 = _mm256_extractf128_ps(a2,1); r0 = f(a00 , a01 , a02 ); r1 = f(a10 , a11 , a12 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > , simd_< single_ <A3>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< single_ <A0>, boost::simd::tag::avx_ > const , simd_< single_ <A1>, boost::simd::tag::avx_ > const , simd_< single_ <A2>, boost::simd::tag::avx_ > const , simd_< single_ <A3>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > , simd_< single_ <A3>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > , simd_< single_ <A3>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> , simd::native<typename meta::scalar_of<A3>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; native<typename meta::scalar_of<A3>::type,tag::sse_> a03,a13; a00 = _mm256_extractf128_ps(a0,0); a10 = _mm256_extractf128_ps(a0,1); a01 = _mm256_extractf128_ps(a1,0); a11 = _mm256_extractf128_ps(a1,1); a02 = _mm256_extractf128_ps(a2,0); a12 = _mm256_extractf128_ps(a2,1); a03 = _mm256_extractf128_ps(a3,0); a13 = _mm256_extractf128_ps(a3,1); r0 = f(a00 , a01 , a02 , a03 ); r1 = f(a10 , a11 , a12 , a13 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > , simd_< single_ <A3>, boost::simd::tag::avx_ > , simd_< single_ <A4>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< single_ <A0>, boost::simd::tag::avx_ > const , simd_< single_ <A1>, boost::simd::tag::avx_ > const , simd_< single_ <A2>, boost::simd::tag::avx_ > const , simd_< single_ <A3>, boost::simd::tag::avx_ > const , simd_< single_ <A4>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > , simd_< single_ <A3>, boost::simd::tag::avx_ > , simd_< single_ <A4>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > , simd_< single_ <A3>, boost::simd::tag::avx_ > , simd_< single_ <A4>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> , simd::native<typename meta::scalar_of<A3>::type, tag::sse_> , simd::native<typename meta::scalar_of<A4>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; native<typename meta::scalar_of<A3>::type,tag::sse_> a03,a13; native<typename meta::scalar_of<A4>::type,tag::sse_> a04,a14; a00 = _mm256_extractf128_ps(a0,0); a10 = _mm256_extractf128_ps(a0,1); a01 = _mm256_extractf128_ps(a1,0); a11 = _mm256_extractf128_ps(a1,1); a02 = _mm256_extractf128_ps(a2,0); a12 = _mm256_extractf128_ps(a2,1); a03 = _mm256_extractf128_ps(a3,0); a13 = _mm256_extractf128_ps(a3,1); a04 = _mm256_extractf128_ps(a4,0); a14 = _mm256_extractf128_ps(a4,1); r0 = f(a00 , a01 , a02 , a03 , a04 ); r1 = f(a10 , a11 , a12 , a13 , a14 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > , simd_< single_ <A3>, boost::simd::tag::avx_ > , simd_< single_ <A4>, boost::simd::tag::avx_ > , simd_< single_ <A5>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< single_ <A0>, boost::simd::tag::avx_ > const , simd_< single_ <A1>, boost::simd::tag::avx_ > const , simd_< single_ <A2>, boost::simd::tag::avx_ > const , simd_< single_ <A3>, boost::simd::tag::avx_ > const , simd_< single_ <A4>, boost::simd::tag::avx_ > const , simd_< single_ <A5>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > , simd_< single_ <A3>, boost::simd::tag::avx_ > , simd_< single_ <A4>, boost::simd::tag::avx_ > , simd_< single_ <A5>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< single_ <A0>, boost::simd::tag::avx_ > , simd_< single_ <A1>, boost::simd::tag::avx_ > , simd_< single_ <A2>, boost::simd::tag::avx_ > , simd_< single_ <A3>, boost::simd::tag::avx_ > , simd_< single_ <A4>, boost::simd::tag::avx_ > , simd_< single_ <A5>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> , simd::native<typename meta::scalar_of<A3>::type, tag::sse_> , simd::native<typename meta::scalar_of<A4>::type, tag::sse_> , simd::native<typename meta::scalar_of<A5>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; native<typename meta::scalar_of<A3>::type,tag::sse_> a03,a13; native<typename meta::scalar_of<A4>::type,tag::sse_> a04,a14; native<typename meta::scalar_of<A5>::type,tag::sse_> a05,a15; a00 = _mm256_extractf128_ps(a0,0); a10 = _mm256_extractf128_ps(a0,1); a01 = _mm256_extractf128_ps(a1,0); a11 = _mm256_extractf128_ps(a1,1); a02 = _mm256_extractf128_ps(a2,0); a12 = _mm256_extractf128_ps(a2,1); a03 = _mm256_extractf128_ps(a3,0); a13 = _mm256_extractf128_ps(a3,1); a04 = _mm256_extractf128_ps(a4,0); a14 = _mm256_extractf128_ps(a4,1); a05 = _mm256_extractf128_ps(a5,0); a15 = _mm256_extractf128_ps(a5,1); r0 = f(a00 , a01 , a02 , a03 , a04 , a05 ); r1 = f(a10 , a11 , a12 , a13 , a14 , a15 ); return map_avx_sse(r0, r1); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class A0 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_avx_sse_ ( simd_< integer_<A0>, boost::simd::tag::sse_ > , simd_< integer_<A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_avx_sse_, boost::simd::tag::avx_ , simd_< integer_<A0>, boost::simd::tag::sse_ > const , simd_< integer_<A0>, boost::simd::tag::sse_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_avx_sse_ ( simd_< integer_<A0>, boost::simd::tag::sse_ > , simd_< integer_<A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class A0 > struct implement< boost::simd::tag::map_avx_sse_ ( simd_< integer_<A0>, boost::simd::tag::sse_ > , simd_< integer_<A0>, boost::simd::tag::sse_ > ) , boost::simd::tag::avx_ > { typedef simd::native< typename meta::scalar_of<A0>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()(A0 const& a0, A0 const& a1) const { result_type that = _mm256_castsi128_si256(a0()); that = _mm256_insertf128_si256(that(), a1(), 1); return that; } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< integer_ <A0>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; a00 = _mm256_extractf128_si256(a0,0); a10 = _mm256_extractf128_si256(a0,1); r0 = f(a00 ); r1 = f(a10 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< integer_ <A0>, boost::simd::tag::avx_ > const , simd_< integer_ <A1>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; a00 = _mm256_extractf128_si256(a0,0); a10 = _mm256_extractf128_si256(a0,1); a01 = _mm256_extractf128_si256(a1,0); a11 = _mm256_extractf128_si256(a1,1); r0 = f(a00 , a01 ); r1 = f(a10 , a11 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< integer_ <A0>, boost::simd::tag::avx_ > const , simd_< integer_ <A1>, boost::simd::tag::avx_ > const , simd_< integer_ <A2>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; a00 = _mm256_extractf128_si256(a0,0); a10 = _mm256_extractf128_si256(a0,1); a01 = _mm256_extractf128_si256(a1,0); a11 = _mm256_extractf128_si256(a1,1); a02 = _mm256_extractf128_si256(a2,0); a12 = _mm256_extractf128_si256(a2,1); r0 = f(a00 , a01 , a02 ); r1 = f(a10 , a11 , a12 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > , simd_< integer_ <A3>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< integer_ <A0>, boost::simd::tag::avx_ > const , simd_< integer_ <A1>, boost::simd::tag::avx_ > const , simd_< integer_ <A2>, boost::simd::tag::avx_ > const , simd_< integer_ <A3>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > , simd_< integer_ <A3>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > , simd_< integer_ <A3>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> , simd::native<typename meta::scalar_of<A3>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; native<typename meta::scalar_of<A3>::type,tag::sse_> a03,a13; a00 = _mm256_extractf128_si256(a0,0); a10 = _mm256_extractf128_si256(a0,1); a01 = _mm256_extractf128_si256(a1,0); a11 = _mm256_extractf128_si256(a1,1); a02 = _mm256_extractf128_si256(a2,0); a12 = _mm256_extractf128_si256(a2,1); a03 = _mm256_extractf128_si256(a3,0); a13 = _mm256_extractf128_si256(a3,1); r0 = f(a00 , a01 , a02 , a03 ); r1 = f(a10 , a11 , a12 , a13 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > , simd_< integer_ <A3>, boost::simd::tag::avx_ > , simd_< integer_ <A4>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< integer_ <A0>, boost::simd::tag::avx_ > const , simd_< integer_ <A1>, boost::simd::tag::avx_ > const , simd_< integer_ <A2>, boost::simd::tag::avx_ > const , simd_< integer_ <A3>, boost::simd::tag::avx_ > const , simd_< integer_ <A4>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > , simd_< integer_ <A3>, boost::simd::tag::avx_ > , simd_< integer_ <A4>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > , simd_< integer_ <A3>, boost::simd::tag::avx_ > , simd_< integer_ <A4>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> , simd::native<typename meta::scalar_of<A3>::type, tag::sse_> , simd::native<typename meta::scalar_of<A4>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; native<typename meta::scalar_of<A3>::type,tag::sse_> a03,a13; native<typename meta::scalar_of<A4>::type,tag::sse_> a04,a14; a00 = _mm256_extractf128_si256(a0,0); a10 = _mm256_extractf128_si256(a0,1); a01 = _mm256_extractf128_si256(a1,0); a11 = _mm256_extractf128_si256(a1,1); a02 = _mm256_extractf128_si256(a2,0); a12 = _mm256_extractf128_si256(a2,1); a03 = _mm256_extractf128_si256(a3,0); a13 = _mm256_extractf128_si256(a3,1); a04 = _mm256_extractf128_si256(a4,0); a14 = _mm256_extractf128_si256(a4,1); r0 = f(a00 , a01 , a02 , a03 , a04 ); r1 = f(a10 , a11 , a12 , a13 , a14 ); return map_avx_sse(r0, r1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > , simd_< integer_ <A3>, boost::simd::tag::avx_ > , simd_< integer_ <A4>, boost::simd::tag::avx_ > , simd_< integer_ <A5>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > dispatching( boost::simd::tag::map_, boost::simd::tag::avx_ , unspecified_<Func> const , simd_< integer_ <A0>, boost::simd::tag::avx_ > const , simd_< integer_ <A1>, boost::simd::tag::avx_ > const , simd_< integer_ <A2>, boost::simd::tag::avx_ > const , simd_< integer_ <A3>, boost::simd::tag::avx_ > const , simd_< integer_ <A4>, boost::simd::tag::avx_ > const , simd_< integer_ <A5>, boost::simd::tag::avx_ > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > , simd_< integer_ <A3>, boost::simd::tag::avx_ > , simd_< integer_ <A4>, boost::simd::tag::avx_ > , simd_< integer_ <A5>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< integer_ <A0>, boost::simd::tag::avx_ > , simd_< integer_ <A1>, boost::simd::tag::avx_ > , simd_< integer_ <A2>, boost::simd::tag::avx_ > , simd_< integer_ <A3>, boost::simd::tag::avx_ > , simd_< integer_ <A4>, boost::simd::tag::avx_ > , simd_< integer_ <A5>, boost::simd::tag::avx_ > ) , boost::simd::tag::avx_ > { typedef typename dispatch::meta:: result_of< Func const( simd::native<typename meta::scalar_of<A0>::type, tag::sse_> , simd::native<typename meta::scalar_of<A1>::type, tag::sse_> , simd::native<typename meta::scalar_of<A2>::type, tag::sse_> , simd::native<typename meta::scalar_of<A3>::type, tag::sse_> , simd::native<typename meta::scalar_of<A4>::type, tag::sse_> , simd::native<typename meta::scalar_of<A5>::type, tag::sse_> )>::type base; typedef simd::native< typename meta::scalar_of<base>::type , boost::simd::tag::avx_ > result_type; inline result_type operator()( Func const& f , A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 ) const { base r0,r1; native<typename meta::scalar_of<A0>::type,tag::sse_> a00,a10; native<typename meta::scalar_of<A1>::type,tag::sse_> a01,a11; native<typename meta::scalar_of<A2>::type,tag::sse_> a02,a12; native<typename meta::scalar_of<A3>::type,tag::sse_> a03,a13; native<typename meta::scalar_of<A4>::type,tag::sse_> a04,a14; native<typename meta::scalar_of<A5>::type,tag::sse_> a05,a15; a00 = _mm256_extractf128_si256(a0,0); a10 = _mm256_extractf128_si256(a0,1); a01 = _mm256_extractf128_si256(a1,0); a11 = _mm256_extractf128_si256(a1,1); a02 = _mm256_extractf128_si256(a2,0); a12 = _mm256_extractf128_si256(a2,1); a03 = _mm256_extractf128_si256(a3,0); a13 = _mm256_extractf128_si256(a3,1); a04 = _mm256_extractf128_si256(a4,0); a14 = _mm256_extractf128_si256(a4,1); a05 = _mm256_extractf128_si256(a5,0); a15 = _mm256_extractf128_si256(a5,1); r0 = f(a00 , a01 , a02 , a03 , a04 , a05 ); r1 = f(a10 , a11 , a12 , a13 , a14 , a15 ); return map_avx_sse(r0, r1); } }; } } }
