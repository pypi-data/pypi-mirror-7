# -*- mode: python -*-

# Soya 3D
# Copyright (C) 2001-2014 Jean-Baptiste LAMY
# http://www.lesfleursdunormal.fr/static/informatique/soya3d/index_en.html

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

varying vec3 self.cameraspace_vertex
varying vec3 self.cameraspace_normal

const vec3 self.eye = vec3(0.0, 0.0, 1.0)

def void lighting_mini_shader():
  if lighting_mode == 1:
    self.cameraspace_vertex = vec3(current_vertex)
    self.cameraspace_normal =      current_normal
    
    
def void pixel_color_mini_shader():
  vec4  self.ambient
  vec4  self.diffuse
  vec4  self.specular
  float self.alpha
  
  float self.nDotVP      # current_normal . light direction
  float self.nDotHV      # current_normal . light half vector
  float self.spotDot     # cosine of angle between spotlight
  float self.attenuation # computed attenuation factor
  float self.d           # distance from surface to light source
  vec3  self.VP          # direction from surface to light position
  
  vec3 self.cameraspace_normal2
  if gl_FrontFacing: self.cameraspace_normal2 =  normalize(self.cameraspace_normal)
  else:              self.cameraspace_normal2 = -normalize(self.cameraspace_normal)
  
  if lighting_mode == 1:
    self.ambient  = vec4(0.0) # Clear the light intensity accumulators
    self.diffuse  = vec4(0.0)
    self.specular = vec4(0.0)
    
    for current_light in lights:
      if gl_LightSource[current_light].position.w == 0.0:
        
        # Directional light
        self.ambient += gl_LightSource[current_light].ambient
        
        self.nDotVP = dot( self.cameraspace_normal2, normalize(vec3(gl_LightSource[current_light].position)))
        
        if self.nDotVP > 0.0:
          self.diffuse += gl_LightSource[current_light].diffuse * self.nDotVP
          if gl_FrontMaterial.specular[3] != 0.0:
            self.nDotHV    = max(0.0, dot( self.cameraspace_normal2, vec3(gl_LightSource[current_light].halfVector)))
            self.specular += gl_LightSource[current_light].specular * pow(self.nDotHV, gl_FrontMaterial.shininess)
            
          
      else:
        # Point light
        self.VP = vec3(gl_LightSource[current_light].position) - self.cameraspace_vertex # Compute vector from surface to light position
        self.d  = length(self.VP)                                                        # Compute distance between surface and light position
        self.VP = normalize(self.VP)                                                     # Normalize the vector from surface to light position

        if gl_LightSource[current_light].spotCutoff == 180.0: # Point light
          self.attenuation = 1.0 / (gl_LightSource[current_light].constantAttenuation         + \
                                    gl_LightSource[current_light].linearAttenuation    * self.d    + \
                                    gl_LightSource[current_light].quadraticAttenuation * self.d * self.d)
          
        else: # Spot light : see if point on surface is inside cone of illumination
          self.spotDot = dot(self.VP, normalize(gl_LightSource[current_light].spotDirection))
          if self.spotDot < gl_LightSource[current_light].spotCosCutoff: return # light adds no contribution
          
          self.attenuation = pow(self.spotDot, gl_LightSource[current_light].spotExponent) / ( \
                                               gl_LightSource[current_light].constantAttenuation         + \
                                               gl_LightSource[current_light].linearAttenuation    * self.d    + \
                                               gl_LightSource[current_light].quadraticAttenuation * self.d * self.d)
          
        self.ambient += gl_LightSource[current_light].ambient  * self.attenuation
        
        self.nDotVP = dot( self.cameraspace_normal, self.VP)
        
        if self.nDotVP > 0.0:
          self.diffuse += gl_LightSource[current_light].diffuse  * self.attenuation * self.nDotVP
          if gl_FrontMaterial.specular[3] != 0.0:
            self.nDotHV    = max(0.0, dot( self.cameraspace_normal, normalize(self.VP + self.eye)))
            self.specular += gl_LightSource[current_light].specular * self.attenuation * pow(self.nDotHV, gl_FrontMaterial.shininess)
          
    self.alpha = current_color[3]
    current_color    = clamp(gl_FrontMaterial.emission + gl_LightModel.ambient + (self.ambient + self.diffuse) * current_color, 0.0, 1.0)
    current_color[3] = self.alpha
    

def void specular_mini_shader():
  if gl_FrontMaterial.specular[3] != 0.0:
    current_color = clamp(current_color + self.specular * gl_FrontMaterial.specular, 0.0, 1.0)
    
    
