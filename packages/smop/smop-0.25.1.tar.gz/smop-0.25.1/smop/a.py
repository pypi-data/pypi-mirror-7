# Autogenerated with SMOP version 0.25.1
# main.py -v solver.m
from __future__ import division
from runtime import *
def solver_(ai,af,w,nargout=1):
    nBlocks=max_(ai[:])
    m,n=size_(ai,nargout=2)
    I=matlabarray([0,1,0,- 1])
    J=matlabarray([1,0,- 1,0])
    a=copy_(ai)
    mv=matlabarray([])
    while not isequal_(af,a):

        bid=ceil_(rand_() * nBlocks)
        i,j=find_(a == bid,nargout=2)
        r=ceil_(rand_() * 4)
        ni=i + I[r]
        nj=j + J[r]
        if (ni < 1) or (ni > m) or (nj < 1) or (nj > n):
            continue
        if a[ni,nj] > 0:
            continue
        ti,tj=find_(af == bid,nargout=2)
        d=(ti - i) ** 2 + (tj - j) ** 2
        dn=(ti - ni) ** 2 + (tj - nj) ** 2
        if (d < dn) and (rand_() > 0.05):
            continue
        a[ni,nj]=bid
        a[i,j]=0
        mv[mv.shape[0] + 1,[1,2]]=[bid,r]

    return mv                                                 
