<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Developer guide &mdash; Bibulous 1.2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Bibulous 1.2 documentation" href="index.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="Instructions on how to report a bug to the Bibulous development team" href="instructions_for_reporting_bugs.html" /> 
  </head>
  <body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><img src="_static/banner.svg" border="0" height=300 alt="py4sci"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="examples.html" title="Examples"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="instructions_for_reporting_bugs.html" title="Instructions on how to report a bug to the Bibulous development team"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo_small.svg" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Developer guide</a><ul>
<li><a class="reference internal" href="#guidelines-and-notes-for-python-coding-style">Guidelines and notes for Python coding style</a></li>
<li><a class="reference internal" href="#overall-project-strategy-and-code-structure">Overall project strategy and code structure</a></li>
<li><a class="reference internal" href="#parsing-bib-files">Parsing BIB files</a><ul>
<li><a class="reference internal" href="#parse-bibfile">parse_bibfile()</a></li>
<li><a class="reference internal" href="#parse-bibentry">parse_bibentry()</a></li>
<li><a class="reference internal" href="#parse-bibfield">parse_bibfield()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parsing-aux-files">Parsing AUX files</a></li>
<li><a class="reference internal" href="#parsing-bst-files">Parsing BST files</a></li>
<li><a class="reference internal" href="#writing-the-bbl-file">Writing the BBL file</a></li>
<li><a class="reference internal" href="#name-formatting">Name formatting</a><ul>
<li><a class="reference internal" href="#create-namelist">create_namelist()</a></li>
<li><a class="reference internal" href="#format-namelist">format_namelist()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generating-sortkeys">Generating sortkeys</a></li>
<li><a class="reference internal" href="#testing">Testing</a></li>
<li><a class="reference internal" href="#generating-the-documentation">Generating the documentation</a></li>
<li><a class="reference internal" href="#miscellaneous-notes">Miscellaneous notes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="instructions_for_reporting_bugs.html"
                        title="previous chapter">Instructions on how to report a bug to the Bibulous development team</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="examples.html"
                        title="next chapter">Examples</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/developer_guide.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="developer-guide">
<h1>Developer guide<a class="headerlink" href="#developer-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="guidelines-and-notes-for-python-coding-style">
<h2>Guidelines and notes for Python coding style<a class="headerlink" href="#guidelines-and-notes-for-python-coding-style" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">Note that one can mix 8-bit Python strings (ASCII text) with UTF-8 encoded text as long as the 8-bit string contains only ASCII characters.</p>
</li>
<li><p class="first">Keep in mind when running into Unicode errors: reading a line of text from a file produces a line of bytes and not characters. To decode the bytes into a string of characters, you need to know the encoding.</p>
</li>
<li><p class="first">There are a couple of minor points where the Bibulous coding standards deviates from Python&#8217;s PEP8:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>A line width of 120 is the standard (not 80).</li>
<li>In general, statements that evaluate to a boolean are placed within parentheses (i.e. <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(a</span> <span class="pre">&lt;</span> <span class="pre">b):</span></tt> rather than <tt class="docutils literal"><span class="pre">if</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b:</span></tt>).</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Many developers prefer to spread out code among a large number of small files, but Bibulous is currently organized in a single large file. This is partly because there is no large block of code that fits by itself so that a separate file makes sense. (Parsing of <tt class="docutils literal"><span class="pre">.bib</span></tt> files, for example, only requires a couple hundred lines.</p>
</li>
</ol>
</div>
<div class="section" id="overall-project-strategy-and-code-structure">
<h2>Overall project strategy and code structure<a class="headerlink" href="#overall-project-strategy-and-code-structure" title="Permalink to this headline">¶</a></h2>
<p>The basic function of BibTeX is to accept an <tt class="docutils literal"><span class="pre">.aux</span></tt> file as input and to produce a <tt class="docutils literal"><span class="pre">.bbl</span></tt> file as output. The <tt class="docutils literal"><span class="pre">aux</span></tt> file contains all of the citation information as well as the filenames for the bibliography database file (<tt class="docutils literal"><span class="pre">.bib</span></tt>) and the style file (<tt class="docutils literal"><span class="pre">.bst</span></tt>).</p>
<p>The basic program flow is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Read the <tt class="docutils literal"><span class="pre">.aux</span></tt> file and get the names of the bibliography databases (<tt class="docutils literal"><span class="pre">.bib</span></tt> files), the style templates (<tt class="docutils literal"><span class="pre">.bst</span></tt> files) to use, together with the entire set of citations.</li>
<li>Read in the Bibulous style template file as a dictionary (<tt class="docutils literal"><span class="pre">bstdict</span></tt>).</li>
<li>If the <tt class="docutils literal"><span class="pre">use_citeextract</span></tt> keyword is set to True, and if an &#8220;extracted&#8221; database file exists, then compare the citations in the extracted database against those in the <tt class="docutils literal"><span class="pre">.aux</span></tt> file. If there are any differences, then re-extract the database. Otherwise, use the extracted database rather than the full one specified in the <tt class="docutils literal"><span class="pre">.aux</span></tt> file.</li>
<li>Read in all of the bibliography database files into one long dictionary (<tt class="docutils literal"><span class="pre">bibdata</span></tt>), replacing any abbreviations with their full form. In an &#8220;extracted&#8221; database, all entries are parsed, whereas in any other type of database file, only those entries whose keywords are found in the citation list are actually parsed. All other entries have their data saved as unparsed strings. Cross-referenced data is <em>not</em> yet inserted at this point. That is delayed until the time of writing the BBL file in order to speed up parsing. It is only then that the cross-referenced entries have their data parsed into dictionary form.</li>
<li>Now that all the information is collected, we can generate the <tt class="docutils literal"><span class="pre">.bbl</span></tt> file. Create the list of sortkeys, then go through each corresponding citation key in turn, and find the corresponding entry key in <tt class="docutils literal"><span class="pre">bibdata</span></tt>. If there is crossref data, then fill in missing values here. Also create the &#8220;special variables&#8221; here. Finally, from the entry type, select a template from <tt class="docutils literal"><span class="pre">bstdict</span></tt> and begin inserting the variables one-by-one into the template.</li>
</ol>
</div></blockquote>
<p>Because the <tt class="docutils literal"><span class="pre">.bib</span></tt> file is highly structured, it is straightforward to write a parser by hand in Python: the <tt class="docutils literal"><span class="pre">parse_bibfile()</span></tt> method converts the <tt class="docutils literal"><span class="pre">.bib</span></tt> file contents into a Python dictionary (the <tt class="docutils literal"><span class="pre">Bibdata</span></tt> class&#8217; <tt class="docutils literal"><span class="pre">bibdata</span></tt>). The <tt class="docutils literal"><span class="pre">.aux</span></tt> file is even easier to parse, and the <tt class="docutils literal"><span class="pre">parse_auxfile()</span></tt> method converts the citation information into the <tt class="docutils literal"><span class="pre">Bibdata</span></tt> class&#8217; <tt class="docutils literal"><span class="pre">citedict</span></tt> dictionary.</p>
<p>The <tt class="docutils literal"><span class="pre">Bibdata</span></tt> class thus holds all relevant information needed to operate on a bibliography and generate the output LaTeX-formatted <tt class="docutils literal"><span class="pre">.bbl</span></tt> file.</p>
</div>
<div class="section" id="parsing-bib-files">
<h2>Parsing BIB files<a class="headerlink" href="#parsing-bib-files" title="Permalink to this headline">¶</a></h2>
<div class="section" id="parse-bibfile">
<h3>parse_bibfile()<a class="headerlink" href="#parse-bibfile" title="Permalink to this headline">¶</a></h3>
<p>The strategy for <tt class="docutils literal"><span class="pre">parse_bibfile()</span></tt> is to find each individual bibliography entry, determine its entry type, and save all of the text between the entry&#8217;s opening and closing braces as one long string, to be passed to <tt class="docutils literal"><span class="pre">parse_bibentry()</span></tt> for further parsing. To gather the entry data string, we first look for a line that starts with <tt class="docutils literal"><span class="pre">&#64;</span></tt>. On that line, we look for a string after the <tt class="docutils literal"><span class="pre">&#64;</span></tt> followed by <tt class="docutils literal"><span class="pre">{</span></tt>, where the string gives the entry type. After we know the entry type, we look for the corresponding closing brace. If we don&#8217;t find it on the same line, then we read in the next line, and so forth, concatenating all of the lines into one long &#8220;entry string&#8221; until we encounter the corresponding closing brace. Once we have this extended &#8220;entry string&#8221; we feed it to <tt class="docutils literal"><span class="pre">parse_bibentry()</span></tt> to generate the bibliography data. Once we have come to the end of a given entry, we continue reading down the file looking for the next &#8216;&#64;&#8217; and so on.</p>
<p>Although this approach effectively means that we have to pass twice through the same data, dealing with brace-matching can otherwise become a mess for the BibTeX format, since it allows nested delimiters, is not directly compatible with regular expressions.</p>
</div>
<div class="section" id="parse-bibentry">
<h3>parse_bibentry()<a class="headerlink" href="#parse-bibentry" title="Permalink to this headline">¶</a></h3>
<p>Because <tt class="docutils literal"><span class="pre">parse_bibfile()</span></tt> has already split the data by individual entry, <tt class="docutils literal"><span class="pre">parse_bibentry()</span></tt> only needs to worry about parsing a single entry, and there are five possible formats for the entry string passed to the function:</p>
<blockquote>
<div><ol class="arabic simple">
<li>If the entrytype is a <tt class="docutils literal"><span class="pre">comment</span></tt>, then skip everything, adding nothing to the database dictionary.</li>
<li>If the entrytype is a <tt class="docutils literal"><span class="pre">preamble</span></tt>, then treat the entire entry contents as a single fieldvalue. Append the string onto the <tt class="docutils literal"><span class="pre">preamble</span></tt> value in the <tt class="docutils literal"><span class="pre">bibdata</span></tt> dictionary.</li>
<li>If the entrytype is a <tt class="docutils literal"><span class="pre">acronym</span></tt>, then get the entrykey and copy it into the <tt class="docutils literal"><span class="pre">name</span></tt> field. The remainder of the string is a single field value (the full form of the acronym); copy that into the <tt class="docutils literal"><span class="pre">description</span></tt> field.</li>
<li>If the entrytype is a <tt class="docutils literal"><span class="pre">string</span></tt> (i.e. an abbreviation), then there is no entrykey. Get the fieldname (abbreviation key), and the remainder of the string is a single field value (the full form of the abbreviated string). Add this key-value pair to the <tt class="docutils literal"><span class="pre">abbrevs</span></tt> dictionary.</li>
<li>If the entry is any other type, then get the entrykey, and the remainder of the string is a <em>series</em> of field-value pairs.</li>
</ol>
</div></blockquote>
<p>Once it determines which of these four options to use, <tt class="docutils literal"><span class="pre">parse_bibentry()</span></tt> extracts the entry key (if present), it locates each individual field and separates out the string corresponding to the key-value pair for each field. It does not actually <em>parse</em> the individual fields. For that, it loops over each field with a call to <tt class="docutils literal"><span class="pre">parse_bibfield()</span></tt> to extract the field key-value pairs.</p>
</div>
<div class="section" id="parse-bibfield">
<h3>parse_bibfield()<a class="headerlink" href="#parse-bibfield" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">parse_bibfield()</span></tt> is the workhorse function of the BIB parsing. And because of BibTeX&#8217;s method for allowing concatenation, use of abbreviation keys, and use of two different types of delimiters (<tt class="docutils literal"><span class="pre">&quot;...&quot;</span></tt> or <tt class="docutils literal"><span class="pre">{...}</span></tt>), this function is a little messy. However, for the format of a given field, there are four parsing possibilities:</p>
<blockquote>
<div><ol class="arabic simple">
<li>If the field begins with a double quote <tt class="docutils literal"><span class="pre">&quot;</span></tt> then scan until you find the next unnested <tt class="docutils literal"><span class="pre">&quot;</span></tt>. Add that to the result string. If the ending <tt class="docutils literal"><span class="pre">&quot;</span></tt> is followed by a comma, then the field is done; return the result string. If the ending is followed by a <tt class="docutils literal"><span class="pre">#</span></tt> then expect another field string. Scan for it and append it to the current result string.</li>
<li>If the field begins with <tt class="docutils literal"><span class="pre">{</span></tt> then scan until you resolve the brace level. This should be followed by a comma, since no concatenation is allowed for brace-delimited fields. Otherwise issue a syntax error warning.</li>
<li>If the field begins with a <tt class="docutils literal"><span class="pre">#</span></tt> (concatenation operator) then skip whitespace to the next character set, where you should expect a quote-delimited field. Append that to the current result string.</li>
<li>If the field begins with anything else, then the substring up until the first whitespace character represents an abbreviation key. Locate it and substitute it in. If you don&#8217;t find the key in the <tt class="docutils literal"><span class="pre">abbrevs</span></tt> dictionary, give a warning and continue on.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="parsing-aux-files">
<h2>Parsing AUX files<a class="headerlink" href="#parsing-aux-files" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">.aux</span></tt> file contains the filenames of the <tt class="docutils literal"><span class="pre">.bib</span></tt> database file and the <tt class="docutils literal"><span class="pre">.bst</span></tt> style template file, as well as the citations. The <tt class="docutils literal"><span class="pre">get_bibfilenames()</span></tt> method scans through the <tt class="docutils literal"><span class="pre">.aux</span></tt> file and locates a line with <tt class="docutils literal"><span class="pre">\bibdata{...}</span></tt> which contains a filename or a comma-delimited list of filenames, giving the database files. Another line with <tt class="docutils literal"><span class="pre">\bibstyle{...}</span></tt> gives the filename or comma-delimited list of filenames for style templates. The filenames obtained are saved into the <tt class="docutils literal"><span class="pre">filedict</span></tt> attribute &#8211; a dictionary whose keys are the file extensions <tt class="docutils literal"><span class="pre">aux</span></tt>, <tt class="docutils literal"><span class="pre">bbl</span></tt>, <tt class="docutils literal"><span class="pre">bib</span></tt>, <tt class="docutils literal"><span class="pre">bst</span></tt>, or <tt class="docutils literal"><span class="pre">tex</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">parse_auxfile()</span></tt> method makes a second pass through the <tt class="docutils literal"><span class="pre">.aux</span></tt> file, this time looking for the citation information. (Auxiliary files are generally quite small, so taking multiple passes through them costs very little time.) Each line with <tt class="docutils literal"><span class="pre">\citation{...}</span></tt> contains a citation key or comma-delimited list of citation keys &#8211; each one is added into the citation dictionary (<tt class="docutils literal"><span class="pre">citedict</span></tt>), with a value corresponding to the citation order.</p>
</div>
<div class="section" id="parsing-bst-files">
<h2>Parsing BST files<a class="headerlink" href="#parsing-bst-files" title="Permalink to this headline">¶</a></h2>
<p>Parsing a <tt class="docutils literal"><span class="pre">.bst</span></tt> file basically involves looking for one of several syntactical structures.</p>
<blockquote>
<div><ol class="arabic simple">
<li>First, any <tt class="docutils literal"><span class="pre">#</span></tt> present in a line indicates a comment. All text following the <tt class="docutils literal"><span class="pre">#</span></tt> are ignored.</li>
<li>Any line containing all capital letters and ending in <tt class="docutils literal"><span class="pre">:</span></tt> indicates a section header. The sections recognized are: <tt class="docutils literal"><span class="pre">TEMPLATES</span></tt>, <tt class="docutils literal"><span class="pre">SPECIAL-TEMPLATES</span></tt>, <tt class="docutils literal"><span class="pre">OPTIONS</span></tt>, <tt class="docutils literal"><span class="pre">VARIABLES</span></tt>, and <tt class="docutils literal"><span class="pre">DEFINITIONS</span></tt>. The first three sections (<tt class="docutils literal"><span class="pre">TEMPLATES</span></tt>, <tt class="docutils literal"><span class="pre">SPECIAL-TEMPLATES</span></tt>, and <tt class="docutils literal"><span class="pre">OPTIONS</span></tt>) use template syntax, while the last two ( <tt class="docutils literal"><span class="pre">VARIABLES</span></tt> and <tt class="docutils literal"><span class="pre">DEFINITIONS</span></tt>) use Python syntax.</li>
<li>In the TEMPLATES, SPECIAL-TEMPLATES, or OPTIONS sections of the file, any line ending in an ellipsis (<tt class="docutils literal"><span class="pre">...</span></tt>) means that the following line is a continuation. Thus, the following line is appended to the current one.</li>
<li>For each <tt class="docutils literal"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">definition</span></tt> pair found in the <tt class="docutils literal"><span class="pre">VARIABLES</span></tt> section of the file, the code creates a new entry in the <tt class="docutils literal"><span class="pre">user_variables</span></tt> dictionary, with value equal to the given definition.</li>
<li>For each <tt class="docutils literal"><span class="pre">entrytype</span> <span class="pre">=</span> <span class="pre">template</span></tt> pair found in the <tt class="docutils literal"><span class="pre">TEMPLATES</span></tt> section of the file, the code creates a corresponding entry in <tt class="docutils literal"><span class="pre">bstdict</span></tt>, with the key given by the <tt class="docutils literal"><span class="pre">entrytype</span></tt> and value given by the <tt class="docutils literal"><span class="pre">template</span></tt>. The code next examines the template definition to see if it contains a nested options block. If so, it adds it to the list of nested templates.</li>
<li>For each <tt class="docutils literal"><span class="pre">keyword</span> <span class="pre">=</span> <span class="pre">value</span></tt> pair found in the <tt class="docutils literal"><span class="pre">OPTIONS</span></tt> section of the file, the code creates a new entry in the <tt class="docutils literal"><span class="pre">options</span></tt> dictionary, with the dictionary key being the keyword itself, and the value copied from the right hand side of the option definition.</li>
<li>For each <tt class="docutils literal"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">definition</span></tt> pair found in the <tt class="docutils literal"><span class="pre">SPECIAL-TEMPLATES</span></tt> section of the file, the code has to do a little more work than elsewhere. First it creates a new entry in the <tt class="docutils literal"><span class="pre">specials</span></tt> dictionary, with the dictionary key given by the <tt class="docutils literal"><span class="pre">var</span></tt>, and the value given by the <tt class="docutils literal"><span class="pre">definition</span></tt>. It then appens the key to the <tt class="docutils literal"><span class="pre">specials_list</span></tt>. (Since a dictionary is not ordered, we need an order-preserving means of iterating through the list of specials to make sure that one can always be defined before another that depends on it.) Next it examines the template definition to see if it contains a nested options block. If so, it adds it to the list of nested templates. It also looks to see if there is an ellipsis representing an implicit loop. If so, it adds the template key to the list of &#8220;looped templates&#8221;. Finally it looks to see if the template&#8217;s key represents an inmplicitly-indexed variable. If so, it adds the key to the list of implicitly indexed variables.</li>
</ol>
</div></blockquote>
<p>Once the initial parsing is done, there are several steps in which it analyzes the results:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Iterating through each of the regular templates, the code looks to see if any of the templates are defined as copies of other templates, as, for example, <tt class="docutils literal"><span class="pre">inbook</span> <span class="pre">=</span> <span class="pre">incollection</span></tt>. If it finds this kind of definition, then it copies the template from the one (<tt class="docutils literal"><span class="pre">incollection</span></tt> here) to the other (<tt class="docutils literal"><span class="pre">inbook</span></tt> here).</li>
<li>The code looks at the functions defined in the <tt class="docutils literal"><span class="pre">DEFINITIONS</span></tt> section of the file. If the <tt class="docutils literal"><span class="pre">allow_scripts</span></tt> keyword is set to True, then it goes ahead and evaluates these function definitions so that they will be available during the process of formatting bibliography entries.</li>
<li>Finally, the code passes each template definition through the <tt class="docutils literal"><span class="pre">validate_templatestr()</span></tt> function to validate that the template has proper syntax.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="writing-the-bbl-file">
<h2>Writing the BBL file<a class="headerlink" href="#writing-the-bbl-file" title="Permalink to this headline">¶</a></h2>
<p>Now that all the information is available to Bibulous, we can begin writing the output BBL file. First we write a few lines to the preamble, including the <tt class="docutils literal"><span class="pre">preamble</span></tt> string obtained from the <tt class="docutils literal"><span class="pre">.bib</span></tt> database files. Then, for each citation key we found in the <tt class="docutils literal"><span class="pre">.aux</span></tt> file, we</p>
<blockquote>
<div><ol class="arabic simple">
<li>Insert any cross-reference data from any other database entries into the current one.</li>
<li>Define all of the &#8220;special variables&#8221;, including the <tt class="docutils literal"><span class="pre">sortkey</span></tt> and <tt class="docutils literal"><span class="pre">citelabel</span></tt>, as fields within the current entry.</li>
</ol>
</div></blockquote>
<p>Now that we have all of the sortkeys, we generate the <tt class="docutils literal"><span class="pre">citation_list</span></tt> &#8212; the thing we iterate through one by one to format the references in order. At each iteration, we call <tt class="docutils literal"><span class="pre">format_bibitem()</span></tt>, which does the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Write the line <tt class="docutils literal"><span class="pre">\bibitem[citelabel]{citekey}</span></tt> into the <tt class="docutils literal"><span class="pre">.bbl</span></tt> file.</li>
<li>Import the template corresponding to the current entry&#8217;s <tt class="docutils literal"><span class="pre">entrytype</span></tt>.</li>
<li>If there are any user-deefined variables (from the <tt class="docutils literal"><span class="pre">VARIABLES</span></tt> section of the file), then evaluate those variables now, so that they can be used inside the template.</li>
<li>For each option block in the template, go through and determine how to &#8220;simplify&#8221; the block. This amounts to locating the first cell in each block that has a defined value, and then replacing the <tt class="docutils literal"><span class="pre">[...]</span></tt> square-bracket-delimited block with its contents. At this point the template variables are still there; only the square brackets have been dropped.</li>
<li>Now that the optional pieces are all gone, go through each template variable and replace it with the corresponding field from the database entry.</li>
<li>If there are any nested <tt class="docutils literal"><span class="pre">\textit{...\textit{...}...}</span></tt> operators in the result, replace odd-level operators with <tt class="docutils literal"><span class="pre">\textup{...}</span></tt> in order to get the right behavior of flipping between italics and regular font.</li>
<li>If there are any nested <tt class="docutils literal"><span class="pre">\textbf{...\textbf{...}...}</span></tt> operators in the result, replace odd-level operators with <tt class="docutils literal"><span class="pre">\textup{...}</span></tt> in order to get the right behavior of flipping between bold and regular weight.</li>
<li>If there are any nested quotation marks in the result, then re-order them according to the American standard. This means having double-quotation-marks at the outermost level, single-quotation-marks inside that, then double inside that, single inside that, and so on. This is messy and difficult code, and so users should always be recommended to use the <tt class="docutils literal"><span class="pre">\enquote{...}</span></tt> LaTeX operator instead of manually-implemented quotation marks.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="name-formatting">
<h2>Name formatting<a class="headerlink" href="#name-formatting" title="Permalink to this headline">¶</a></h2>
<p>One of the more complex tasks needed for parsing BIB files is to resolve the elements of name lists (typically saved in the <tt class="docutils literal"><span class="pre">author</span></tt> and <tt class="docutils literal"><span class="pre">editor</span></tt> fields). In order to know how these should be inserted into a template, it is necessary to know which parts of a given person&#8217;s name correspond to the first name, the middle name(s), the &#8220;prefix&#8221; (or &#8220;von part&#8221;), the last name (or &#8220;surname&#8221;), and the &#8220;suffix&#8221; (such as &#8220;Jr.&#8221; or &#8220;III&#8221;). These five pieces or each person&#8217;s name are saved as a dictionary, so that a bibliography entry with five authors is represented in <tt class="docutils literal"><span class="pre">&lt;authorlist&gt;</span></tt> as a list of five dictionaries, and each dictionary having keys <tt class="docutils literal"><span class="pre">first</span></tt>, <tt class="docutils literal"><span class="pre">middle</span></tt>, <tt class="docutils literal"><span class="pre">prefix</span></tt>, <tt class="docutils literal"><span class="pre">last</span></tt>, and <tt class="docutils literal"><span class="pre">suffix</span></tt>.</p>
<p>In order to speed up parsing times, the actual mapping of the <tt class="docutils literal"><span class="pre">author</span></tt> or <tt class="docutils literal"><span class="pre">editor</span></tt> fields to <tt class="docutils literal"><span class="pre">authorlist</span></tt> or <tt class="docutils literal"><span class="pre">editorlist</span></tt> is not done until the loop over citation keys performed while writing out the BBL file. The function that product the list-of-dicts parsing result is <tt class="docutils literal"><span class="pre">namestr_to_namedict(namestr)</span></tt>.</p>
<p>The default formatting of a namelist into a string to be inserted into the template is performed by <tt class="docutils literal"><span class="pre">format_namelist()</span></tt>.</p>
<div class="section" id="create-namelist">
<h3>create_namelist()<a class="headerlink" href="#create-namelist" title="Permalink to this headline">¶</a></h3>
<p>A BibTeX &#8220;name&#8221; field can consist of three different formats of names:</p>
<blockquote>
<div><ol class="arabic simple">
<li>A space-separated list: <tt class="docutils literal"><span class="pre">[firstname</span> <span class="pre">middlenames</span> <span class="pre">suffix</span> <span class="pre">lastname]</span></tt></li>
<li>A two-element comma-separated list: <tt class="docutils literal"><span class="pre">[prefix</span> <span class="pre">lastname,</span> <span class="pre">firstname</span> <span class="pre">middlenames]</span></tt></li>
<li>A three-element comma-separated list: <tt class="docutils literal"><span class="pre">[prefix</span> <span class="pre">lastname,</span> <span class="pre">suffix,</span> <span class="pre">firstname</span> <span class="pre">middlenames]</span></tt></li>
</ol>
</div></blockquote>
<p>So, an easy way to separate these three categories is by counting the number of commas that appear. The trickiest part here is that although we can use <tt class="docutils literal"><span class="pre">and</span></tt> as a name separator, we are only allowed to do so if <tt class="docutils literal"><span class="pre">and</span></tt> occurs at the top brace level.</p>
<p>In addition, in order to make name parsing more flexible for nonstandard names, Bibulous adds two more name formats to this list:</p>
<blockquote>
<div><ol class="arabic simple" start="4">
<li>A four-element comma-separated list: <tt class="docutils literal"><span class="pre">[firstname,</span> <span class="pre">middlenames,</span> <span class="pre">prefix,</span> <span class="pre">lastname]</span></tt></li>
<li>A five-element comma-separated list: <tt class="docutils literal"><span class="pre">[firstname,</span> <span class="pre">middlenames,</span> <span class="pre">prefix,</span> <span class="pre">lastname,</span> <span class="pre">suffix]</span></tt></li>
</ol>
</div></blockquote>
<p>For each name in the field, we parse the name tokens into a dictionary. We then compile all of the dictionaries into a list, ordered by the appearance of the names in the input field.</p>
</div>
<div class="section" id="format-namelist">
<h3>format_namelist()<a class="headerlink" href="#format-namelist" title="Permalink to this headline">¶</a></h3>
<p>Given a namelist (list of dictionaries), we glue the name elements together into a single string, incorporating all of the format options selected by the user in the template file. This includes calls to <tt class="docutils literal"><span class="pre">namedict_to_formatted_namestr()</span></tt>, and to <tt class="docutils literal"><span class="pre">initialize_name()</span></tt> if converting any name tokens to initials.</p>
</div>
</div>
<div class="section" id="generating-sortkeys">
<h2>Generating sortkeys<a class="headerlink" href="#generating-sortkeys" title="Permalink to this headline">¶</a></h2>
<p>If the user&#8217;s style template file selects the citation order to be <tt class="docutils literal"><span class="pre">citenum</span></tt> or <tt class="docutils literal"><span class="pre">none</span></tt>, then creating the ordered citation list is as simple as listing the citation keys in order of their citation appearance, which was recorded as the value in the citation dictionary. If the user instead chooses the citation order to be <tt class="docutils literal"><span class="pre">citekey</span></tt>, then all that is needed is to sort the citation keys alphabetically. Similar operations follow for the various citation order options, but the difficult lies in correctly sorting in the presence of non-ASCII languages, and especially in the presence of LaTeX markup of non-ASCII names. For a citation sorting order that requires using author names, any LaTeX markup needs to be converted to its Unicode equivalent prior to sorting. Using unicode allows the sorting to be done with any input languages, and allows the sorting order to be locale-dependent.</p>
<p><tt class="docutils literal"><span class="pre">create_citation_list()</span></tt> is the highest-level function for generating the citation list. For each citation key, it calls <tt class="docutils literal"><span class="pre">generate_sortkey()</span></tt>, which is the workhorse function for including all of the various options when generating the key to use for sorting the list. A key part of the function is a call to <tt class="docutils literal"><span class="pre">purify_string()</span></tt>, which removes unnecessary LaTeX markup elements and then calls <tt class="docutils literal"><span class="pre">latex_to_utf8()</span></tt> to convert LaTeX-markup non-ASCII characters to Unicode. It is only after all of these conversions that the final sorting is performed and the sorted citation list returned.</p>
</div>
<div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>The suite of regression tests for Bibulous consist of various template definitions and database entries designed to test individual features of the program. The basic approach of the tests is as follows:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Once a change is made to the code (to fix a bug or add functionality), the developer also adds an entry to the <tt class="docutils literal"><span class="pre">test/test1.bib</span></tt> file, where the entry&#8217;s &#8220;entrytype&#8221; is named in such a way to give an indication of what the test is for. For example, the entry in the BIB file may be defined with:</p>
<div class="highlight-python"><div class="highlight"><pre>@initialize1{...
</pre></div>
</div>
<p>where the developer provides an <tt class="docutils literal"><span class="pre">author</span></tt> field in the entry where one or more authors have names which are difficult to for generating initials correctly. The developer should also include at least a 1-line comment about the purpose of the entry as well. To make everything easy to find, use the entrytype as the entry&#8217;s key as well. Thus, the example above would use:</p>
<div class="highlight-python"><div class="highlight"><pre>@initialize1{initialize1, ...
</pre></div>
</div>
</li>
<li><p class="first">If the above new entry is something which can be checked with normal options settings, then the developer should add a corresponding line in the BST file defining how that new entrytype (i.e. <tt class="docutils literal"><span class="pre">initialize1</span></tt>) should be formatted. If <em>different</em> options settings are needed, then a new BST file is needed. Only a minimalist file is generally needed: the file can, for example, contain one line defining a new entrytype and one line to define the new option setting. You can define all of the other options if you want, but these are redundant and introduce a number of unnecessary &#8220;overwriting option value...&#8221; warning messages.</p>
</li>
<li><p class="first">Next, the developer should add a line <tt class="docutils literal"><span class="pre">\citation{entrytype}</span></tt> to the AUX file where the <tt class="docutils literal"><span class="pre">entrytype</span></tt> is the key given in the new entry of the BIB file you just put in (e.g. <tt class="docutils literal"><span class="pre">initialize1</span></tt>). This is the same as the entrytype to keep everything consistent.</p>
</li>
<li><p class="first">Next, the developer needs to add two lines to the <tt class="docutils literal"><span class="pre">test1_target.bbl</span></tt> file to say what the formatted result should look like. Take a look at other lines to get a feel for how these should look, and take in consideration the form of the template just added to the BST file.</p>
</li>
<li><p class="first">Finally, run <tt class="docutils literal"><span class="pre">bibulous_test.py</span></tt> to check the result. This script will load the modified BIB and BST files and will write out several formatted BBL file <tt class="docutils literal"><span class="pre">test1.bbl</span></tt> etc. It will then run a <tt class="docutils literal"><span class="pre">diff</span></tt> program on the output file versus the target BBL file to see if there are any differences between the target and actual output BBL files.</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="generating-the-documentation">
<h2>Generating the documentation<a class="headerlink" href="#generating-the-documentation" title="Permalink to this headline">¶</a></h2>
<p>The documentation is written in reStructuredText (RST) and converted to HTML using Sphinx. Sphinx can also use LaTeX to convert the HTML files into a PDF.</p>
<p>From the bibulous repository <tt class="docutils literal"><span class="pre">doc/</span></tt> subfolder, run <tt class="docutils literal"><span class="pre">make</span> <span class="pre">html</span></tt> to generate the HTML documentation. The result can be found in <tt class="docutils literal"><span class="pre">doc/_build/html/</span></tt>, with <tt class="docutils literal"><span class="pre">index.html</span></tt> as the main file. To generate the PDF documentation, run <tt class="docutils literal"><span class="pre">make</span> <span class="pre">latexpdf</span></tt> from the <tt class="docutils literal"><span class="pre">doc/</span></tt> subfolder, with the result found at <tt class="docutils literal"><span class="pre">doc/_build/latex/Bibulous.pdf</span></tt>.</p>
<p>While the documentation is saved in the <tt class="docutils literal"><span class="pre">doc/</span></tt> folder on the main branch, this is not automatically converted into viewable, linked HTML on GitHub. To achieve that requires pushing the updated docs into the <tt class="docutils literal"><span class="pre">gh-pages</span></tt> branch. One way of doing this is the following. Make a local copy of the main branch&#8217;s <tt class="docutils literal"><span class="pre">doc/</span></tt> folder. Switch to the <tt class="docutils literal"><span class="pre">gh-pages</span></tt> branch (i.e. <tt class="docutils literal"><span class="pre">git</span> <span class="pre">checkout</span> <span class="pre">gh-pages</span></tt>) and replace everything there with the locally-copied <tt class="docutils literal"><span class="pre">doc/</span></tt> folder contents. Then update: <tt class="docutils literal"><span class="pre">git</span> <span class="pre">add</span> <span class="pre">-A</span></tt> and <tt class="docutils literal"><span class="pre">git</span> <span class="pre">push</span> <span class="pre">origin</span> <span class="pre">gh-pages</span></tt>. And switch back to the main branch, <tt class="docutils literal"><span class="pre">git</span> <span class="pre">checkout</span> <span class="pre">master</span></tt>.</p>
</div>
<div class="section" id="miscellaneous-notes">
<h2>Miscellaneous notes<a class="headerlink" href="#miscellaneous-notes" title="Permalink to this headline">¶</a></h2>
<p>The code includes two different variables, <tt class="docutils literal"><span class="pre">citekey</span></tt> and <tt class="docutils literal"><span class="pre">entrykey</span></tt> which for any given entry are always identical. So it would appear that they are redundant. But the keys in the <tt class="docutils literal"><span class="pre">citedict</span></tt> dictionary, and the keys specifying each entry in the database, belong to different sets. That is, the list of entry keys can be from every entry in the database, even entries that were not cited. The list of citation keys, however, contains only those keys that were cited, and so can be a much smaller list.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="examples.html" title="Examples"
             >next</a> |</li>
        <li class="right" >
          <a href="instructions_for_reporting_bugs.html" title="Instructions on how to report a bug to the Bibulous development team"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Bibulous developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>