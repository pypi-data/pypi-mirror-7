

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to TensorToolbox’s documentation! &mdash; TensorToolbox 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="TensorToolbox 0.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">TensorToolbox 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-tensortoolbox-s-documentation">
<h1>Welcome to TensorToolbox&#8217;s documentation!<a class="headerlink" href="#welcome-to-tensortoolbox-s-documentation" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<span class="target" id="module-TensorToolbox"></span><p>&#64;author: Daniele Bigoni (<a class="reference external" href="mailto:dabi&#37;&#52;&#48;imm&#46;dtu&#46;dk">dabi<span>&#64;</span>imm<span>&#46;</span>dtu<span>&#46;</span>dk</a>)</p>
<p>TensorToolbox is the collection of tools for Tensor decomposition and arithmetic</p>
<p>&#64;copyright: 2014 The Technical University of Denmark</p>
<span class="target" id="module-TensorToolbox.core"></span><dl class="function">
<dt id="TensorToolbox.core.idxunfold">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">idxunfold</tt><big>(</big><em>dlist</em>, <em>idxs</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.idxunfold" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index corresponding to the unfolded (flat) version of a tensor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dlist</strong> (<em>list,int</em>) &#8211; list of integers containing the dimensions of the tensor</li>
<li><strong>idxs</strong> (<em>list,int</em>) &#8211; tensor index</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">index for the flatten tensor</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.idxfold">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">idxfold</tt><big>(</big><em>dlist</em>, <em>idx</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.idxfold" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index corresponding to the folded version of a tensor from the flatten version</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dlist</strong> (<em>list,int</em>) &#8211; list of integers containing the dimensions of the tensor</li>
<li><strong>idx</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; tensor flatten index</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of int &#8211; the index for the folded version</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body"><p class="first last">this routine can be used to get the indexes of a TTmat from indices of a matkron (matrix obtained using np.kron): (i,j) in N^d x N^d -&gt; ((i_1,..,i_d),(j_1,..,j_d)) in (N x .. x N) x (N x .. x N)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.matkron_to_mattensor">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">matkron_to_mattensor</tt><big>(</big><em>A</em>, <em>nrows</em>, <em>ncols</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.matkron_to_mattensor" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reshapes a 2D-matrix obtained as kron product of len(nrows)==len(ncols) matrices, to a len(nrows)-tensor that can be used as input for the TTmat constructor. Applies the Van Loan-Pitsianis reordering of the matrix elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>ndarray</em>) &#8211; 2-dimensional matrix</li>
<li><strong>nrows,ncols</strong> (<em>list,int</em>) &#8211; number of rows and number of columns of the original matrices used for the kron product</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.mat_to_tt_idxs">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">mat_to_tt_idxs</tt><big>(</big><em>rowidxs</em>, <em>colidxs</em>, <em>nrows</em>, <em>ncols</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.mat_to_tt_idxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping from the multidimensional matrix indexing to the tt matrix indexing</p>
<p>(rowidxs,colidxs) = ((i_1,...,i_d),(j_1,...,j_d)) -&gt; (l_1,...,l_d)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rowidxs,colidxs</strong> (<em>tuple,int</em>) &#8211; list of row and column indicies. len(rowidxs) == len(colidxs)</li>
<li><strong>nrows,ncols</strong> (<em>tuple,int</em>) &#8211; dimensions of matrices</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuple,int indices in the tt format</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.tt_to_mat_idxs">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">tt_to_mat_idxs</tt><big>(</big><em>idxs</em>, <em>nrows</em>, <em>ncols</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.tt_to_mat_idxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping from the tt matrix indexing to the multidimensional matrix indexing</p>
<blockquote>
<div>(l_1,...,l_d) -&gt; (rowidxs,colidxs) = ((i_1,...,i_d),(j_1,...,j_d))</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>idxs</strong> (<em>tuple,int</em>) &#8211; list of tt indicies. len(idxs) == len(nrows) == len(ncols)</li>
<li><strong>nrows,ncols</strong> (<em>tuple,int</em>) &#8211; dimensions of matrices</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rowidxs,colidxs) = ((i_1,..,i_d),(j_1,..,j_d)) indices in the matrix indexing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.maxvol">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">maxvol</tt><big>(</big><em>A</em>, <em>delta=0.01</em>, <em>maxit=100</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.maxvol" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the rxr submatrix of maximal volume in A(nxr), n&gt;=r</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>ndarray</em>) &#8211; two dimensional array with (n,r)=shape(A) where r&lt;=n</li>
<li><strong>delta</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; stopping cirterion [default=1e-2]</li>
<li><strong>maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations [default=100]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><tt class="docutils literal"><span class="pre">(I,AsqInv,it)</span></tt> where <tt class="docutils literal"><span class="pre">I</span></tt> is the list or rows of A forming the matrix with maximal volume, <tt class="docutils literal"><span class="pre">AsqInv</span></tt> is the inverse of the matrix with maximal volume and <tt class="docutils literal"><span class="pre">it</span></tt> is the number of iterations to convergence</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first">raise exception if the dimension of A is r&gt;n or if A is singular</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">ConvergenceError if convergence is not reached in maxit iterations</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.lowrankapprox">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">lowrankapprox</tt><big>(</big><em>A</em>, <em>r</em>, <em>Jinit=None</em>, <em>delta=1e-05</em>, <em>maxit=100</em>, <em>maxvoleps=0.01</em>, <em>maxvolit=100</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.lowrankapprox" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a matrix A nxm, find the maximum volume submatrix with rank r&lt;n,m.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>ndarray</em>) &#8211; two dimensional array with dimension nxm</li>
<li><strong>r</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; rank of the maxvol submatrix</li>
<li><strong>Jinit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of integers containing the r starting columns. If <tt class="docutils literal"><span class="pre">None</span></tt> then pick them randomly.</li>
<li><strong>delta</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; accuracy parameter</li>
<li><strong>maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations in the lowrankapprox routine</li>
<li><strong>maxvoleps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; accuracy parameter for each usage of the maxvol algorithm</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Parma int maxvolit:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">maximum number of iterations in the maxvol routine</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><tt class="docutils literal"><span class="pre">(I,J,AsqInv,it)</span></tt> where <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt> are the list of rows and columns of A that compose the submatrix of maximal volume, <tt class="docutils literal"><span class="pre">AsqInv</span></tt> is the inverse of such matrix and <tt class="docutils literal"><span class="pre">it</span></tt> is the number of iteration to convergence</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.ttcross_store">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">ttcross_store</tt><big>(</big><em>path</em>, <em>TW</em>, <em>TTapp</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.ttcross_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to store the computed values of a TTcross approximation. Usually needed when the single function evaluation is demanding or when we need to restart TTcross later on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; path pointing to the location where to store the data</li>
<li><strong>TW</strong> (<em>TensorWrapper</em>) &#8211; Tensor wrapper used to build the ttcross approximation. TW.get_data(), TW.get_X() and TW.get_params() will be stored.</li>
<li><strong>TTapp</strong> (<em>TTvec</em>) &#8211; TTcross approximation. TTapp.ttcross.Jinit will be stored.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.object_store">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">object_store</tt><big>(</big><em>path</em>, <em>obj</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.object_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to store any object in the library.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; path pointing to the location where to store the data</li>
<li><strong>obj</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><em>object</em></a>) &#8211; a pickleable object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="TensorToolbox.core.TensorWrapper">
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">TensorWrapper</tt><big>(</big><em>f</em>, <em>X</em>, <em>params=None</em>, <em>twtype='array'</em>, <em>data=None</em>, <em>dtype=&lt;type 'object'&gt;</em>, <em>store_file=''</em>, <em>store_object=None</em>, <em>empty=False</em>, <em>maxprocs=None</em>, <em>marshal_f=True</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.TensorWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A tensor wrapper is a data structure W that given a multi-dimensional scalar function f(X,params), and a set of coordinates {{x1}_i1,{x2}_i2,..,{xd}_id} indexed by the multi index {i1,..,id}, let you access f(x1_i1,..,xd_id) by W[i1,..,id]. The function evaluations are performed &#8220;as needed&#8221; and stored for future accesses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> &#8211; multi-dimensional scalar function of type f(x,params), x being a list.</li>
<li><strong>X</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of arrays with coordinates for each dimension</li>
<li><strong>params</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><em>tuple</em></a>) &#8211; parameters to be passed to function f</li>
<li><strong>twtype</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; &#8216;array&#8217; values are stored whenever computed, &#8216;view&#8217; values are never stored and function f is always called</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.python.org/library/stdtypes.html#dict" title="(in Python v2.7)"><em>dict</em></a>) &#8211; initialization data of the Tensor Wrapper (already computed entries)</li>
<li><strong>range_shape</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; specify the shape of the objects in the tensor wrapper</li>
<li><strong>empty</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Creates an instance without initializing it. All the content can be initialized using the <tt class="docutils literal"><span class="pre">setstate()</span></tt> function.</li>
<li><strong>maxprocs</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of processors to be used in the function evaluation (MPI)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="TensorToolbox.core.TensorWrapper.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#TensorToolbox.core.TensorWrapper.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.TensorWrapper.get_ndim">
<tt class="descname">get_ndim</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.TensorWrapper.get_ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns the number of dimensions of the original tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.TensorWrapper.get_shape">
<tt class="descname">get_shape</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.TensorWrapper.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns the shape of the of the original tensor</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorToolbox.core.TTvec">
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">TTvec</tt><big>(</big><em>A</em>, <em>eps=1e-10</em>, <em>method='svd'</em>, <em>lr_r=None</em>, <em>lr_fix_rank=False</em>, <em>lr_Jinit=None</em>, <em>lr_delta=0.0001</em>, <em>lr_maxit=100</em>, <em>mv_eps=1e-06</em>, <em>mv_maxit=100</em>, <em>lr_store_location=''</em>, <em>store_object=None</em>, <em>store_freq=1</em>, <em>generate=True</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.TTvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of multidimensional tensor in Tensor Train format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>Candecomp,ndarray,TT</em>) &#8211; Available input formats are Candecomp, full tensor in numpy.ndarray, Tensor Train structure (list of cores)</li>
<li><strong>generate</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether to perform the construction or just initialize the object</li>
<li><strong>method</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; &#8216;svd&#8217; use singular value decomposition to construct the TT representation, &#8216;ttcross&#8217; use low rank skeleton approximation to construct the TT representation.</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-10] For method==&#8217;svd&#8217;: precision with which to approximate the input tensor. For method==&#8217;ttcross&#8217;: TT-rounding tolerance for rank-check.</li>
<li><strong>lr_r</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of integer ranks of different cores. If <tt class="docutils literal"><span class="pre">None</span></tt> then the incremental TTcross approach will be used. (method==&#8217;ttcross&#8217;)</li>
<li><strong>lr_fix_rank</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; determines whether the rank is allowed to be increased (method==&#8217;ttcross&#8217;)</li>
<li><strong>lr_Jinit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of list of integers containing the r starting columns in the lowrankapprox routine for each core. If <tt class="docutils literal"><span class="pre">None</span></tt> then pick them randomly. (method==&#8217;ttcross&#8217;)</li>
<li><strong>lr_delta</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; accuracy parameter in the TT-cross routine (method==&#8217;ttcross&#8217;). It is the relative error in Frobenious norm between two successive iterations.</li>
<li><strong>lr_maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations in the lowrankapprox routine (method==&#8217;ttcross&#8217;)</li>
<li><strong>mv_eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; accuracy parameter for each usage of the maxvol algorithm (method==&#8217;ttcross&#8217;)</li>
<li><strong>mv_maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations in the maxvol routine (method==&#8217;ttcross&#8217;)</li>
<li><strong>fix_rank</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Whether the rank is allowed to increase</li>
<li><strong>lr_store_location</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Store computed values during construction on the specified file path. The stored values are ttcross_Jinit and the values used in the TensorWrapper. This permits a restart from already computed values. If empty string nothing is done. (method==&#8217;ttcross&#8217;)</li>
<li><strong>store_object</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Object to be stored (default are the tensor wrapper and ttcross_Jinit)</li>
<li><strong>store_freq</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; storage frequency. <tt class="docutils literal"><span class="pre">store_freq==1</span></tt> stores intermediate values at every iteration. The program stores data every <tt class="docutils literal"><span class="pre">store_freq</span></tt> internal iterations. If <tt class="docutils literal"><span class="pre">store_object</span></tt> is a SpectralTensorTrain, then <tt class="docutils literal"><span class="pre">store_freq</span></tt> determines the number of seconds every which to store values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="TensorToolbox.core.TTvec.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>idxs</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.TTvec.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.TTvec.interpolate">
<tt class="descname">interpolate</tt><big>(</big><em>Ms=None</em>, <em>eps=1e-08</em>, <em>is_sparse=None</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.TTvec.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates the values of the TTvec at arbitrary points, using the interpolation matrices <a href="#id1"><span class="problematic" id="id2">``</span></a>Ms&#8217;&#8216;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Ms</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of interpolation matrices for each dimension. Ms[i].shape[1] == self.shape()[i]</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; tolerance with which to perform the rounding after interpolation</li>
<li><strong>is_sparse</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; is_sparse[i] is a bool indicating whether Ms[i] is sparse or not. If &#8216;None&#8217; all matrices are non sparse</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">TTvec interpolation</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">TTvec</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">DABISpectralToolbox</span> <span class="kn">import</span> <span class="n">DABISpectral1D</span> <span class="k">as</span> <span class="n">S1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ms</span> <span class="o">=</span> <span class="p">[</span> <span class="n">S1D</span><span class="o">.</span><span class="n">LinearInterpolationMatrix</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">XI</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_sparse</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span><span class="o">*</span><span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TTapproxI</span> <span class="o">=</span> <span class="n">TTapprox</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Ms</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span><span class="n">is_sparse</span><span class="o">=</span><span class="n">is_sparse</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.TTvec.outer_ttcross">
<tt class="descname">outer_ttcross</tt><big>(</big><em>eps</em>, <em>lr_r</em>, <em>lr_Jinit</em>, <em>lr_delta</em>, <em>lr_maxit</em>, <em>mv_eps</em>, <em>mv_maxit</em>, <em>fix_rank=False</em>, <em>lr_store_location=''</em>, <em>store_object=None</em>, <em>store_freq=1</em>, <em>multidim_point=None</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.TTvec.outer_ttcross" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a TT representation of A using TT cross. This routine manage the outer loops for incremental ttcross or passes everything to ttcross if lr_r are specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; tolerance with which to perform the TT-rounding and check the rank accuracy</li>
<li><strong>lr_r</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of upper ranks (A.ndim)</li>
<li><strong>lr_Jinit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list (A.ndim-1) of lists of init indices</li>
<li><strong>lr_delta</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; TT-cross accuracy</li>
<li><strong>lr_maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations for ttcross</li>
<li><strong>mv_eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; MaxVol accuracy</li>
<li><strong>mv_maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations for MaxVol</li>
<li><strong>fix_rank</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Whether the rank is allowed to increase</li>
<li><strong>lr_store_location</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Store computed values during construction on the specified file path. The stored values are ttcross_Jinit and the values used in the TensorWrapper. This permits a restart from already computed values. If empty string nothing is done. (method==&#8217;ttcross&#8217;)</li>
<li><strong>store_object</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Object to be stored (default are the tensor wrapper and ttcross_Jinit)</li>
<li><strong>store_freq</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; storage frequency. <tt class="docutils literal"><span class="pre">store_freq==1</span></tt> stores intermediate values at every iteration. The program stores data every <tt class="docutils literal"><span class="pre">store_freq</span></tt> internal iterations. If <tt class="docutils literal"><span class="pre">store_object</span></tt> is a SpectralTensorTrain, then <tt class="docutils literal"><span class="pre">store_freq</span></tt> determines the number of seconds every which to store values.</li>
<li><strong>multidim_point</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; If the object A returns a multidimensional array, then this can be used to define which point to apply ttcross to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.TTvec.project">
<tt class="descname">project</tt><big>(</big><em>Vs=None</em>, <em>Ws=None</em>, <em>eps=1e-08</em>, <em>is_sparse=None</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.TTvec.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the TTvec onto a set of basis provided, using the Generalized Vandermonde matrices <a href="#id3"><span class="problematic" id="id4">``</span></a>Vs&#8217;&#8217; and weights <a href="#id5"><span class="problematic" id="id6">``</span></a>Ws&#8217;&#8216;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Vs</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of generalized Vandermonde matrices for each dimension. Ms[i].shape[1] == self.shape()[i]</li>
<li><strong>Ws</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of weights for each dimension. Ws[i].shape[0] == self.shape()[i]</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; tolerance with which to perform the rounding after interpolation</li>
<li><strong>is_sparse</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; is_sparse[i] is a bool indicating whether Ms[i] is sparse or not. If &#8216;None&#8217; all matrices are non sparse</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">TTvec containting the Fourier coefficients</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">TTvec</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">DABISpectralToolbox</span> <span class="kn">import</span> <span class="n">DABISpectral1D</span> <span class="k">as</span> <span class="n">S1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">S1D</span><span class="o">.</span><span class="n">Poly1D</span><span class="p">(</span><span class="n">S1D</span><span class="o">.</span><span class="n">JACOBI</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">S1D</span><span class="o">.</span><span class="n">Quadrature</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">S1D</span><span class="o">.</span><span class="n">GAUSS</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">*</span><span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Compute here the TTapprox at points X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TTapprox</span> <span class="o">=</span> <span class="n">TTvec</span><span class="p">(</span><span class="o">....</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Project</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Vs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">P</span><span class="o">.</span><span class="n">GradVandermonde1D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="p">]</span> <span class="o">*</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_sparse</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TTfourier</span> <span class="o">=</span> <span class="n">TTapprox</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">Vs</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span><span class="n">is_sparse</span><span class="o">=</span><span class="n">is_sparse</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.TTvec.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.TTvec.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the shape of the tensor represented</p>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.TTvec.ttcross">
<tt class="descname">ttcross</tt><big>(</big><em>A</em>, <em>lr_r</em>, <em>lr_Jinit</em>, <em>lr_delta</em>, <em>lr_maxit</em>, <em>mv_eps</em>, <em>mv_maxit</em>, <em>store_init=True</em>, <em>lr_store_location=''</em>, <em>store_object=None</em>, <em>store_freq=1</em>, <em>multidim_point=None</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.TTvec.ttcross" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a TT representation of A using TT cross</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>nd.array/TensorWrapper</em>) &#8211; </li>
<li><strong>lr_r</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of upper ranks (A.ndim)</li>
<li><strong>lr_Jinit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list (A.ndim-1) of lists of init indices</li>
<li><strong>lr_store_location</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Store computed values during construction on the specified file path. The stored values are ttcross_Jinit and the values used in the TensorWrapper. This permits a restart from already computed values. If empty string nothing is done. (method==&#8217;ttcross&#8217;)</li>
<li><strong>store_object</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Object to be stored (default are the tensor wrapper and ttcross_Jinit)</li>
<li><strong>store_freq</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; storage frequency. <tt class="docutils literal"><span class="pre">store_freq==1</span></tt> stores intermediate values at every iteration. The program stores data every <tt class="docutils literal"><span class="pre">store_freq</span></tt> internal iterations. If <tt class="docutils literal"><span class="pre">store_object</span></tt> is a SpectralTensorTrain, then <tt class="docutils literal"><span class="pre">store_freq</span></tt> determines the number of seconds every which to store values.</li>
<li><strong>multidim_point</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; If the object A returns a multidimensional array, then this can be used to define which point to apply ttcross to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.randvec">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">randvec</tt><big>(</big><em>d</em>, <em>N</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rank-1 multidimensional random vector in Tensor Train format</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>d (int): number of dimensions
N (int or list): If int then uniform sizes are used for all the dimensions, if list of int then len(N) == d and each dimension will use different size</dd>
<dt>Returns:</dt>
<dd>TTvec The rank-1 multidim random vector in Tensor Train format</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.zerosvec">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">zerosvec</tt><big>(</big><em>d</em>, <em>N</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.zerosvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rank-1 multidimensional vector of zeros in Tensor Train format</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>d (int): number of dimensions
N (int or list): If int then uniform sizes are used for all the dimensions, if list of int then len(N) == d and each dimension will use different size</dd>
<dt>Returns:</dt>
<dd>TTvec The rank-1 multidim vector of zeros in Tensor Train format</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="TensorToolbox.core.TTmat">
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">TTmat</tt><big>(</big><em>A</em>, <em>nrows</em>, <em>ncols</em>, <em>eps=1e-08</em>, <em>is_sparse=None</em>, <em>sparse_ranks=None</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.TTmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of multidimensional matrix in Tensor Train format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>Candecomp,ndarray,TT</em>) &#8211; Available input formats are Candecomp, full tensor in numpy.ndarray, Tensor Train structure (list of cores), list of sparse matrices of sizes (r_{i-1}*r_{i}*nrows x ncols) (used for fast dot product - limited support for other functionalities)</li>
<li><strong>nrows</strong> (<em>list,int</em>) &#8211; If int then the row size will be the same in all dimensions, if list then len(nrows) == len(self.TT) (numer of cores) and row size will change for each dimension.</li>
<li><strong>ncols</strong> (<em>list,int</em>) &#8211; If int then the column size will be the same in all dimensions, if list then len(ncols) == len(self.TT) (numer of cores) and column size will change for each dimension.</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-8] precision with which to approximate the input tensor</li>
<li><strong>is_sparse</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; [default == False] if True it uses sparsity to accelerate some computations</li>
<li><strong>sparse_ranks</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; [default==None] mandatory argument when A is a list of sparse matrices. It contains integers listing the TT-ranks of the matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the method __getitem__ is not overwritten, thus the indices used to access the tensor refer to the flatten versions of the matrices composing the matrix tensor.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.eye">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">eye</tt><big>(</big><em>d</em>, <em>N</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the multidimensional identity operator in Tensor Train format</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>d (int): number of dimensions
N (int or list): If int then uniform sizes are used for all the dimensions, if list of int then len(N) == d and each dimension will use different size</dd>
<dt>Returns:</dt>
<dd>TTmat The multidim identity matrix in Tensor Train format</dd>
<dt>Note:</dt>
<dd>TODO: improve construction avoiding passage through Candecomp</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.randmat">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">randmat</tt><big>(</big><em>d</em>, <em>nrows</em>, <em>ncols</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.randmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rank-1 multidimensional random matrix in Tensor Train format</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>d (int): number of dimensions
nrows (int or list): If int then uniform sizes are used for all the dimensions, if list of int then len(nrows) == d and each dimension will use different size
ncols (int or list): If int then uniform sizes are used for all the dimensions, if list of int then len(ncols) == d and each dimension will use different size</dd>
<dt>Returns:</dt>
<dd>TTmat The rank-1 multidim random matrix in Tensor Train format</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="TensorToolbox.core.QTTvec">
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">QTTvec</tt><big>(</big><em>A</em>, <em>base</em>, <em>shape=None</em>, <em>eps=1e-10</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.QTTvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of multidimensional tensor in Quantics Tensor Train format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>ndarray,TT</em>) &#8211; Available input formats are full tensor in numpy.ndarray, Tensor Train structure (list of cores)</li>
<li><strong>base</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; folding base for QTT representation</li>
<li><strong>shape</strong> (<em>list,int</em>) &#8211; if QTTvec is constructed from a list of cores, shape must be provided to describe the original shape of the vector</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-8] precision with which to approximate the input tensor</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="TensorToolbox.core.QTTvec.fullshape">
<tt class="descname">fullshape</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.QTTvec.fullshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the shape of the folded tensor</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorToolbox.core.QTTzerosvec">
<tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">QTTzerosvec</tt><big>(</big><em>d</em>, <em>N</em>, <em>base</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.QTTzerosvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rank-1 multidimensional vector of zeros in Quantics Tensor Train format</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>d (int): number of dimensions
N (int or list): If int then uniform sizes are used for all the dimensions, if list of int then len(N) == d and each dimension will use different size
base (int): QTT base</dd>
<dt>Returns:</dt>
<dd>QTTvec The rank-1 multidim vector of zeros in Tensor Train format</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="TensorToolbox.core.QTTmat">
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">QTTmat</tt><big>(</big><em>A</em>, <em>base</em>, <em>nrows</em>, <em>ncols</em>, <em>eps=1e-08</em>, <em>is_sparse=False</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.QTTmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of multidimensional matrix in Quantics Tensor Train format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>ndarray,TT</em>) &#8211; Available input formats are full tensor in numpy.ndarray, Tensor Train structure (list of cores). If input is ndarray, then it must be in mattensor format (see aux.py)</li>
<li><strong>base</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; folding base for QTT representation</li>
<li><strong>nrows</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; If int then the row size will be the same in all dimensions, if list then len(nrows) == len(self.TT) (numer of cores) and row size will change for each dimension.</li>
<li><strong>ncols</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; If int then the column size will be the same in all dimensions, if list then len(ncols) == len(self.TT) (numer of cores) and column size will change for each dimension.</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-8] precision with which to approximate the input tensor</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="TensorToolbox.core.QTTmat.get_fullncols">
<tt class="descname">get_fullncols</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.QTTmat.get_fullncols" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of cols of the unfolded matrices</p>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.QTTmat.get_fullnrows">
<tt class="descname">get_fullnrows</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.QTTmat.get_fullnrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of rows of the unfolded matrices</p>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.QTTmat.get_ncols">
<tt class="descname">get_ncols</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.QTTmat.get_ncols" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of cols of the folded matrices</p>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.QTTmat.get_nrows">
<tt class="descname">get_nrows</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.QTTmat.get_nrows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of rows of the folded matrices</p>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.QTTmat.ndims">
<tt class="descname">ndims</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.QTTmat.ndims" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of dimensions of the tensor space</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorToolbox.core.STT">
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">STT</tt><big>(</big><em>f</em>, <em>grids</em>, <em>params</em>, <em>range_dim=0</em>, <em>marshal_f=True</em>, <em>surrogateONOFF=False</em>, <em>surrogate_type=None</em>, <em>orders=None</em>, <em>orderAdapt=None</em>, <em>eps=0.0001</em>, <em>lr_r=None</em>, <em>lr_fix_rank=False</em>, <em>lr_Jinit=None</em>, <em>lr_delta=0.0001</em>, <em>lr_maxit=100</em>, <em>mv_eps=1e-06</em>, <em>mv_maxit=100</em>, <em>stt_store_location=''</em>, <em>stt_store_overwrite=False</em>, <em>stt_store_freq=0</em>, <em>maxprocs=None</em>, <em>empty=False</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.STT" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor of the Spectral Tensor Train approximation. Given a function <tt class="docutils literal"><span class="pre">f(x,theta,params):(Is,</span> <span class="pre">It)</span> <span class="pre">-&gt;</span> <span class="pre">R</span></tt>
with <tt class="docutils literal"><span class="pre">dim(Is)=n</span></tt> and <tt class="docutils literal"><span class="pre">dim(It)=d</span></tt>, construct an approximation of <tt class="docutils literal"><span class="pre">g(theta,params):</span> <span class="pre">It</span> <span class="pre">-&gt;</span> <span class="pre">h_t(Is)</span></tt>. For example <tt class="docutils literal"><span class="pre">Is</span></tt> could be the discretization of a spatial dimension, and <tt class="docutils literal"><span class="pre">It</span></tt> some parameter space, so that <tt class="docutils literal"><span class="pre">f(x,theta,params)</span></tt> describes a scalar field depending some parameters that vary in <tt class="docutils literal"><span class="pre">It</span></tt>. The <tt class="docutils literal"><span class="pre">params</span></tt> in the definition of <tt class="docutils literal"><span class="pre">f</span></tt> can be constants used by the function or othere objects that must be passed to the function definition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> (<em>function</em>) &#8211; multidimensional function to be approximated with format <tt class="docutils literal"><span class="pre">f(x,theta,params)</span></tt></li>
<li><strong>grids</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; this is a list with <tt class="docutils literal"><span class="pre">len(grids)=dim(Is)+dim(It)</span></tt> which can contain:
a) 1-dimensional numpy.array of points discretizing the i-th dimension,
b) a tuple <tt class="docutils literal"><span class="pre">(PolyType,QuadType,PolyParams,span)</span></tt> where <tt class="docutils literal"><span class="pre">PolyType</span></tt> is one of the polynomials available in <tt class="xref py py-mod docutils literal"><span class="pre">SpectralToolbox.Spectral1D</span></tt> and <tt class="docutils literal"><span class="pre">QuadType</span></tt> is one of the quadrature rules associated to the selected polynomial and <tt class="docutils literal"><span class="pre">PolyParams</span></tt> are the parameters for the selected polynomial. <tt class="docutils literal"><span class="pre">span</span></tt> is a tuple defining the left and right end for dimension i (Example: <tt class="docutils literal"><span class="pre">(-3,np.inf)</span></tt>)
c) a tuple <tt class="docutils literal"><span class="pre">(QuadType,span)</span></tt> where <tt class="docutils literal"><span class="pre">QuadType</span></tt> is one of the quadrature rules available in <tt class="xref py py-mod docutils literal"><span class="pre">SpectralToolbox.Spectral1D</span></tt> without the selection of a particular polynomial type, and <tt class="docutils literal"><span class="pre">span</span></tt> is defined as above.</li>
<li><strong>params</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><em>object</em></a>) &#8211; any list of parameters to be passed to the function <tt class="docutils literal"><span class="pre">f</span></tt></li>
<li><strong>range_dim</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; define the dimension of the spatial dimension <tt class="docutils literal"><span class="pre">Is</span></tt>. For functionals <tt class="docutils literal"><span class="pre">f(theta,params)</span></tt>, <tt class="docutils literal"><span class="pre">dim(Is)=0</span></tt>. For scalar fileds in 3D, <tt class="docutils literal"><span class="pre">dim(Is)=3</span></tt>.</li>
<li><strong>marshal_f</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether to marshal the function f or not. For MPI support, the function f must be marshalable (does this adverb exists??).</li>
<li><strong>surrogateONOFF</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether to construct the surrogate or not</li>
<li><strong>surrogate_type</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; whether the surrogate will be an interpolating surrogate (<tt class="docutils literal"><span class="pre">TensorTrain.LINEAR_INTERPOLATION</span></tt> or <tt class="docutils literal"><span class="pre">TensorTrain.LAGRANGE_INTERPOLATION</span></tt>) or a projection surrogate (<tt class="docutils literal"><span class="pre">TensorTrain.PROJECTION</span></tt>)</li>
<li><strong>orders</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; polynomial orders for each dimension if <tt class="docutils literal"><span class="pre">TensorTrain.PROJECTION</span></tt> is used. If <tt class="docutils literal"><span class="pre">orderAdapt==True</span></tt> then the <tt class="docutils literal"><span class="pre">orders</span></tt> are starting orders that can be increased as needed by the construction algorithm. If this parameter is not provided but <tt class="docutils literal"><span class="pre">orderAdapt==True</span></tt>, then the starting order is 1 for all the dimensions.</li>
<li><strong>orderAdapt</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether the order is fixed or not.</li>
<li><strong>stt_store_location</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; path to a file where function evaluations can be stored and used in order to restart the construction.</li>
<li><strong>stt_store_overwrite</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether to overwrite pre-existing files</li>
<li><strong>stt_store_freq</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; storage frequency. Determines every how many seconds the state is stored. <tt class="docutils literal"><span class="pre">stt_store_freq==0</span></tt> stores every time it is possible.</li>
<li><strong>empty</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Creates an instance without initializing it. All the content can be initialized using the <tt class="docutils literal"><span class="pre">setstate()</span></tt> function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a description of the remaining parameters see <a class="reference internal" href="#TensorToolbox.core.TTvec" title="TensorToolbox.core.TTvec"><tt class="xref py py-class docutils literal"><span class="pre">TTvec</span></tt></a>.</p>
</div>
<dl class="method">
<dt id="TensorToolbox.core.STT.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.STT.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.STT.__call__">
<tt class="descname">__call__</tt><big>(</big><em>x</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.STT.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the surrogate on points <tt class="docutils literal"><span class="pre">x</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>np.ndarray</em>) &#8211; 1 or 2 dimensional array of points in the parameter space where to evaluate the function. In 2 dimensions, each row is an entry, i.e. <tt class="docutils literal"><span class="pre">x.shape[1]</span> <span class="pre">==</span> <span class="pre">self.param_dim</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">an array with dimension equal to the space dimension (<tt class="docutils literal"><span class="pre">range_dim</span></tt>) plus one. If <tt class="docutils literal"><span class="pre">A</span></tt> is the returned vector and <tt class="docutils literal"><span class="pre">range_dim=2</span></tt>, then <tt class="docutils literal"><span class="pre">A[:,:,i]</span></tt> is the value of the surrogate for <tt class="docutils literal"><span class="pre">x[i,:]</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorToolbox.core.STT.integrate">
<tt class="descname">integrate</tt><big>(</big><big>)</big><a class="headerlink" href="#TensorToolbox.core.STT.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral of the approximated function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an array with dimension equal to the space dimension (<tt class="docutils literal"><span class="pre">range_dim</span></tt>), containing the value of the integral.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorToolbox.core.Candecomp">
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">Candecomp</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#TensorToolbox.core.Candecomp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">TTvec</tt><big>(</big><em>A</em>, <em>eps=1e-10</em>, <em>method='svd'</em>, <em>lr_r=None</em>, <em>lr_fix_rank=False</em>, <em>lr_Jinit=None</em>, <em>lr_delta=0.0001</em>, <em>lr_maxit=100</em>, <em>mv_eps=1e-06</em>, <em>mv_maxit=100</em>, <em>lr_store_location=''</em>, <em>store_object=None</em>, <em>store_freq=1</em>, <em>generate=True</em><big>)</big></dt>
<dd><p>Constructor of multidimensional tensor in Tensor Train format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>Candecomp,ndarray,TT</em>) &#8211; Available input formats are Candecomp, full tensor in numpy.ndarray, Tensor Train structure (list of cores)</li>
<li><strong>generate</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether to perform the construction or just initialize the object</li>
<li><strong>method</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; &#8216;svd&#8217; use singular value decomposition to construct the TT representation, &#8216;ttcross&#8217; use low rank skeleton approximation to construct the TT representation.</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-10] For method==&#8217;svd&#8217;: precision with which to approximate the input tensor. For method==&#8217;ttcross&#8217;: TT-rounding tolerance for rank-check.</li>
<li><strong>lr_r</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of integer ranks of different cores. If <tt class="docutils literal"><span class="pre">None</span></tt> then the incremental TTcross approach will be used. (method==&#8217;ttcross&#8217;)</li>
<li><strong>lr_fix_rank</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; determines whether the rank is allowed to be increased (method==&#8217;ttcross&#8217;)</li>
<li><strong>lr_Jinit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of list of integers containing the r starting columns in the lowrankapprox routine for each core. If <tt class="docutils literal"><span class="pre">None</span></tt> then pick them randomly. (method==&#8217;ttcross&#8217;)</li>
<li><strong>lr_delta</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; accuracy parameter in the TT-cross routine (method==&#8217;ttcross&#8217;). It is the relative error in Frobenious norm between two successive iterations.</li>
<li><strong>lr_maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations in the lowrankapprox routine (method==&#8217;ttcross&#8217;)</li>
<li><strong>mv_eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; accuracy parameter for each usage of the maxvol algorithm (method==&#8217;ttcross&#8217;)</li>
<li><strong>mv_maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations in the maxvol routine (method==&#8217;ttcross&#8217;)</li>
<li><strong>fix_rank</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Whether the rank is allowed to increase</li>
<li><strong>lr_store_location</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Store computed values during construction on the specified file path. The stored values are ttcross_Jinit and the values used in the TensorWrapper. This permits a restart from already computed values. If empty string nothing is done. (method==&#8217;ttcross&#8217;)</li>
<li><strong>store_object</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Object to be stored (default are the tensor wrapper and ttcross_Jinit)</li>
<li><strong>store_freq</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; storage frequency. <tt class="docutils literal"><span class="pre">store_freq==1</span></tt> stores intermediate values at every iteration. The program stores data every <tt class="docutils literal"><span class="pre">store_freq</span></tt> internal iterations. If <tt class="docutils literal"><span class="pre">store_object</span></tt> is a SpectralTensorTrain, then <tt class="docutils literal"><span class="pre">store_freq</span></tt> determines the number of seconds every which to store values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt>
<tt class="descname">__getitem__</tt><big>(</big><em>idxs</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">interpolate</tt><big>(</big><em>Ms=None</em>, <em>eps=1e-08</em>, <em>is_sparse=None</em><big>)</big></dt>
<dd><p>Interpolates the values of the TTvec at arbitrary points, using the interpolation matrices <a href="#id7"><span class="problematic" id="id8">``</span></a>Ms&#8217;&#8216;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Ms</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of interpolation matrices for each dimension. Ms[i].shape[1] == self.shape()[i]</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; tolerance with which to perform the rounding after interpolation</li>
<li><strong>is_sparse</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; is_sparse[i] is a bool indicating whether Ms[i] is sparse or not. If &#8216;None&#8217; all matrices are non sparse</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">TTvec interpolation</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">TTvec</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">DABISpectralToolbox</span> <span class="kn">import</span> <span class="n">DABISpectral1D</span> <span class="k">as</span> <span class="n">S1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ms</span> <span class="o">=</span> <span class="p">[</span> <span class="n">S1D</span><span class="o">.</span><span class="n">LinearInterpolationMatrix</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">XI</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_sparse</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span><span class="o">*</span><span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TTapproxI</span> <span class="o">=</span> <span class="n">TTapprox</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Ms</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span><span class="n">is_sparse</span><span class="o">=</span><span class="n">is_sparse</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">outer_ttcross</tt><big>(</big><em>eps</em>, <em>lr_r</em>, <em>lr_Jinit</em>, <em>lr_delta</em>, <em>lr_maxit</em>, <em>mv_eps</em>, <em>mv_maxit</em>, <em>fix_rank=False</em>, <em>lr_store_location=''</em>, <em>store_object=None</em>, <em>store_freq=1</em>, <em>multidim_point=None</em><big>)</big></dt>
<dd><p>Construct a TT representation of A using TT cross. This routine manage the outer loops for incremental ttcross or passes everything to ttcross if lr_r are specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; tolerance with which to perform the TT-rounding and check the rank accuracy</li>
<li><strong>lr_r</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of upper ranks (A.ndim)</li>
<li><strong>lr_Jinit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list (A.ndim-1) of lists of init indices</li>
<li><strong>lr_delta</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; TT-cross accuracy</li>
<li><strong>lr_maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations for ttcross</li>
<li><strong>mv_eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; MaxVol accuracy</li>
<li><strong>mv_maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; maximum number of iterations for MaxVol</li>
<li><strong>fix_rank</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Whether the rank is allowed to increase</li>
<li><strong>lr_store_location</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Store computed values during construction on the specified file path. The stored values are ttcross_Jinit and the values used in the TensorWrapper. This permits a restart from already computed values. If empty string nothing is done. (method==&#8217;ttcross&#8217;)</li>
<li><strong>store_object</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Object to be stored (default are the tensor wrapper and ttcross_Jinit)</li>
<li><strong>store_freq</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; storage frequency. <tt class="docutils literal"><span class="pre">store_freq==1</span></tt> stores intermediate values at every iteration. The program stores data every <tt class="docutils literal"><span class="pre">store_freq</span></tt> internal iterations. If <tt class="docutils literal"><span class="pre">store_object</span></tt> is a SpectralTensorTrain, then <tt class="docutils literal"><span class="pre">store_freq</span></tt> determines the number of seconds every which to store values.</li>
<li><strong>multidim_point</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; If the object A returns a multidimensional array, then this can be used to define which point to apply ttcross to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">project</tt><big>(</big><em>Vs=None</em>, <em>Ws=None</em>, <em>eps=1e-08</em>, <em>is_sparse=None</em><big>)</big></dt>
<dd><p>Project the TTvec onto a set of basis provided, using the Generalized Vandermonde matrices <a href="#id9"><span class="problematic" id="id10">``</span></a>Vs&#8217;&#8217; and weights <a href="#id11"><span class="problematic" id="id12">``</span></a>Ws&#8217;&#8216;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Vs</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of generalized Vandermonde matrices for each dimension. Ms[i].shape[1] == self.shape()[i]</li>
<li><strong>Ws</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of weights for each dimension. Ws[i].shape[0] == self.shape()[i]</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; tolerance with which to perform the rounding after interpolation</li>
<li><strong>is_sparse</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; is_sparse[i] is a bool indicating whether Ms[i] is sparse or not. If &#8216;None&#8217; all matrices are non sparse</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">TTvec containting the Fourier coefficients</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">TTvec</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">DABISpectralToolbox</span> <span class="kn">import</span> <span class="n">DABISpectral1D</span> <span class="k">as</span> <span class="n">S1D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">S1D</span><span class="o">.</span><span class="n">Poly1D</span><span class="p">(</span><span class="n">S1D</span><span class="o">.</span><span class="n">JACOBI</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">S1D</span><span class="o">.</span><span class="n">Quadrature</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">S1D</span><span class="o">.</span><span class="n">GAUSS</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">*</span><span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Compute here the TTapprox at points X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TTapprox</span> <span class="o">=</span> <span class="n">TTvec</span><span class="p">(</span><span class="o">....</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Project</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Vs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">P</span><span class="o">.</span><span class="n">GradVandermonde1D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="p">]</span> <span class="o">*</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_sparse</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TTfourier</span> <span class="o">=</span> <span class="n">TTapprox</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">Vs</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span><span class="n">is_sparse</span><span class="o">=</span><span class="n">is_sparse</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">shape</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the shape of the tensor represented</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">ttcross</tt><big>(</big><em>A</em>, <em>lr_r</em>, <em>lr_Jinit</em>, <em>lr_delta</em>, <em>lr_maxit</em>, <em>mv_eps</em>, <em>mv_maxit</em>, <em>store_init=True</em>, <em>lr_store_location=''</em>, <em>store_object=None</em>, <em>store_freq=1</em>, <em>multidim_point=None</em><big>)</big></dt>
<dd><p>Construct a TT representation of A using TT cross</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>nd.array/TensorWrapper</em>) &#8211; </li>
<li><strong>lr_r</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list of upper ranks (A.ndim)</li>
<li><strong>lr_Jinit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; list (A.ndim-1) of lists of init indices</li>
<li><strong>lr_store_location</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Store computed values during construction on the specified file path. The stored values are ttcross_Jinit and the values used in the TensorWrapper. This permits a restart from already computed values. If empty string nothing is done. (method==&#8217;ttcross&#8217;)</li>
<li><strong>store_object</strong> (<a class="reference external" href="http://docs.python.org/library/string.html#string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Object to be stored (default are the tensor wrapper and ttcross_Jinit)</li>
<li><strong>store_freq</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; storage frequency. <tt class="docutils literal"><span class="pre">store_freq==1</span></tt> stores intermediate values at every iteration. The program stores data every <tt class="docutils literal"><span class="pre">store_freq</span></tt> internal iterations. If <tt class="docutils literal"><span class="pre">store_object</span></tt> is a SpectralTensorTrain, then <tt class="docutils literal"><span class="pre">store_freq</span></tt> determines the number of seconds every which to store values.</li>
<li><strong>multidim_point</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; If the object A returns a multidimensional array, then this can be used to define which point to apply ttcross to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">TTmat</tt><big>(</big><em>A</em>, <em>nrows</em>, <em>ncols</em>, <em>eps=1e-08</em>, <em>is_sparse=None</em>, <em>sparse_ranks=None</em><big>)</big></dt>
<dd><p>Constructor of multidimensional matrix in Tensor Train format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> (<em>Candecomp,ndarray,TT</em>) &#8211; Available input formats are Candecomp, full tensor in numpy.ndarray, Tensor Train structure (list of cores), list of sparse matrices of sizes (r_{i-1}*r_{i}*nrows x ncols) (used for fast dot product - limited support for other functionalities)</li>
<li><strong>nrows</strong> (<em>list,int</em>) &#8211; If int then the row size will be the same in all dimensions, if list then len(nrows) == len(self.TT) (numer of cores) and row size will change for each dimension.</li>
<li><strong>ncols</strong> (<em>list,int</em>) &#8211; If int then the column size will be the same in all dimensions, if list then len(ncols) == len(self.TT) (numer of cores) and column size will change for each dimension.</li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-8] precision with which to approximate the input tensor</li>
<li><strong>is_sparse</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; [default == False] if True it uses sparsity to accelerate some computations</li>
<li><strong>sparse_ranks</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; [default==None] mandatory argument when A is a list of sparse matrices. It contains integers listing the TT-ranks of the matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the method __getitem__ is not overwritten, thus the indices used to access the tensor refer to the flatten versions of the matrices composing the matrix tensor.</p>
</div>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">TensorToolbox.core.</tt><tt class="descname">STT</tt><big>(</big><em>f</em>, <em>grids</em>, <em>params</em>, <em>range_dim=0</em>, <em>marshal_f=True</em>, <em>surrogateONOFF=False</em>, <em>surrogate_type=None</em>, <em>orders=None</em>, <em>orderAdapt=None</em>, <em>eps=0.0001</em>, <em>lr_r=None</em>, <em>lr_fix_rank=False</em>, <em>lr_Jinit=None</em>, <em>lr_delta=0.0001</em>, <em>lr_maxit=100</em>, <em>mv_eps=1e-06</em>, <em>mv_maxit=100</em>, <em>stt_store_location=''</em>, <em>stt_store_overwrite=False</em>, <em>stt_store_freq=0</em>, <em>maxprocs=None</em>, <em>empty=False</em><big>)</big></dt>
<dd><p>Constructor of the Spectral Tensor Train approximation. Given a function <tt class="docutils literal"><span class="pre">f(x,theta,params):(Is,</span> <span class="pre">It)</span> <span class="pre">-&gt;</span> <span class="pre">R</span></tt>
with <tt class="docutils literal"><span class="pre">dim(Is)=n</span></tt> and <tt class="docutils literal"><span class="pre">dim(It)=d</span></tt>, construct an approximation of <tt class="docutils literal"><span class="pre">g(theta,params):</span> <span class="pre">It</span> <span class="pre">-&gt;</span> <span class="pre">h_t(Is)</span></tt>. For example <tt class="docutils literal"><span class="pre">Is</span></tt> could be the discretization of a spatial dimension, and <tt class="docutils literal"><span class="pre">It</span></tt> some parameter space, so that <tt class="docutils literal"><span class="pre">f(x,theta,params)</span></tt> describes a scalar field depending some parameters that vary in <tt class="docutils literal"><span class="pre">It</span></tt>. The <tt class="docutils literal"><span class="pre">params</span></tt> in the definition of <tt class="docutils literal"><span class="pre">f</span></tt> can be constants used by the function or othere objects that must be passed to the function definition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> (<em>function</em>) &#8211; multidimensional function to be approximated with format <tt class="docutils literal"><span class="pre">f(x,theta,params)</span></tt></li>
<li><strong>grids</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; this is a list with <tt class="docutils literal"><span class="pre">len(grids)=dim(Is)+dim(It)</span></tt> which can contain:
a) 1-dimensional numpy.array of points discretizing the i-th dimension,
b) a tuple <tt class="docutils literal"><span class="pre">(PolyType,QuadType,PolyParams,span)</span></tt> where <tt class="docutils literal"><span class="pre">PolyType</span></tt> is one of the polynomials available in <tt class="xref py py-mod docutils literal"><span class="pre">SpectralToolbox.Spectral1D</span></tt> and <tt class="docutils literal"><span class="pre">QuadType</span></tt> is one of the quadrature rules associated to the selected polynomial and <tt class="docutils literal"><span class="pre">PolyParams</span></tt> are the parameters for the selected polynomial. <tt class="docutils literal"><span class="pre">span</span></tt> is a tuple defining the left and right end for dimension i (Example: <tt class="docutils literal"><span class="pre">(-3,np.inf)</span></tt>)
c) a tuple <tt class="docutils literal"><span class="pre">(QuadType,span)</span></tt> where <tt class="docutils literal"><span class="pre">QuadType</span></tt> is one of the quadrature rules available in <tt class="xref py py-mod docutils literal"><span class="pre">SpectralToolbox.Spectral1D</span></tt> without the selection of a particular polynomial type, and <tt class="docutils literal"><span class="pre">span</span></tt> is defined as above.</li>
<li><strong>params</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><em>object</em></a>) &#8211; any list of parameters to be passed to the function <tt class="docutils literal"><span class="pre">f</span></tt></li>
<li><strong>range_dim</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; define the dimension of the spatial dimension <tt class="docutils literal"><span class="pre">Is</span></tt>. For functionals <tt class="docutils literal"><span class="pre">f(theta,params)</span></tt>, <tt class="docutils literal"><span class="pre">dim(Is)=0</span></tt>. For scalar fileds in 3D, <tt class="docutils literal"><span class="pre">dim(Is)=3</span></tt>.</li>
<li><strong>marshal_f</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether to marshal the function f or not. For MPI support, the function f must be marshalable (does this adverb exists??).</li>
<li><strong>surrogateONOFF</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether to construct the surrogate or not</li>
<li><strong>surrogate_type</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; whether the surrogate will be an interpolating surrogate (<tt class="docutils literal"><span class="pre">TensorTrain.LINEAR_INTERPOLATION</span></tt> or <tt class="docutils literal"><span class="pre">TensorTrain.LAGRANGE_INTERPOLATION</span></tt>) or a projection surrogate (<tt class="docutils literal"><span class="pre">TensorTrain.PROJECTION</span></tt>)</li>
<li><strong>orders</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; polynomial orders for each dimension if <tt class="docutils literal"><span class="pre">TensorTrain.PROJECTION</span></tt> is used. If <tt class="docutils literal"><span class="pre">orderAdapt==True</span></tt> then the <tt class="docutils literal"><span class="pre">orders</span></tt> are starting orders that can be increased as needed by the construction algorithm. If this parameter is not provided but <tt class="docutils literal"><span class="pre">orderAdapt==True</span></tt>, then the starting order is 1 for all the dimensions.</li>
<li><strong>orderAdapt</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether the order is fixed or not.</li>
<li><strong>stt_store_location</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#str" title="(in Python v2.7)"><em>str</em></a>) &#8211; path to a file where function evaluations can be stored and used in order to restart the construction.</li>
<li><strong>stt_store_overwrite</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; whether to overwrite pre-existing files</li>
<li><strong>stt_store_freq</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; storage frequency. Determines every how many seconds the state is stored. <tt class="docutils literal"><span class="pre">stt_store_freq==0</span></tt> stores every time it is possible.</li>
<li><strong>empty</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; Creates an instance without initializing it. All the content can be initialized using the <tt class="docutils literal"><span class="pre">setstate()</span></tt> function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a description of the remaining parameters see <a class="reference internal" href="#TensorToolbox.core.TTvec" title="TensorToolbox.core.TTvec"><tt class="xref py py-class docutils literal"><span class="pre">TTvec</span></tt></a>.</p>
</div>
<dl class="method">
<dt>
<tt class="descname">__getitem__</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">__call__</tt><big>(</big><em>x</em>, <em>verbose=False</em><big>)</big></dt>
<dd><p>Evaluate the surrogate on points <tt class="docutils literal"><span class="pre">x</span></tt></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>np.ndarray</em>) &#8211; 1 or 2 dimensional array of points in the parameter space where to evaluate the function. In 2 dimensions, each row is an entry, i.e. <tt class="docutils literal"><span class="pre">x.shape[1]</span> <span class="pre">==</span> <span class="pre">self.param_dim</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">an array with dimension equal to the space dimension (<tt class="docutils literal"><span class="pre">range_dim</span></tt>) plus one. If <tt class="docutils literal"><span class="pre">A</span></tt> is the returned vector and <tt class="docutils literal"><span class="pre">range_dim=2</span></tt>, then <tt class="docutils literal"><span class="pre">A[:,:,i]</span></tt> is the value of the surrogate for <tt class="docutils literal"><span class="pre">x[i,:]</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">integrate</tt><big>(</big><big>)</big></dt>
<dd><p>Compute the integral of the approximated function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an array with dimension equal to the space dimension (<tt class="docutils literal"><span class="pre">range_dim</span></tt>), containing the value of the integral.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-TensorToolbox.multilinalg"></span><dl class="function">
<dt id="TensorToolbox.multilinalg.mul">
<tt class="descclassname">TensorToolbox.multilinalg.</tt><tt class="descname">mul</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#TensorToolbox.multilinalg.mul" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>If A,B are TTvec/TTmat -&gt; Hadamard product of two TT tensors</li>
<li>If A TTvec/TTmat and B scalar -&gt; multiplication by scalar</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.multilinalg.kron">
<tt class="descclassname">TensorToolbox.multilinalg.</tt><tt class="descname">kron</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#TensorToolbox.multilinalg.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kron product between two tensors in TT format.
Complexity: O(1)</p>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.multilinalg.contraction">
<tt class="descclassname">TensorToolbox.multilinalg.</tt><tt class="descname">contraction</tt><big>(</big><em>A</em>, <em>U</em><big>)</big><a class="headerlink" href="#TensorToolbox.multilinalg.contraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Multidimensional contraction of tensor A with vectors in list U.
Complexity: O(dnr^2)</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">W</span> <span class="pre">=</span> <span class="pre">contraction(A,U)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; Tensor in some form</li>
<li><strong>U</strong> &#8211; list of vectors of dimensions n_k for performing the contraction</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.multilinalg.norm">
<tt class="descclassname">TensorToolbox.multilinalg.</tt><tt class="descname">norm</tt><big>(</big><em>A</em>, <em>ord='fro'</em>, <em>round_eps=1e-10</em>, <em>eps=0.0001</em>, <em>maxit=1000</em>, <em>pow_guess=None</em>, <em>info=False</em><big>)</big><a class="headerlink" href="#TensorToolbox.multilinalg.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of tensor A</p>
<dl class="docutils">
<dt>Syntax:</dt>
<dd><tt class="docutils literal"><span class="pre">w</span> <span class="pre">=</span> <span class="pre">norm(A,[ord])</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>A</strong> &#8211; Tensor in some form</li>
<li><strong>ord</strong> &#8211; Specifies the type of norm that needs to be computed. Available norms are
* Frobenius norm: &#8216;fro&#8217;</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.multilinalg.sd">
<tt class="descclassname">TensorToolbox.multilinalg.</tt><tt class="descname">sd</tt><big>(</big><em>A</em>, <em>b</em>, <em>x0=None</em>, <em>eps=1e-08</em>, <em>maxit=1000</em>, <em>eps_round=1e-10</em>, <em>ext_info=False</em><big>)</big><a class="headerlink" href="#TensorToolbox.multilinalg.sd" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the system <span class="math">\(Ax=b\)</span> using the Steepest Descent method in Tensor Train format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>TTmat</em>) &#8211; Tensor train matrix</li>
<li><strong>b</strong> (<em>TTvec/ndarray</em>) &#8211; Right hand side</li>
<li><strong>x0</strong> (<em>TTvec/ndarray</em>) &#8211; [default == <a class="reference internal" href="#TensorToolbox.core.zerosvec" title="TensorToolbox.core.zerosvec"><tt class="xref py py-func docutils literal"><span class="pre">TensorToolbox.core.zerosvec()</span></tt></a>] initial guess of solution <tt class="docutils literal"><span class="pre">x</span></tt></li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-8] stop criteria</li>
<li><strong>maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; [default == 1000] maximum number of iterations</li>
<li><strong>eps_round</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-10] accuracy for Tensor Train rounding operations</li>
<li><strong>ext_info</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; [default == False] whehter of not to have additional info returned</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>tuple <tt class="xref py py-data docutils literal"><span class="pre">(x,conv,info)</span></tt></p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">x</span></tt> (TTvec): solution of the linear system if converged or last iterate if not converged</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">conv</span></tt> (bool): True -&gt; converged, False -&gt; Not converged / Zero Inner Product exeception</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">info</span></tt> (dict): <tt class="docutils literal"><span class="pre">iter</span></tt> -&gt; total number of iterations; <tt class="docutils literal"><span class="pre">r</span></tt> -&gt; last residual in TT format; <tt class="docutils literal"><span class="pre">res</span></tt> -&gt; residual history</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.multilinalg.cg">
<tt class="descclassname">TensorToolbox.multilinalg.</tt><tt class="descname">cg</tt><big>(</big><em>A</em>, <em>b</em>, <em>x0=None</em>, <em>eps=1e-08</em>, <em>maxit=1000</em>, <em>eps_round=1e-10</em>, <em>ext_info=False</em><big>)</big><a class="headerlink" href="#TensorToolbox.multilinalg.cg" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the system <span class="math">\(Ax=b\)</span> using the Conjugate Gradient method in Tensor Train format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>TTmat</em>) &#8211; Tensor train matrix</li>
<li><strong>b</strong> (<em>TTvec/ndarray</em>) &#8211; Right hand side</li>
<li><strong>x0</strong> (<em>TTvec/ndarray</em>) &#8211; [default == <a class="reference internal" href="#TensorToolbox.core.zerosvec" title="TensorToolbox.core.zerosvec"><tt class="xref py py-func docutils literal"><span class="pre">TensorToolbox.core.zerosvec()</span></tt></a>] initial guess of solution <tt class="docutils literal"><span class="pre">x</span></tt></li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-8] stop criteria for Bi-CGSTAB iterations</li>
<li><strong>maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; [default == 1000] maximum number of iterations for Bi-CGSTAB</li>
<li><strong>eps_round</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-10] accuracy for Tensor Train rounding operations</li>
<li><strong>ext_info</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; [default == False] whehter of not to have additional info returned</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>tuple <tt class="xref py py-data docutils literal"><span class="pre">(x,conv,info)</span></tt></p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">x</span></tt> (TTvec): solution of the linear system if converged or last iterate if not converged</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">conv</span></tt> (bool): True -&gt; converged, False -&gt; Not converged / Zero Inner Product exeception</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">info</span></tt> (dict): <tt class="docutils literal"><span class="pre">iter</span></tt> -&gt; total number of iterations; <tt class="docutils literal"><span class="pre">r</span></tt> -&gt; last residual in TT format; <tt class="docutils literal"><span class="pre">res</span></tt> -&gt; residual history</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.multilinalg.bicgstab">
<tt class="descclassname">TensorToolbox.multilinalg.</tt><tt class="descname">bicgstab</tt><big>(</big><em>A</em>, <em>b</em>, <em>x0=None</em>, <em>eps=1e-08</em>, <em>maxit=1000</em>, <em>eps_round=1e-10</em>, <em>ext_info=False</em><big>)</big><a class="headerlink" href="#TensorToolbox.multilinalg.bicgstab" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the system <span class="math">\(Ax=b\)</span> using the Bi-Conjugate Gradient Stabilized method using Tensor Train format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>TTmat</em>) &#8211; Tensor train matrix</li>
<li><strong>b</strong> (<em>TTvec</em>) &#8211; Right hand side</li>
<li><strong>x0</strong> (<em>TTvec</em>) &#8211; [default == <a class="reference internal" href="#TensorToolbox.core.zerosvec" title="TensorToolbox.core.zerosvec"><tt class="xref py py-func docutils literal"><span class="pre">TensorToolbox.core.zerosvec()</span></tt></a>] initial guess of solution <tt class="docutils literal"><span class="pre">x</span></tt></li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-8] stop criteria for Bi-CGSTAB iterations</li>
<li><strong>maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; [default == 1000] maximum number of iterations for Bi-CGSTAB</li>
<li><strong>eps_round</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-10] accuracy for Tensor Train rounding operations</li>
<li><strong>ext_info</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; [default == False] whehter of not to have additional info returned</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>tuple <tt class="xref py py-data docutils literal"><span class="pre">(x,conv,info)</span></tt></p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">x</span></tt> (TTvec): solution of the linear system if converged or last iterate if not converged</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">conv</span></tt> (bool): True -&gt; converged, False -&gt; Not converged / Zero Inner Product exeception</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">info</span></tt> (dict): <tt class="docutils literal"><span class="pre">iter</span></tt> -&gt; total number of iterations; <tt class="docutils literal"><span class="pre">r</span></tt> -&gt; last residual in TT format; <tt class="docutils literal"><span class="pre">rho</span></tt> -&gt; last value of dot(r0,r) must be bigger than np.spacing(1); <tt class="docutils literal"><span class="pre">r0v</span></tt> -&gt; last value of dot(r0,v) must be bigger than np.spacing(1)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorToolbox.multilinalg.gmres">
<tt class="descclassname">TensorToolbox.multilinalg.</tt><tt class="descname">gmres</tt><big>(</big><em>A</em>, <em>b</em>, <em>x0=None</em>, <em>eps=1e-08</em>, <em>maxit=1000</em>, <em>restart=1000</em>, <em>eps_round=1e-10</em>, <em>ext_info=False</em><big>)</big><a class="headerlink" href="#TensorToolbox.multilinalg.gmres" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the system <span class="math">\(Ax=b\)</span> using the Generalized Minimum Residual method with Modified Gram-Schmidt iterations using Tensor Train format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>TTmat</em>) &#8211; Tensor train matrix</li>
<li><strong>b</strong> (<em>TTvec</em>) &#8211; Right hand side</li>
<li><strong>x0</strong> (<em>TTvec</em>) &#8211; [default == <a class="reference internal" href="#TensorToolbox.core.zerosvec" title="TensorToolbox.core.zerosvec"><tt class="xref py py-func docutils literal"><span class="pre">TensorToolbox.core.zerosvec()</span></tt></a>] initial guess of solution <tt class="docutils literal"><span class="pre">x</span></tt></li>
<li><strong>eps</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-8] stop criteria for GMRES iterations</li>
<li><strong>maxit</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; [default == 1000] maximum number of iterations for GMRES</li>
<li><strong>restart</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; [default == 1000] restart constant for GMRES (nothing is implemented to retain information, i.e. Hessemberg and Krylov space are reset)</li>
<li><strong>eps_round</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; [default == 1e-10] accuracy for Tensor Train rounding operations</li>
<li><strong>ext_info</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; [default == False] whehter of not to have additional info returned</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>tuple <tt class="xref py py-data docutils literal"><span class="pre">(x,conv,info)</span></tt></p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">x</span></tt> (TTvec): solution of the linear system if converged or last iterate if not converged</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">conv</span></tt> (bool): True -&gt; converged, False -&gt; Not converged / Zero Inner Product exeception</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">info</span></tt> (dict): <tt class="docutils literal"><span class="pre">iter</span></tt> -&gt; total number of iterations; <tt class="docutils literal"><span class="pre">TT_r</span></tt> -&gt; last residual in TT format; <tt class="docutils literal"><span class="pre">res</span></tt> -&gt; norm of last residual; <tt class="docutils literal"><span class="pre">err</span></tt> -&gt; residual history per iteration</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note :</th><td class="field-body"><p class="first last">not optimized for symmetric A</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to TensorToolbox&#8217;s documentation!</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">TensorToolbox 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Daniele Bigoni.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>