#  _________________________________________________________________________
#
#  Coopr: A COmmon Optimization Python Repository
#  Copyright (c) 2008 Sandia Corporation.
#  This software is distributed under the BSD License.
#  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
#  the U.S. Government retains certain rights in this software.
#  For more information, see the Coopr README.txt file.
#  _________________________________________________________________________


import os
import os.path
import re
import re
from coopr.sucasa.mapfile_parser import parse_mapfile


class MILPSymbInfo(object):

    basic_sets = ["integers","reals","literals"]

    def __init__(self,name="unknown"):
        """ Constructor. """
        self.verbose=False
        self.symbol={}
        self.superset={}
        self.basic_superset={}
        self.stype={}
        self.dimen={}
        self.slist=[]
        self.literals = []
        self.name=name
        #
        # A regular expression used to match valid set names
        self.re_word = re.compile('[a-zA-Z][a-zA-Z_0-9\.]*$')
        #
        # temp_sets[setname] is the name of a temporary set for 'setname''
        self.temp_sets = {}
        #
        # orig_sets[setname] is the name of the original set for temporary set 'setname'
        self.orig_sets = {}
        #
        # The index of the next valid temporary set (set#)
        self.tempid=0

    def read_mapfile(self,filename=None,debug=0):
        """ Read a mapfile and initialize this class """
        if filename is None:
            filename = self.name+".map"
        if not os.path.exists(filename):
            raise IOError("File does not exist: "+filename)
        #
        # Call PLY parser
        #
        parse_mapfile(self, filename=filename, debug=debug)

    def write_mapfile(self, filename=None,quiet=False):
        """ Write a mapfile from the data in this class """
        if filename is None:
            filename = self.name+".map"
        OUTPUT = open(filename,"w")
        basename = os.path.basename(filename)
        OUTPUT.write("#\n")
        OUTPUT.write("# Mapfile "+basename+" generated by the\n")
        OUTPUT.write("#    SUCASA MILPSymbInfo class.\n")
        OUTPUT.write("#\n")
        literal_superset = []
        unknown_dimen = []
        for name in self.slist:
            tmp = self.stype[name]+" "+name
            if len(self.symbol[name])>0:
                tmp += "["
                flag=False
                for val in self.symbol[name]:
                    if flag:
                        tmp += ","
                    flag=True
                    tmp += val
                tmp += "]"
            if self.stype[name] == "set":
                if type(self.superset[name]) in (list,tuple):
                    tmp += " within "+self.superset[name][0]
                    for superset in self.superset[name][1:]:
                        tmp += " cross "+superset
                else:
                    tmp += " within "+str(self.superset[name])
                if self.dimen[name] == 0:
                    unknown_dimen.append(name)
                    tmp += " dimen 1"
                else:
                    tmp += " dimen "+str(self.dimen[name])
            elif self.stype[name] == "param":
                if type(self.superset[name]) is list:
                    if len(self.superset[name]) == 1:
                        tmp += " in "+self.superset[name][0]
                    else:
                        tmp += " in "+self.superset[name][0]
                        for i in range(1,len(self.superset[name])):
                            tmp += " cross "+self.superset[name][i]
                else:
                    tmp += " in "+self.superset[name]
            if self.superset[name] == "literals":
                literal_superset.append(name)
            tmp += ";"
            OUTPUT.write(tmp+'\n')
        OUTPUT.close()
        if not quiet and len(literal_superset) > 0:     #pragma:nocover
            print("      WARNING: superset type unknown for the following symbols, so")
            print("        they are interpreted as symbolic literals:")
            for id in literal_superset:
                print("          "+str(id))
        if not quiet and len(unknown_dimen) > 0:        #pragma:nocover
            print("      WARNING: dimen unknown for the following symbols, so")
            print("        they are assumed to have dimen 1:")
            for id in unknown_dimen:
                print("          "+str(id))
        return filename

    def __str__(self):
        """ Generate a string representation """
        ans = ""
        for name in self.slist:
            ans += str(self.stype[name]) + " " + name + " " +  str(self.symbol[name])+" "+str(self.superset[name])+" "+str(self.dimen[name])+"\n"
        return ans

    def print_symbols(self):
        """ Print the string representation """
        print(str(self))

    def add_symbol(self,stype,name,index=None,superset=None,tmpsets=False,dimen=1,quiet=False):
        """
        Add a symbol.
        stype - the type of the symbol
        name - the name of the symbol
        index - a tuple of index sets
        dimen - the dimension of the data that this symbol points to
        """
        if name in self.symbol:
            raise IOError("Symbol '"+name+"' has already been defined!")
        if not index is None:
            if tmpsets:
                #
                # We create temporary names for sets that aren't already
                # specified
                #
                tmp=[]
                for id in index:
                    if not id in self.basic_sets and not id in self.symbol:
                        if re.match(self.re_word,id):
                            self.add_symbol("set",id)
                            tmp.append(id)
                        elif id in self.temp_sets:
                            tmp.append(self.temp_sets[id])
                        else:
                            newname = "set"+str(self.tempid)
                            if not quiet:           #pragma:nocover
                                print("      WARNING: creating set '"+newname+"' for set string '"+id+"'")
                            self.add_symbol("set",newname)
                            tmp.append(newname)
                            self.temp_sets[id]=newname
                            self.orig_sets[newname]=id
                            self.tempid += 1
                    else:
                        tmp.append(id)
                index=tmp
            else:
                #
                # We verify that all set names have been specified
                #
                for id in index:
                    if not id in self.basic_sets and not id in self.symbol:
                        raise IOError("Bad index set name '"+id+"' for symbol '"+name+"'")
        if not superset is None:
            if not type(superset) is list:
                if not superset in self.basic_sets and not superset in self.symbol:
                    raise IOError("Bad superset set name '"+superset+"' for symbol "+name)
            else:
                for supersetitem in superset:
                    if not supersetitem in self.basic_sets and not supersetitem in self.symbol:
                        raise IOError("Bad superset set name '"+supersetitem+"' for symbol "+name)

        #
        # SUCASA defaults
        #
        if superset is None and stype == "set":
            superset="literals"
        elif superset is None and stype == "param":
            superset="reals"

        if superset is not None:
            if type(superset) in [list,tuple]:
                key = tuple(superset)
            else:
                key = (superset,)
            if key in self.basic_superset:
                self.basic_superset[(name,)]= self.basic_superset[key]
            else:
                self.basic_superset[(name,)] = key
        if index is None:
            self.symbol[name]=[]
        else:
            self.symbol[name]=index
        self.superset[name]=superset
        self.stype[name]=stype
        self.dimen[name]=int(dimen)
        self.slist.append(name)

    def generate_milp_symbol_code(self):
        """ Generate the MILP code """
        #
        # Write Info Header
        #
        OUTPUT = open(self.name+"_info.h","w")
        OUTPUT.write("//\n")
        OUTPUT.write("// " + self.name + "_info.h\n")
        OUTPUT.write("//\n")
        OUTPUT.write("// Automatically generated by MILPSymbInfo::setup_ilp_symbols\n")
        OUTPUT.write("\n")
        OUTPUT.write("//\n")
        OUTPUT.write("\n")
        OUTPUT.write("#ifndef " + self.name + "_info_h\n")
        OUTPUT.write("#define " + self.name + "_info_h\n")
        OUTPUT.write("\n")
        OUTPUT.write("#include <set>\n")
        OUTPUT.write("#include <map>\n")
        OUTPUT.write("#include <pico/MILPSymbInfo.h>\n")
        OUTPUT.write("#include <pico/MILPSymbol.h>\n")
        OUTPUT.write("#include <utilib/BasicArray.h>\n")
        OUTPUT.write("\n")
        OUTPUT.write("namespace sucasa_" + self.name + " {\n")
        OUTPUT.write("\n")
        OUTPUT.write("using utilib::CharString;\n")
        OUTPUT.write("using pico::MILPSymbol0;\n")
        OUTPUT.write("using pico::MILPSymbol1;\n")
        OUTPUT.write("using pico::MILPSymbol2;\n")
        OUTPUT.write("using pico::MILPSymbol3;\n")
        OUTPUT.write("//using pico::MILPSymbol4;\n")
        OUTPUT.write("//using pico::MILPSymbol5;\n")
        OUTPUT.write("//using pico::MILPSymbol6;\n")
        OUTPUT.write("//using pico::MILPSymbol7;\n")
        OUTPUT.write("\n")
        OUTPUT.write("class Info;\n")
        OUTPUT.write("\n")

        OUTPUT.write("\n")
        #
        # Define SymbInfo class
        #
        OUTPUT.write("///\n")
        OUTPUT.write("class SymbInfo\n")
        OUTPUT.write("{\n")
        OUTPUT.write("public:\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  typedef pico::MILPSymbol::tuple_t tuple_t;\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  SymbInfo(Info* _info=0) : infoptr(_info) {}\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  Info* infoptr;\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  Info& info() {return *infoptr;}\n")
        OUTPUT.write("};\n")
        OUTPUT.write("\n")
        OUTPUT.write("\n")

        OUTPUT.write("\n")
        #
        # Define MILPSymbFunctions class
        #
        OUTPUT.write("class MILPSymbFunctions : public SymbInfo\n")
        OUTPUT.write("{\n")
        OUTPUT.write("public:\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  MILPSymbFunctions(Info* _info=NULL) : SymbInfo(_info) {}\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  void test_varmap(utilib::BasicArray<double>& primal, utilib::BasicArray<double>& dual);\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  void register_var_values(utilib::BasicArray<double>& vec);\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  void register_dual_values(utilib::BasicArray<double>& vec);\n")
        OUTPUT.write("  ///\n")
        #
        # typedefs for symbol iterators
        #
        OUTPUT.write("  typedef std::set<SymbInfo::tuple_t >::iterator symbol_iterator;\n")
        OUTPUT.write("  typedef std::set<SymbInfo::tuple_t >::const_iterator symbol_const_iterator;\n")
        OUTPUT.write("  typedef std::set<size_t>::iterator set_iterator;\n")
        OUTPUT.write("  typedef std::set<size_t>::const_iterator set_const_iterator;\n")
        OUTPUT.write("\n")
        #
        # Print symbol functions
        #
        for name in self.symbol:
            type = self.stype[name]
            #
            # CharString& foo_name()
            #
            OUTPUT.write("  const CharString& "+name+"_name() const;\n")
            #
            # size_t foo(int& arg1, double& arg2) const;
            # size_t bar() const;
            #
            if type == "set":
                if self.dimen[name] <= 1:
                    OUTPUT.write("  const std::set<size_t>& "+name+"("+self._set_args(self.symbol[name])+") const;\n")
                else:
                    OUTPUT.write("  const std::set<SymbInfo::tuple_t>& "+name+"("+self._set_args(self.symbol[name])+") const;    // dimen="+str(self.dimen[name]))
            elif type == "param":
                OUTPUT.write("  const "+self._index_str(name)+"& "+name+"("+self._set_args(self.symbol[name])+") const;\n")
                OUTPUT.write("  const "+self._index_str(name)+"& "+name+"_value("+self._set_args(self.symbol[name])+") const;\n")
                OUTPUT.write("  size_t "+name+"_index("+self._set_args(self.symbol[name])+") const;\n")
            elif type == "var":
                OUTPUT.write("  double "+name+"("+self._set_args(self.symbol[name])+") const;\n")
                OUTPUT.write("  double "+name+"_value("+self._set_args(self.symbol[name])+") const;\n")
                OUTPUT.write("  size_t "+name+"_index("+self._set_args(self.symbol[name])+") const;\n")
            else:
                OUTPUT.write("  size_t "+name+"("+self._set_args(self.symbol[name])+") const;\n")
                OUTPUT.write("  double "+name+"_value("+self._set_args(self.symbol[name])+") const;\n")
                OUTPUT.write("  size_t "+name+"_index("+self._set_args(self.symbol[name])+") const;\n")
            #
            # const std::string& foo_value(size_t)
            # const double& foo_value(size_t)
            #
            if (type == "set" and self.dimen[name] <= 1):
                OUTPUT.write("  const "+self._index_str(name)+"& "+name+"_value(const size_t& idx) const;\n")
            if type == "set" and self.dimen[name] > 1:
                OUTPUT.write("  utilib::Any "+name+"_value(const SymbInfo::tuple_t& tuple) const;\n")
            #
            # Functions for indexed data
            #
            if len(self.symbol[name]) > 0:
                #
                # size_t foo(const SymbInfo::tuple_t& tuple) const;
                #
                if type == "set":
                    if self.dimen[name] <= 1:
                        OUTPUT.write("  const std::set<size_t>& "+name+"(const SymbInfo::tuple_t& tuple) const;\n")
                    else:
                        OUTPUT.write("  const std::set<SymbInfo::tuple_t>& "+name+"(const SymbInfo::tuple_t& tuple) const;\n")
                elif type == "param":
                    OUTPUT.write("  const "+self._index_str(name)+"& "+name+"(const SymbInfo::tuple_t& tuple) const;\n")
                    OUTPUT.write("  const "+self._index_str(name)+"& "+name+"_value(const SymbInfo::tuple_t& tuple) const;\n")
                    OUTPUT.write("  size_t "+name+"_index(const SymbInfo::tuple_t& tuple) const;\n")
                elif type == "var":
                    OUTPUT.write("  double "+name+"(const SymbInfo::tuple_t& tuple) const;\n")
                    OUTPUT.write("  double "+name+"_value(const SymbInfo::tuple_t& tuple) const;\n")
                    OUTPUT.write("  size_t "+name+"_index(const SymbInfo::tuple_t& tuple) const;\n")
                else:
                    OUTPUT.write("  size_t "+name+"(const SymbInfo::tuple_t& tuple) const;\n")
                    OUTPUT.write("  double "+name+"_value(const SymbInfo::tuple_t& tuple) const;\n")
                    OUTPUT.write("  size_t "+name+"_index(const SymbInfo::tuple_t& tuple) const;\n")
                #
                # bool foo_isvalid(const SymbInfo::tuple_t& tuple) const;
                #
                OUTPUT.write("  bool "+name+"_isvalid(const SymbInfo::tuple_t& tuple) const;\n")

                #
                # bool foo_isvalid(size_t& arg1, size_t& arg2) const;
                #
                OUTPUT.write("  bool "+name+"_isvalid("+self._set_args(self.symbol[name])+") const;\n")

                #
                # const set<SymbInfo::tuple_t >& foo_indices() const;
                #
                OUTPUT.write("  const std::set<SymbInfo::tuple_t >& "+name+"_indices() const;\n")

            OUTPUT.write("\n")
        OUTPUT.write("};\n")
        OUTPUT.write("\n")
        OUTPUT.write("\n")
        OUTPUT.write("\n")
        #
        # Define Info class
        #
        OUTPUT.write("class Info : public pico::MILPSymbInfo, public MILPSymbFunctions\n")
        OUTPUT.write("{\n")
        OUTPUT.write("\n")
        OUTPUT.write("public:\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  Info();\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  ~Info() {}\n")
        OUTPUT.write("\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  utilib::BasicArray<double> primal_values;\n")
        OUTPUT.write("  ///\n")
        OUTPUT.write("  utilib::BasicArray<double> dual_values;\n")

        for name in self.symbol:
            OUTPUT.write("  ///\n")
            if self.stype[name] == "set":
                if self.dimen[name] <= 1:
                    OUTPUT.write("  MILPSymbol"+str(len(self.symbol[name]))+"<"+self._index_str(name)+",size_t> "+name+"_symbol;\n")
                    OUTPUT.write("  typedef MILPSymbol"+str(len(self.symbol[name]))+"<"+self._index_str(name)+",size_t>::item_iterator "+name+"_iterator;\n")
                    OUTPUT.write("  typedef MILPSymbol"+str(len(self.symbol[name]))+"<"+self._index_str(name)+",size_t>::item_const_iterator "+name+"_const_iterator;\n")
                else:
                    OUTPUT.write("  MILPSymbol"+str(len(self.symbol[name]))+"<void,SymbInfo::tuple_t> "+name+"_symbol;\n")
                    OUTPUT.write("  typedef MILPSymbol"+str(len(self.symbol[name]))+"<void,SymbInfo::tuple_t>::item_iterator "+name+"_iterator;\n")
                    OUTPUT.write("  typedef MILPSymbol"+str(len(self.symbol[name]))+"<void,SymbInfo::tuple_t>::item_const_iterator "+name+"_const_iterator;\n")
            else:
                OUTPUT.write("  MILPSymbol"+str(len(self.symbol[name]))+"<"+self._index_str(name)+",size_t,size_t> "+name+"_symbol;\n")
                OUTPUT.write("  typedef MILPSymbol"+str(len(self.symbol[name]))+"<"+self._index_str(name)+",size_t,size_t>::item_iterator "+name+"_iterator;\n")
                OUTPUT.write("  typedef MILPSymbol"+str(len(self.symbol[name]))+"<"+self._index_str(name)+",size_t,size_t>::item_const_iterator "+name+"_const_iterator;\n")
            OUTPUT.write("\n")
        OUTPUT.write("};\n")
        OUTPUT.write("\n")
        OUTPUT.write("\n")
        OUTPUT.write("\n")
        OUTPUT.write(";\n")
        #
        # Print methods for the MILPSymbFunctions class
        #
        for name in self.symbol:
            type = self.stype[name]
            #
            # CharString& foo_name()
            #
            OUTPUT.write("  inline const CharString& MILPSymbFunctions::"+name+"_name() const\n")
            OUTPUT.write("    {return infoptr->"+name+"_symbol.name;}\n")
            #
            # std::set<size_t> foo()
            #   OR
            # size_t foo()
            #
            if type == "set":
                if self.dimen[name] <= 1:
                    OUTPUT.write("  inline const std::set<size_t>& MILPSymbFunctions::"+name+"("+self._set_args(self.symbol[name])+") const\n")
                else:
                    OUTPUT.write("  inline const std::set<SymbInfo::tuple_t>& MILPSymbFunctions::"+name+"("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    {return infoptr->"+name+"_symbol("+self._args(self.symbol[name])+");}\n")
            elif type == "param":
                OUTPUT.write("  inline const "+self._index_str(name)+"& MILPSymbFunctions::"+name+"("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    {return "+name+"_value("+self._args(self.symbol[name])+");}\n")
                OUTPUT.write("  inline const "+self._index_str(name)+"& MILPSymbFunctions::"+name+"_value("+self._set_args(self.symbol[name])+") const\n")
                if (name,) not in self.basic_superset:          #pragma:nocover
                    raise IOError("Attempting to setup '"+name+"' literal value but it is not have a basic superset")
                elif self.basic_superset[(name,)] == ("integers",):
                    OUTPUT.write("    {return infoptr->"+name+"_symbol("+self._args(self.symbol[name])+");}\n")
                elif self.basic_superset[(name,)] == ("reals",):
                    OUTPUT.write("    {return infoptr->double_literals[infoptr->"+name+"_symbol("+self._args(self.symbol[name])+")];}\n")
                elif self.basic_superset[(name,)] == ("literals",):
                    OUTPUT.write("    {return infoptr->string_literals[infoptr->"+name+"_symbol("+self._args(self.symbol[name])+")];}\n")
                OUTPUT.write("  inline size_t MILPSymbFunctions::"+name+"_index("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    {return infoptr->"+name+"_symbol("+self._args(self.symbol[name])+");}\n")
            elif type == "var":
                OUTPUT.write("  inline double MILPSymbFunctions::"+name+"("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    {return infoptr->primal_values[infoptr->"+name+"_symbol("+self._args(self.symbol[name])+")];}\n")
                OUTPUT.write("  inline double MILPSymbFunctions::"+name+"_value("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    {return infoptr->primal_values[infoptr->"+name+"_symbol("+self._args(self.symbol[name])+")];}\n")
                OUTPUT.write("  inline size_t MILPSymbFunctions::"+name+"_index("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    {return infoptr->"+name+"_symbol("+self._args(self.symbol[name])+");}\n")
            else:
                OUTPUT.write("  inline size_t MILPSymbFunctions::"+name+"("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    {return infoptr->"+name+"_symbol("+self._args(self.symbol[name])+");}\n")
                OUTPUT.write("  inline double MILPSymbFunctions::"+name+"_value("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    {return infoptr->dual_values[infoptr->"+name+"_symbol("+self._args(self.symbol[name])+")];}\n")
                OUTPUT.write("  inline size_t MILPSymbFunctions::"+name+"_index("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    {return infoptr->"+name+"_symbol("+self._args(self.symbol[name])+");}\n")
            #
            # const std::string& foo_value(size_t)
            # const double& foo_value(size_t)
            #
            if (type == "set" and self.dimen[name] <= 1):
                OUTPUT.write("  inline const "+self._index_str(name)+"& MILPSymbFunctions::"+name+"_value(const size_t& idx) const\n")
                if (name,) not in self.basic_superset:          #pragma:nocover
                    raise IOError("Attempting to setup '"+name+"' literal value but it is not have a basic superset")
                elif self.basic_superset[(name,)] == ("integers",):
                    OUTPUT.write("    {return idx;}\n")
                elif self.basic_superset[(name,)] == ("reals",):
                    OUTPUT.write("    {return infoptr->double_literals[idx];}\n")
                elif self.basic_superset[(name,)] == ("literals",):
                    OUTPUT.write("    {return infoptr->string_literals[idx];}\n")
            if type == "set" and self.dimen[name] > 1:
                OUTPUT.write(" inline utilib::Any MILPSymbFunctions::"+name+"_value(const SymbInfo::tuple_t& tuple) const\n")
                OUTPUT.write("   { return infoptr->"+name+"_symbol.value(tuple);}\n")
            #
            # Functions for indexed data
            #
            if len(self.symbol[name]) > 0:
                #
                # bool foo_isvalid(const SymbInfo::tuple_t& tuple) const;
                #
                OUTPUT.write("  inline bool MILPSymbFunctions::"+name+"_isvalid(const SymbInfo::tuple_t& tuple) const\n")
                OUTPUT.write("    { try { infoptr->"+name+"_symbol(tuple);} catch (std::runtime_error& err) {return false;} return true; }\n")
                #
                # bool foo_isvalid(int& arg1, double& arg2) const;
                #
                OUTPUT.write("  inline bool MILPSymbFunctions::"+name+"_isvalid("+self._set_args(self.symbol[name])+") const\n")
                OUTPUT.write("    { try { infoptr->"+name+"_symbol("+self._args(self.symbol[name])+");} catch (std::runtime_error& err) {return false;} return true;}\n")
                #
                # std::set<SymbInfo::tuple_t >& foo_indices() const;
                #
                OUTPUT.write("  inline const std::set<SymbInfo::tuple_t >& MILPSymbFunctions::"+name+"_indices() const\n")
                OUTPUT.write("    {return infoptr->"+name+"_symbol.valid;}\n")
                #
                # int foo(const SymbInfo::tuple_t& tuple) const;
                #
                if type == "set":
                    if self.dimen[name] <= 1:
                        OUTPUT.write("  inline const std::set<size_t>& MILPSymbFunctions::"+name+"(const SymbInfo::tuple_t& tuple) const\n")
                    else:
                        OUTPUT.write("  inline const std::set<SymbInfo::tuple_t>& MILPSymbFunctions::"+name+"(const SymbInfo::tuple_t& tuple) const\n")
                    OUTPUT.write("    {return infoptr->"+name+"_symbol(tuple);}\n")
                elif type == "param":
                    OUTPUT.write("  inline const "+self._index_str(name)+"& MILPSymbFunctions::"+name+"(const SymbInfo::tuple_t& tuple) const\n")
                    OUTPUT.write("    {return "+name+"_value(tuple);}\n")
                    OUTPUT.write("  inline const "+self._index_str(name)+"& MILPSymbFunctions::"+name+"_value(const SymbInfo::tuple_t& tuple) const\n")
                    if (name,) not in self.basic_superset:          #pragma:nocover
                        raise IOError("Attempting to setup '"+name+"' literal value but it is not have a basic superset")
                    elif self.basic_superset[(name,)] == ("integers",):
                        OUTPUT.write("    {return infoptr->"+name+"_symbol(tuple);}\n")
                    elif self.basic_superset[(name,)] == ("reals",):
                        OUTPUT.write("    {return infoptr->double_literals[infoptr->"+name+"_symbol(tuple)];}\n")
                    elif self.basic_superset[(name,)] == ("literals",):
                        OUTPUT.write("    {return infoptr->string_literals[infoptr->"+name+"_symbol(tuple)];}\n")

                    OUTPUT.write("  inline size_t MILPSymbFunctions::"+name+"_index(const SymbInfo::tuple_t& tuple) const\n")
                    OUTPUT.write("    {return infoptr->"+name+"_symbol(tuple);}\n")
                elif type == "var":
                    OUTPUT.write("  inline double MILPSymbFunctions::"+name+"(const SymbInfo::tuple_t& tuple) const\n")
                    OUTPUT.write("    {return infoptr->primal_values[infoptr->"+name+"_symbol(tuple)];}\n")
                    OUTPUT.write("  inline double MILPSymbFunctions::"+name+"_value(const SymbInfo::tuple_t& tuple) const\n")
                    OUTPUT.write("    {return infoptr->primal_values[infoptr->"+name+"_symbol(tuple)];}\n")
                    OUTPUT.write("  inline size_t MILPSymbFunctions::"+name+"_index(const SymbInfo::tuple_t& tuple) const\n")
                    OUTPUT.write("    {return infoptr->"+name+"_symbol(tuple);}\n")
                else:
                    OUTPUT.write("  inline size_t MILPSymbFunctions::"+name+"(const SymbInfo::tuple_t& tuple) const\n")
                    OUTPUT.write("    {return infoptr->"+name+"_symbol(tuple);}\n")
                    OUTPUT.write("  inline double MILPSymbFunctions::"+name+"_value(const SymbInfo::tuple_t& tuple) const\n")
                    OUTPUT.write("    {return infoptr->dual_values[infoptr->"+name+"_symbol(tuple)];}\n")
                    OUTPUT.write("  inline size_t MILPSymbFunctions::"+name+"_index(const SymbInfo::tuple_t& tuple) const\n")
                    OUTPUT.write("    {return infoptr->"+name+"_symbol(tuple);}\n")
            OUTPUT.write("\n")

        OUTPUT.write("\n")
        OUTPUT.write("\n")
        OUTPUT.write("}\n")
        OUTPUT.write("\n")


        OUTPUT.write("\n")
        OUTPUT.write("#endif\n")
        OUTPUT.close()

        #
        # Write Info Source
        #
        OUTPUT = open(self.name+"_info.cpp","w")
        OUTPUT.write("//\n")
        OUTPUT.write("// " + self.name + "_info.cpp\n")
        OUTPUT.write("// Automatically generated by MILPSymbInfo::setup_ilp_symbols\n")
        OUTPUT.write("//\n")
        OUTPUT.write("\n")
        OUTPUT.write("#include <utilib/CommonIO.h>\n")
        OUTPUT.write("#include \"" + self.name + "_info.h\"\n")
        OUTPUT.write("\n")
        OUTPUT.write("namespace sucasa_" + self.name + " {\n")
        OUTPUT.write("\n")
        OUTPUT.write("using namespace std;\n")
        OUTPUT.write("using namespace pico;\n")
        OUTPUT.write("using namespace utilib;\n")
        OUTPUT.write("\n")

        OUTPUT.write("Info::Info()\n")
        OUTPUT.write("  : MILPSymbFunctions(this)\n")
        for name in self.symbol:
            if self.stype[name] == "set":
                OUTPUT.write("    ,"+name+"_symbol(\""+name+"\")\n")
            elif self.superset[name] == "reals":
                OUTPUT.write("    ,"+name+"_symbol(\""+name+"\",&double_literals)\n")
            elif self.superset[name] == "literals":
                OUTPUT.write("    ,"+name+"_symbol(\""+name+"\",&string_literals)\n")
            else:
                OUTPUT.write("    ,"+name+"_symbol(\""+name+"\")\n")
        OUTPUT.write("  {\n")
        for name in self.symbol:
            OUTPUT.write("    //\n")
            OUTPUT.write("    // Initialize the "+name+"_symbol object\n")
            OUTPUT.write("    //\n")
            OUTPUT.write("    "+name+"_symbol.dimen = "+str(max(1,self.dimen[name]))+" ;\n")
            OUTPUT.write("    symbols[\""+name+"\"] = &"+name+"_symbol;\n")
            if not self.stype[name] in ["set","param"]:
                OUTPUT.write("    rc_symbols[\""+name+"\"] = &"+name+"_symbol;\n")
            for arg in self.symbol[name]:
                OUTPUT.write("    "+name+"_symbol.arg_sets.push_back(&"+arg+"_symbol);\n")
            if self.stype[name] == "set" and self.dimen[name] <= 1:
                if self.basic_superset[(name,)] == ("literals",):
                    OUTPUT.write("    "+name+"_symbol.set_literals(&string_literals);\n")
                elif self.basic_superset[(name,)] == ("reals",):
                    OUTPUT.write("    "+name+"_symbol.set_literals(&double_literals);\n")
            OUTPUT.write("\n")

        OUTPUT.write("  }\n")
        OUTPUT.write("\n")
        OUTPUT.write("\n")

        OUTPUT.write("void MILPSymbFunctions::register_var_values(utilib::BasicArray<double>& vec)\n")
        OUTPUT.write("{ infoptr->primal_values &= vec; }\n")
        OUTPUT.write("\n")
        OUTPUT.write("\n")

        OUTPUT.write("void MILPSymbFunctions::register_dual_values(utilib::BasicArray<double>& vec)\n")
        OUTPUT.write("{ infoptr->dual_values &= vec; }\n")
        OUTPUT.write("\n")
        OUTPUT.write("\n")

        OUTPUT.write("void MILPSymbFunctions::test_varmap(utilib::BasicArray<double>& primal, utilib::BasicArray<double>& dual)\n")
        OUTPUT.write("{\n")
        OUTPUT.write("register_var_values(primal);\n")
        OUTPUT.write("register_dual_values(dual);\n")
        OUTPUT.write("\n")
        OUTPUT.write("ucout << \" ---- BEGINNING test_varmap OUTPUT ----------------------------\" << std::endl;\n")
        for name in self.symbol:
            indices = "(*curr)[0]"
            for i in range(1,len(self.symbol[name])):
                indices = indices + ",(*curr)[" + str(i) +"]"
            if self.stype[name] == "set":
                OUTPUT.write("ucout << \"Set " +name+"\" << std::endl;\n")
            else:
                OUTPUT.write("ucout << \"Symbol " +name+"\" << std::endl;\n")
            OUTPUT.write("ucout << \""+name+" name: \" << " +name+"_name() << std::endl;\n")
            if len(self.symbol[name]) > 0:

                if self.stype[name] == "set":
                    OUTPUT.write("{\n")
                    OUTPUT.write("symbol_const_iterator curr = " + name +"_indices().begin();\n")
                    OUTPUT.write("symbol_const_iterator last = " + name + "_indices().end();\n")
                    OUTPUT.write("ucout << \"tuple: \" << *curr << std::endl;\n")
                    OUTPUT.write("while (curr != last) {\n")
                    OUTPUT.write("  {ucout << \""+name+" value: \";\n")
                    OUTPUT.write("  set_const_iterator scurr = " +name+"(*curr).begin();\n")
                    OUTPUT.write("  set_const_iterator send = " +name+"(*curr).end();\n")
                    OUTPUT.write("  while (scurr != send) {\n")
                    OUTPUT.write("    ucout << " +name+"_value(*scurr);\n")
                    OUTPUT.write("    ucout << \" ( \" << *scurr << \" ) \";\n")
                    OUTPUT.write("    scurr++;\n")
                    OUTPUT.write("    }\n")
                    OUTPUT.write("  ucout << std::endl;}\n")
                    OUTPUT.write("  {ucout << \""+name+" value: \";\n")
                    OUTPUT.write("  set_const_iterator scurr = " +name+"("+indices+").begin();\n")
                    OUTPUT.write("  set_const_iterator send = " +name+"("+indices+").end();\n")
                    OUTPUT.write("  while (scurr != send) {\n")
                    OUTPUT.write("    ucout << " +name+"_value(*scurr);\n")
                    OUTPUT.write("    ucout << \" ( \" << *scurr << \" ) \";\n")
                    OUTPUT.write("    scurr++;\n")
                    OUTPUT.write("    }\n")
                    OUTPUT.write("  ucout << std::endl;}\n")
                    OUTPUT.write("  ucout << \"isvalid: \" << "+name+"_isvalid(*curr) << std::endl;\n")
                    OUTPUT.write("  ucout << \"isvalid: \" << "+name+"_isvalid("+indices+") << std::endl;\n")
                else:
                    OUTPUT.write("{\n")
                    OUTPUT.write("symbol_const_iterator curr = " + name +"_indices().begin();\n")
                    OUTPUT.write("symbol_const_iterator last = " + name + "_indices().end();\n")
                    OUTPUT.write("while (curr != last) {\n")
                    OUTPUT.write("  ucout << \""+name+" \" << "+name+"(*curr) << std::endl;\n")
                    OUTPUT.write("  ucout << \""+name+" \" << "+name+"("+indices+") << std::endl;\n")
                    OUTPUT.write("  ucout << \""+name+" value: \" << "+name+"_value(*curr) << std::endl;\n")
                    OUTPUT.write("  ucout << \""+name+" value: \" << "+name+"_value("+indices+") << std::endl;\n")
                    OUTPUT.write("  ucout << \""+name+" index: \" << "+name+"_index(*curr) << std::endl;\n")
                    OUTPUT.write("  ucout << \""+name+" index: \" << "+name+"_index("+indices+") << std::endl;\n")
                    OUTPUT.write("  ucout << \"tuple: \" << *curr << std::endl;\n")
                    OUTPUT.write("  ucout << \"isvalid: \" << "+name+"_isvalid(*curr) << std::endl;\n")
                    OUTPUT.write("  ucout << \"isvalid: \" << "+name+"_isvalid("+indices+") << std::endl;\n")
                OUTPUT.write("  curr++;\n")
                OUTPUT.write("  }\n")
                OUTPUT.write("}\n")
            else:
                if self.stype[name] == "set":
                    OUTPUT.write("{\n")
                    OUTPUT.write("set_const_iterator curr = "+name+"().begin();\n")
                    OUTPUT.write("set_const_iterator end  = "+name+"().end();\n")
                    OUTPUT.write("while (curr != end) {\n")
                    OUTPUT.write("  ucout << \""+name+" value: \" << "+name+"_value(*curr) << \"  "+name+" index: \" << *curr << std::endl;\n")
                    OUTPUT.write("  curr++;\n")
                    OUTPUT.write("  }\n")
                    OUTPUT.write("}\n")
                else:
                    OUTPUT.write("ucout << \""+name+": \" << " +name+"() << std::endl;\n")
                    OUTPUT.write("ucout << \""+name+" value: \" << " +name+"_value() << std::endl;\n")
                    OUTPUT.write("ucout << \""+name+" index: \" << " +name+"_index_set() << std::endl;\n")
            OUTPUT.write("ucout << std::endl;\n")

        OUTPUT.write("ucout << \" ---- ENDING test_varmap OUTPUT ----------------------------\" << std::endl;\n")
        OUTPUT.write("ucout << Flush;\n")
        OUTPUT.write("}\n")
        OUTPUT.write("\n")
        OUTPUT.write("} // namespace sucasa_" + self.name)
        OUTPUT.write("\n")

        OUTPUT.close()
        return [self.name+"_info.h",self.name+"_info.cpp"]



    def _index_str(self,name):
        # WEH - I don't think that this is needed
        #if name in self.basic_sets:
            #return name
        if (name,) not in self.basic_superset:
            return "size_t"
        if self.basic_superset[(name,)] == ("integers",):
            return "size_t"
        elif self.basic_superset[(name,)] == ("reals",):
            return "double"
        elif self.basic_superset[(name,)] == ("literals",):
            return "std::string"
        return "unknown"                #pragma:nocover

    def _set_args(self,names):
        ans=""
        i=1
        flag=False
        for name in names:
            if flag:
                ans += ","
            flag=True
            #ans += self._index_str(name)+"& arg"+str(i)
            ans += "size_t arg"+str(i)
            i += 1
        return ans

    def _args(self,names):
        ans=""
        i=1
        flag=False
        for name in names:
            if flag:
                ans += ","
            flag=True
            ans += "arg"+str(i)
            i += 1
        return ans
