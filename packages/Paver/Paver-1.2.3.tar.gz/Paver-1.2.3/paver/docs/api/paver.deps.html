<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>paver.deps package &mdash; Paver 1.2.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Paver 1.2.3 documentation" href="../index.html" />
    <link rel="up" title="paver package" href="paver.html" />
    <link rel="next" title="paver.tests package" href="paver.tests.html" />
    <link rel="prev" title="paver package" href="paver.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="paver.tests.html" title="paver.tests package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="paver.html" title="paver package"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Paver 1.2.3 documentation</a> &raquo;</li>
          <li><a href="../paverfullapi.html" >Complete API Reference</a> &raquo;</li>
          <li><a href="paver.html" accesskey="U">paver package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="paver-deps-package">
<h1>paver.deps package<a class="headerlink" href="#paver-deps-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-paver.deps.path2">
<span id="paver-deps-path2-module"></span><h2>paver.deps.path2 module<a class="headerlink" href="#module-paver.deps.path2" title="Permalink to this headline">¶</a></h2>
<p>path.py - An object representing a path to a file or directory.</p>
<dl class="docutils">
<dt>Original author:</dt>
<dd>Jason Orendorff &lt;<a class="reference external" href="mailto:jason&#46;orendorff&#37;&#52;&#48;gmail&#46;com">jason<span>&#46;</span>orendorff<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</dd>
<dt>Contributors:</dt>
<dd>Mikhail Gusarov &lt;<a class="reference external" href="mailto:dottedmag&#37;&#52;&#48;dottedmag&#46;net">dottedmag<span>&#64;</span>dottedmag<span>&#46;</span>net</a>&gt;
Marc Abramowitz &lt;<a class="reference external" href="mailto:marc&#37;&#52;&#48;marc-abramowitz&#46;com">marc<span>&#64;</span>marc-abramowitz<span>&#46;</span>com</a>&gt;</dd>
</dl>
<p>Example:</p>
<p>from path import path
d = path(&#8216;/home/guido/bin&#8217;)
for f in d.files(&#8216;<a href="#id1"><span class="problematic" id="id2">*</span></a>.py&#8217;):</p>
<blockquote>
<div>f.chmod(0755)</div></blockquote>
<p>This module requires Python 2.3 or later.</p>
<dl class="class">
<dt id="paver.deps.path2.path">
<em class="property">class </em><tt class="descclassname">paver.deps.path2.</tt><tt class="descname">path</tt><a class="headerlink" href="#paver.deps.path2.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></p>
<p>Represents a filesystem path.</p>
<p>For documentation on individual methods, consult their
counterparts in os.path.</p>
<dl class="method">
<dt id="paver.deps.path2.path.abspath">
<tt class="descname">abspath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.abspath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.access">
<tt class="descname">access</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.access" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if current user has access to this path.</p>
<p>mode - One of the constants os.F_OK, os.R_OK, os.W_OK, os.X_OK</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.atime">
<tt class="descname">atime</tt><a class="headerlink" href="#paver.deps.path2.path.atime" title="Permalink to this definition">¶</a></dt>
<dd><p>Last access time of the file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.basename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.bytes">
<tt class="descname">bytes</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read all bytes, return them as a string.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.chmod">
<tt class="descname">chmod</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.chmod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.chown">
<tt class="descname">chown</tt><big>(</big><em>uid</em>, <em>gid</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.chown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.chroot">
<tt class="descname">chroot</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.chroot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.copy">
<tt class="descname">copy</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data and mode bits (&#8220;cp src dst&#8221;).</p>
<p>The destination may be a directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.copy2">
<tt class="descname">copy2</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.copy2" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data and all stat info (&#8220;cp -p src dst&#8221;).</p>
<p>The destination may be a directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.copyfile">
<tt class="descname">copyfile</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.copyfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data from src to dst</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.copymode">
<tt class="descname">copymode</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.copymode" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy mode bits from src to dst</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.copystat">
<tt class="descname">copystat</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.copystat" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all stat info (mode bits, atime, mtime, flags) from src to dst</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.copytree">
<tt class="descname">copytree</tt><big>(</big><em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.copytree" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively copy a directory tree using copy2().</p>
<p>The destination directory must not already exist.
If exception(s) occur, an Error is raised with a list of reasons.</p>
<p>If the optional symlinks flag is true, symbolic links in the
source tree result in symbolic links in the destination tree; if
it is false, the contents of the files pointed to by symbolic
links are copied.</p>
<p>The optional ignore argument is a callable. If given, it
is called with the <cite>src</cite> parameter, which is the directory
being visited by copytree(), and <cite>names</cite> which is the list of
<cite>src</cite> contents, as returned by os.listdir():</p>
<blockquote>
<div>callable(src, names) -&gt; ignored_names</div></blockquote>
<p>Since copytree() is called recursively, the callable will be
called once for each directory that is copied. It returns a
list of names relative to the <cite>src</cite> directory that should
not be copied.</p>
<p>XXX Consider this example code rather than the ultimate tool.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.ctime">
<tt class="descname">ctime</tt><a class="headerlink" href="#paver.deps.path2.path.ctime" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation time of the file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.dirname">
<tt class="descname">dirname</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.dirname" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.dirs">
<tt class="descname">dirs</tt><big>(</big><big>)</big> &rarr; List of this directory's subdirectories.<a class="headerlink" href="#paver.deps.path2.path.dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>The elements of the list are path objects.
This does not walk recursively into subdirectories
(but see path.walkdirs).</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists
directories whose names match the given pattern.  For
example, d.dirs(&#8216;build-<a href="#id3"><span class="problematic" id="id4">*</span></a>&#8216;).</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.drive">
<tt class="descname">drive</tt><a class="headerlink" href="#paver.deps.path2.path.drive" title="Permalink to this definition">¶</a></dt>
<dd><p>The drive specifier, for example &#8216;C:&#8217;.
This is always empty on systems that don&#8217;t use drive specifiers.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.exists">
<tt class="descname">exists</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.exists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.expand">
<tt class="descname">expand</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up a filename by calling expandvars(),
expanduser(), and normpath() on it.</p>
<p>This is commonly everything needed to clean up a filename
read from a configuration file, for example.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.expanduser">
<tt class="descname">expanduser</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.expanduser" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.expandvars">
<tt class="descname">expandvars</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.expandvars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.ext">
<tt class="descname">ext</tt><a class="headerlink" href="#paver.deps.path2.path.ext" title="Permalink to this definition">¶</a></dt>
<dd><p>The file extension, for example &#8216;.py&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.files">
<tt class="descname">files</tt><big>(</big><big>)</big> &rarr; List of the files in this directory.<a class="headerlink" href="#paver.deps.path2.path.files" title="Permalink to this definition">¶</a></dt>
<dd><p>The elements of the list are path objects.
This does not walk into subdirectories (see path.walkfiles).</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists files
whose names match the given pattern.  For example,
d.files(&#8216;<a href="#id5"><span class="problematic" id="id6">*</span></a>.pyc&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.fnmatch">
<tt class="descname">fnmatch</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.fnmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self.name matches the given pattern.</p>
<dl class="docutils">
<dt>pattern - A filename pattern with wildcards,</dt>
<dd>for example &#8216;<a href="#id7"><span class="problematic" id="id8">*</span></a>.py&#8217;.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.get_owner">
<tt class="descname">get_owner</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.get_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the owner of this file or directory.</p>
<p>This follows symbolic links.</p>
<p>On Windows, this returns a name of the form ur&#8217;DOMAINUser Name&#8217;.
On Windows, a group can own a file or directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.getatime">
<tt class="descname">getatime</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.getatime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.getctime">
<tt class="descname">getctime</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.getctime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="paver.deps.path2.path.getcwd">
<em class="property">classmethod </em><tt class="descname">getcwd</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.getcwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current working directory as a path object.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.getmtime">
<tt class="descname">getmtime</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.getmtime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.getsize">
<tt class="descname">getsize</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.getsize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.glob">
<tt class="descname">glob</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.glob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of path objects that match the pattern.</p>
<p>pattern - a path relative to this directory, with wildcards.</p>
<p>For example, path(&#8216;/users&#8217;).glob(&#8216;<em>/bin/</em>&#8216;) returns a list
of all the files users have in their bin directories.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.isabs">
<tt class="descname">isabs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.isabs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.isdir">
<tt class="descname">isdir</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.isdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.isfile">
<tt class="descname">isfile</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.isfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.islink">
<tt class="descname">islink</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.islink" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.ismount">
<tt class="descname">ismount</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.ismount" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.joinpath">
<tt class="descname">joinpath</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.joinpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Join two or more path components, adding a separator
character (os.sep) if needed.  Returns a new path
object.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.lines">
<tt class="descname">lines</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em>, <em>retain=True</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read all lines, return them in a list.</p>
<dl class="docutils">
<dt>Optional arguments:</dt>
<dd><dl class="first last docutils">
<dt>encoding - The Unicode encoding (or character set) of</dt>
<dd>the file.  The default is None, meaning the content
of the file is read as 8-bit characters and returned
as a list of (non-Unicode) str objects.</dd>
<dt>errors - How to handle Unicode errors; see help(str.decode)</dt>
<dd>for the options.  Default is &#8216;strict&#8217;</dd>
<dt>retain - If true, retain newline characters; but all newline</dt>
<dd>character combinations (&#8216;r&#8217;, &#8216;n&#8217;, &#8216;rn&#8217;) are
translated to &#8216;n&#8217;.  If false, newline characters are
stripped off.  Default is True.</dd>
</dl>
</dd>
</dl>
<p>This uses &#8216;U&#8217; mode in Python 2.3 and later.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.link">
<tt class="descname">link</tt><big>(</big><em>newpath</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.link" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hard link at &#8216;newpath&#8217;, pointing to this file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.listdir">
<tt class="descname">listdir</tt><big>(</big><big>)</big> &rarr; List of items in this directory.<a class="headerlink" href="#paver.deps.path2.path.listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Use D.files() or D.dirs() instead if you want a listing
of just files or just subdirectories.</p>
<p>The elements of the list are path objects.</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists
items whose names match the given pattern.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.lstat">
<tt class="descname">lstat</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.lstat" title="Permalink to this definition">¶</a></dt>
<dd><p>Like path.stat(), but do not follow symbolic links.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.makedirs">
<tt class="descname">makedirs</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.makedirs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.makedirs_p">
<tt class="descname">makedirs_p</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.makedirs_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.mkdir">
<tt class="descname">mkdir</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.mkdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.mkdir_p">
<tt class="descname">mkdir_p</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.mkdir_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.move">
<tt class="descname">move</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively move a file or directory to another location. This is
similar to the Unix &#8220;mv&#8221; command.</p>
<p>If the destination is a directory or a symlink to a directory, the source
is moved inside the directory. The destination path must not already
exist.</p>
<p>If the destination already exists but is not a directory, it may be
overwritten depending on os.rename() semantics.</p>
<p>If the destination is on our current filesystem, then rename() is used.
Otherwise, src is copied to the destination and then removed.
A lot more could be done here...  A look at a mv.c shows a lot of
the issues this implementation glosses over.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.mtime">
<tt class="descname">mtime</tt><a class="headerlink" href="#paver.deps.path2.path.mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Last-modified time of the file.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.name">
<tt class="descname">name</tt><a class="headerlink" href="#paver.deps.path2.path.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this file or directory without the full path.</p>
<p>For example, path(&#8216;/usr/local/lib/libpython.so&#8217;).name == &#8216;libpython.so&#8217;</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.namebase">
<tt class="descname">namebase</tt><a class="headerlink" href="#paver.deps.path2.path.namebase" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as path.name, but with one file extension stripped off.</p>
<p>For example, path(&#8216;/home/guido/python.tar.gz&#8217;).name     == &#8216;python.tar.gz&#8217;,
but          path(&#8216;/home/guido/python.tar.gz&#8217;).namebase == &#8216;python.tar&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.normcase">
<tt class="descname">normcase</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.normcase" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.normpath">
<tt class="descname">normpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.normpath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.open">
<tt class="descname">open</tt><big>(</big><em>mode='r'</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file.  Return a file object.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.owner">
<tt class="descname">owner</tt><a class="headerlink" href="#paver.deps.path2.path.owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the owner of this file or directory.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.parent">
<tt class="descname">parent</tt><a class="headerlink" href="#paver.deps.path2.path.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>This path&#8217;s parent directory, as a new path object.</p>
<p>For example, path(&#8216;/usr/local/lib/libpython.so&#8217;).parent == path(&#8216;/usr/local/lib&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.pathconf">
<tt class="descname">pathconf</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.pathconf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.read_hash">
<tt class="descname">read_hash</tt><big>(</big><em>hash_name</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.read_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate given hash for this file.</p>
<p>List of supported hashes can be obtained from hashlib package. This
reads the entire file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.read_hexhash">
<tt class="descname">read_hexhash</tt><big>(</big><em>hash_name</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.read_hexhash" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate given hash for this file, returning hexdigest.</p>
<p>List of supported hashes can be obtained from hashlib package. This
reads the entire file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.read_md5">
<tt class="descname">read_md5</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.read_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the md5 hash for this file.</p>
<p>This reads through the entire file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.readlink">
<tt class="descname">readlink</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.readlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result may be an absolute or a relative path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.readlinkabs">
<tt class="descname">readlinkabs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.readlinkabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result is always an absolute path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.realpath">
<tt class="descname">realpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.realpath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.relpath">
<tt class="descname">relpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.relpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this path as a relative path,
based from the current working directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.relpathto">
<tt class="descname">relpathto</tt><big>(</big><em>dest</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.relpathto" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a relative path from self to dest.</p>
<p>If there is no relative path from self to dest, for example if
they reside on different drives in Windows, then this returns
dest.abspath().</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.remove">
<tt class="descname">remove</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.remove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.remove_p">
<tt class="descname">remove_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.remove_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.removedirs">
<tt class="descname">removedirs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.removedirs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.removedirs_p">
<tt class="descname">removedirs_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.removedirs_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.rename">
<tt class="descname">rename</tt><big>(</big><em>new</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.rename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.renames">
<tt class="descname">renames</tt><big>(</big><em>new</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.renames" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.rmdir">
<tt class="descname">rmdir</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.rmdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.rmdir_p">
<tt class="descname">rmdir_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.rmdir_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.rmtree">
<tt class="descname">rmtree</tt><big>(</big><em>*args</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.rmtree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.rmtree_p">
<tt class="descname">rmtree_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.rmtree_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.samefile">
<tt class="descname">samefile</tt><big>(</big><em>otherfile</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.samefile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="paver.deps.path2.path.size">
<tt class="descname">size</tt><a class="headerlink" href="#paver.deps.path2.path.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the file, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.splitall">
<tt class="descname">splitall</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.splitall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the path components in this path.</p>
<p>The first item in the list will be a path.  Its value will be
either os.curdir, os.pardir, empty, or the root directory of
this path (for example, &#8216;/&#8217; or &#8216;C:\&#8217;).  The other items in
the list will be strings.</p>
<p>path.path.joinpath(<a href="#id9"><span class="problematic" id="id10">*</span></a>result) will yield the original path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.splitdrive">
<tt class="descname">splitdrive</tt><big>(</big><big>)</big> &rarr; Return (p.drive, &lt;the rest of p&gt;).<a class="headerlink" href="#paver.deps.path2.path.splitdrive" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the drive specifier from this path.  If there is
no drive specifier, p.drive is empty, so the return value
is simply (path(&#8216;&#8217;), p).  This is always the case on Unix.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.splitext">
<tt class="descname">splitext</tt><big>(</big><big>)</big> &rarr; Return (p.stripext(), p.ext).<a class="headerlink" href="#paver.deps.path2.path.splitext" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the filename extension from this path and return
the two parts.  Either part may be empty.</p>
<p>The extension is everything from &#8216;.&#8217; to the end of the
last path segment.  This has the property that if
(a, b) == p.splitext(), then a + b == p.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.splitpath">
<tt class="descname">splitpath</tt><big>(</big><big>)</big> &rarr; Return (p.parent, p.name).<a class="headerlink" href="#paver.deps.path2.path.splitpath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.stat">
<tt class="descname">stat</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.stat" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a stat() system call on this path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.statvfs">
<tt class="descname">statvfs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.statvfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a statvfs() system call on this path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.stripext">
<tt class="descname">stripext</tt><big>(</big><big>)</big> &rarr; Remove one file extension from the path.<a class="headerlink" href="#paver.deps.path2.path.stripext" title="Permalink to this definition">¶</a></dt>
<dd><p>For example, path(&#8216;/home/guido/python.tar.gz&#8217;).stripext()
returns path(&#8216;/home/guido/python.tar&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.symlink">
<tt class="descname">symlink</tt><big>(</big><em>newlink</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a symbolic link at &#8216;newlink&#8217;, pointing here.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.text">
<tt class="descname">text</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read it in, return the content as a string.</p>
<p>This uses &#8216;U&#8217; mode in Python 2.3 and later, so &#8216;rn&#8217; and &#8216;r&#8217;
are automatically translated to &#8216;n&#8217;.</p>
<p>Optional arguments:</p>
<dl class="docutils">
<dt>encoding - The Unicode encoding (or character set) of</dt>
<dd>the file.  If present, the content of the file is
decoded and returned as a unicode object; otherwise
it is returned as an 8-bit str.</dd>
<dt>errors - How to handle Unicode errors; see help(str.decode)</dt>
<dd>for the options.  Default is &#8216;strict&#8217;.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.touch">
<tt class="descname">touch</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.touch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the access/modified times of this file to the current time.
Create the file if it does not exist.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.unlink">
<tt class="descname">unlink</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.unlink" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.unlink_p">
<tt class="descname">unlink_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path2.path.unlink_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.utime">
<tt class="descname">utime</tt><big>(</big><em>times</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.utime" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the access and modified times of this file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.walk">
<tt class="descname">walk</tt><big>(</big><big>)</big> &rarr; iterator over files and subdirs, recursively.<a class="headerlink" href="#paver.deps.path2.path.walk" title="Permalink to this definition">¶</a></dt>
<dd><p>The iterator yields path objects naming each child item of
this directory and its descendants.  This requires that
D.isdir().</p>
<p>This performs a depth-first traversal of the directory tree.
Each directory is returned just before all its children.</p>
<p>The errors= keyword argument controls behavior when an
error occurs.  The default is &#8216;strict&#8217;, which causes an
exception.  The other allowed values are &#8216;warn&#8217;, which
reports the error via warnings.warn(), and &#8216;ignore&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.walkdirs">
<tt class="descname">walkdirs</tt><big>(</big><big>)</big> &rarr; iterator over subdirs, recursively.<a class="headerlink" href="#paver.deps.path2.path.walkdirs" title="Permalink to this definition">¶</a></dt>
<dd><p>With the optional &#8216;pattern&#8217; argument, this yields only
directories whose names match the given pattern.  For
example, mydir.walkdirs(&#8216;<a href="#id11"><span class="problematic" id="id12">*</span></a>test&#8217;) yields only directories
with names ending in &#8216;test&#8217;.</p>
<p>The errors= keyword argument controls behavior when an
error occurs.  The default is &#8216;strict&#8217;, which causes an
exception.  The other allowed values are &#8216;warn&#8217;, which
reports the error via warnings.warn(), and &#8216;ignore&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.walkfiles">
<tt class="descname">walkfiles</tt><big>(</big><big>)</big> &rarr; iterator over files in D, recursively.<a class="headerlink" href="#paver.deps.path2.path.walkfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>The optional argument, pattern, limits the results to files
with names that match the pattern.  For example,
mydir.walkfiles(&#8216;<a href="#id13"><span class="problematic" id="id14">*</span></a>.tmp&#8217;) yields only files with the .tmp
extension.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.write_bytes">
<tt class="descname">write_bytes</tt><big>(</big><em>bytes</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.write_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file and write the given bytes to it.</p>
<p>Default behavior is to overwrite any existing file.
Call p.write_bytes(bytes, append=True) to append instead.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.write_lines">
<tt class="descname">write_lines</tt><big>(</big><em>lines</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.write_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given lines of text to this file.</p>
<p>By default this overwrites any existing file at this path.</p>
<p>This puts a platform-specific newline sequence on every line.
See &#8216;linesep&#8217; below.</p>
<p>lines - A list of strings.</p>
<dl class="docutils">
<dt>encoding - A Unicode encoding to use.  This applies only if</dt>
<dd>&#8216;lines&#8217; contains any Unicode strings.</dd>
<dt>errors - How to handle errors in Unicode encoding.  This</dt>
<dd>also applies only to Unicode strings.</dd>
<dt>linesep - The desired line-ending.  This line-ending is</dt>
<dd>applied to every line.  If a line already has any
standard line ending (&#8216;r&#8217;, &#8216;n&#8217;, &#8216;rn&#8217;, u&#8217;x85&#8217;,
u&#8217;rx85&#8217;, u&#8217;u2028&#8217;), that will be stripped off and
this will be used instead.  The default is os.linesep,
which is platform-dependent (&#8216;rn&#8217; on Windows, &#8216;n&#8217; on
Unix, etc.)  Specify None to write the lines as-is,
like file.writelines().</dd>
</dl>
<p>Use the keyword argument append=True to append lines to the
file.  The default is to overwrite the file.  Warning:
When you use this with Unicode data, if the encoding of the
existing data in the file is different from the encoding
you specify with the encoding= parameter, the result is
mixed-encoding data, which can really confuse someone trying
to read the file later.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path2.path.write_text">
<tt class="descname">write_text</tt><big>(</big><em>text</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.deps.path2.path.write_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given text to this file.</p>
<p>The default behavior is to overwrite any existing file;
to append instead, use the &#8216;append=True&#8217; keyword argument.</p>
<p>There are two differences between path.write_text() and
path.write_bytes(): newline handling and Unicode handling.
See below.</p>
<p>Parameters:</p>
<blockquote>
<div><ul class="simple">
<li>text - str/unicode - The text to be written.</li>
<li>encoding - str - The Unicode encoding that will be used.
This is ignored if &#8216;text&#8217; isn&#8217;t a Unicode string.</li>
<li>errors - str - How to handle Unicode encoding errors.
Default is &#8216;strict&#8217;.  See help(unicode.encode) for the
options.  This is ignored if &#8216;text&#8217; isn&#8217;t a Unicode
string.</li>
<li>linesep - keyword argument - str/unicode - The sequence of
characters to be used to mark end-of-line.  The default is
os.linesep.  You can also specify None; this means to
leave all newlines as they are in &#8216;text&#8217;.</li>
<li>append - keyword argument - bool - Specifies what to do if
the file already exists (True: append to the end of it;
False: overwrite it.)  The default is False.</li>
</ul>
</div></blockquote>
<p>&#8212; Newline handling.</p>
<p>write_text() converts all standard end-of-line sequences
(&#8216;n&#8217;, &#8216;r&#8217;, and &#8216;rn&#8217;) to your platform&#8217;s default end-of-line
sequence (see os.linesep; on Windows, for example, the
end-of-line marker is &#8216;rn&#8217;).</p>
<p>If you don&#8217;t like your platform&#8217;s default, you can override it
using the &#8216;linesep=&#8217; keyword argument.  If you specifically want
write_text() to preserve the newlines as-is, use &#8216;linesep=None&#8217;.</p>
<p>This applies to Unicode text the same as to 8-bit text, except
there are three additional standard Unicode end-of-line sequences:
u&#8217;x85&#8217;, u&#8217;rx85&#8217;, and u&#8217;u2028&#8217;.</p>
<p>(This is slightly different from when you open a file for
writing with fopen(filename, &#8220;w&#8221;) in C or open(filename, &#8216;w&#8217;)
in Python.)</p>
<p>&#8212; Unicode</p>
<p>If &#8216;text&#8217; isn&#8217;t Unicode, then apart from newline handling, the
bytes are written verbatim to the file.  The &#8216;encoding&#8217; and
&#8216;errors&#8217; arguments are not used and must be omitted.</p>
<p>If &#8216;text&#8217; is Unicode, it is first converted to bytes using the
specified &#8216;encoding&#8217; (or the default encoding if &#8216;encoding&#8217;
isn&#8217;t specified).  The &#8216;errors&#8217; argument applies only to this
conversion.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-paver.deps.path3">
<span id="paver-deps-path3-module"></span><h2>paver.deps.path3 module<a class="headerlink" href="#module-paver.deps.path3" title="Permalink to this headline">¶</a></h2>
<p>path.py - An object representing a path to a file or directory.</p>
<dl class="docutils">
<dt>Original author:</dt>
<dd>Jason Orendorff &lt;<a class="reference external" href="mailto:jason&#46;orendorff&#37;&#52;&#48;gmail&#46;com">jason<span>&#46;</span>orendorff<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</dd>
<dt>Contributors:</dt>
<dd>Mikhail Gusarov &lt;<a class="reference external" href="mailto:dottedmag&#37;&#52;&#48;dottedmag&#46;net">dottedmag<span>&#64;</span>dottedmag<span>&#46;</span>net</a>&gt;
Marc Abramowitz &lt;<a class="reference external" href="mailto:marc&#37;&#52;&#48;marc-abramowitz&#46;com">marc<span>&#64;</span>marc-abramowitz<span>&#46;</span>com</a>&gt;</dd>
</dl>
<p>Example:</p>
<p>from path import path
d = path(&#8216;/home/guido/bin&#8217;)
for f in d.files(&#8216;<a href="#id15"><span class="problematic" id="id16">*</span></a>.py&#8217;):</p>
<blockquote>
<div>f.chmod(0755)</div></blockquote>
<p>This module requires Python 2.3 or later.</p>
<dl class="class">
<dt id="paver.deps.path3.path">
<em class="property">class </em><tt class="descclassname">paver.deps.path3.</tt><tt class="descname">path</tt><a class="headerlink" href="#paver.deps.path3.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></p>
<p>Represents a filesystem path.</p>
<p>For documentation on individual methods, consult their
counterparts in os.path.</p>
<dl class="method">
<dt id="paver.deps.path3.path.abspath">
<tt class="descname">abspath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.abspath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.access">
<tt class="descname">access</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.access" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if current user has access to this path.</p>
<p>mode - One of the constants os.F_OK, os.R_OK, os.W_OK, os.X_OK</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.atime">
<tt class="descname">atime</tt><a class="headerlink" href="#paver.deps.path3.path.atime" title="Permalink to this definition">¶</a></dt>
<dd><p>Last access time of the file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.basename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.bytes">
<tt class="descname">bytes</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read all bytes, return them as a string.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.chmod">
<tt class="descname">chmod</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.chmod" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.chown">
<tt class="descname">chown</tt><big>(</big><em>uid</em>, <em>gid</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.chown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.chroot">
<tt class="descname">chroot</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.chroot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.copy">
<tt class="descname">copy</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data and mode bits (&#8220;cp src dst&#8221;).</p>
<p>The destination may be a directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.copy2">
<tt class="descname">copy2</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.copy2" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data and all stat info (&#8220;cp -p src dst&#8221;).</p>
<p>The destination may be a directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.copyfile">
<tt class="descname">copyfile</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.copyfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy data from src to dst</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.copymode">
<tt class="descname">copymode</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.copymode" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy mode bits from src to dst</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.copystat">
<tt class="descname">copystat</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.copystat" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all stat info (mode bits, atime, mtime, flags) from src to dst</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.copytree">
<tt class="descname">copytree</tt><big>(</big><em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.copytree" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively copy a directory tree using copy2().</p>
<p>The destination directory must not already exist.
If exception(s) occur, an Error is raised with a list of reasons.</p>
<p>If the optional symlinks flag is true, symbolic links in the
source tree result in symbolic links in the destination tree; if
it is false, the contents of the files pointed to by symbolic
links are copied.</p>
<p>The optional ignore argument is a callable. If given, it
is called with the <cite>src</cite> parameter, which is the directory
being visited by copytree(), and <cite>names</cite> which is the list of
<cite>src</cite> contents, as returned by os.listdir():</p>
<blockquote>
<div>callable(src, names) -&gt; ignored_names</div></blockquote>
<p>Since copytree() is called recursively, the callable will be
called once for each directory that is copied. It returns a
list of names relative to the <cite>src</cite> directory that should
not be copied.</p>
<p>XXX Consider this example code rather than the ultimate tool.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.ctime">
<tt class="descname">ctime</tt><a class="headerlink" href="#paver.deps.path3.path.ctime" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation time of the file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.dirname">
<tt class="descname">dirname</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.dirname" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.dirs">
<tt class="descname">dirs</tt><big>(</big><big>)</big> &rarr; List of this directory's subdirectories.<a class="headerlink" href="#paver.deps.path3.path.dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>The elements of the list are path objects.
This does not walk recursively into subdirectories
(but see path.walkdirs).</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists
directories whose names match the given pattern.  For
example, d.dirs(&#8216;build-<a href="#id17"><span class="problematic" id="id18">*</span></a>&#8216;).</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.drive">
<tt class="descname">drive</tt><a class="headerlink" href="#paver.deps.path3.path.drive" title="Permalink to this definition">¶</a></dt>
<dd><p>The drive specifier, for example &#8216;C:&#8217;.
This is always empty on systems that don&#8217;t use drive specifiers.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.exists">
<tt class="descname">exists</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.exists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.expand">
<tt class="descname">expand</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up a filename by calling expandvars(),
expanduser(), and normpath() on it.</p>
<p>This is commonly everything needed to clean up a filename
read from a configuration file, for example.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.expanduser">
<tt class="descname">expanduser</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.expanduser" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.expandvars">
<tt class="descname">expandvars</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.expandvars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.ext">
<tt class="descname">ext</tt><a class="headerlink" href="#paver.deps.path3.path.ext" title="Permalink to this definition">¶</a></dt>
<dd><p>The file extension, for example &#8216;.py&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.files">
<tt class="descname">files</tt><big>(</big><big>)</big> &rarr; List of the files in this directory.<a class="headerlink" href="#paver.deps.path3.path.files" title="Permalink to this definition">¶</a></dt>
<dd><p>The elements of the list are path objects.
This does not walk into subdirectories (see path.walkfiles).</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists files
whose names match the given pattern.  For example,
d.files(&#8216;<a href="#id19"><span class="problematic" id="id20">*</span></a>.pyc&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.fnmatch">
<tt class="descname">fnmatch</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.fnmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self.name matches the given pattern.</p>
<dl class="docutils">
<dt>pattern - A filename pattern with wildcards,</dt>
<dd>for example &#8216;<a href="#id21"><span class="problematic" id="id22">*</span></a>.py&#8217;.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.get_owner">
<tt class="descname">get_owner</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.get_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the owner of this file or directory.</p>
<p>This follows symbolic links.</p>
<p>On Windows, this returns a name of the form ur&#8217;DOMAINUser Name&#8217;.
On Windows, a group can own a file or directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.getatime">
<tt class="descname">getatime</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.getatime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.getctime">
<tt class="descname">getctime</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.getctime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="paver.deps.path3.path.getcwd">
<em class="property">classmethod </em><tt class="descname">getcwd</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.getcwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current working directory as a path object.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.getmtime">
<tt class="descname">getmtime</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.getmtime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.getsize">
<tt class="descname">getsize</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.getsize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.glob">
<tt class="descname">glob</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.glob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of path objects that match the pattern.</p>
<p>pattern - a path relative to this directory, with wildcards.</p>
<p>For example, path(&#8216;/users&#8217;).glob(&#8216;<em>/bin/</em>&#8216;) returns a list
of all the files users have in their bin directories.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.isabs">
<tt class="descname">isabs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.isabs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.isdir">
<tt class="descname">isdir</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.isdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.isfile">
<tt class="descname">isfile</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.isfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.islink">
<tt class="descname">islink</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.islink" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.ismount">
<tt class="descname">ismount</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.ismount" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.joinpath">
<tt class="descname">joinpath</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.joinpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Join two or more path components, adding a separator
character (os.sep) if needed.  Returns a new path
object.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.lines">
<tt class="descname">lines</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em>, <em>retain=True</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read all lines, return them in a list.</p>
<dl class="docutils">
<dt>Optional arguments:</dt>
<dd><dl class="first last docutils">
<dt>encoding - The Unicode encoding (or character set) of</dt>
<dd>the file.  The default is None, meaning the content
of the file is read as 8-bit characters and returned
as a list of (non-Unicode) str objects.</dd>
<dt>errors - How to handle Unicode errors; see help(str.decode)</dt>
<dd>for the options.  Default is &#8216;strict&#8217;</dd>
<dt>retain - If true, retain newline characters; but all newline</dt>
<dd>character combinations (&#8216;r&#8217;, &#8216;n&#8217;, &#8216;rn&#8217;) are
translated to &#8216;n&#8217;.  If false, newline characters are
stripped off.  Default is True.</dd>
</dl>
</dd>
</dl>
<p>This uses &#8216;U&#8217; mode in Python 2.3 and later.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.link">
<tt class="descname">link</tt><big>(</big><em>newpath</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.link" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hard link at &#8216;newpath&#8217;, pointing to this file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.listdir">
<tt class="descname">listdir</tt><big>(</big><big>)</big> &rarr; List of items in this directory.<a class="headerlink" href="#paver.deps.path3.path.listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Use D.files() or D.dirs() instead if you want a listing
of just files or just subdirectories.</p>
<p>The elements of the list are path objects.</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists
items whose names match the given pattern.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.lstat">
<tt class="descname">lstat</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.lstat" title="Permalink to this definition">¶</a></dt>
<dd><p>Like path.stat(), but do not follow symbolic links.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.makedirs">
<tt class="descname">makedirs</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.makedirs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.makedirs_p">
<tt class="descname">makedirs_p</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.makedirs_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.mkdir">
<tt class="descname">mkdir</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.mkdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.mkdir_p">
<tt class="descname">mkdir_p</tt><big>(</big><em>mode=511</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.mkdir_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.move">
<tt class="descname">move</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively move a file or directory to another location. This is
similar to the Unix &#8220;mv&#8221; command.</p>
<p>If the destination is a directory or a symlink to a directory, the source
is moved inside the directory. The destination path must not already
exist.</p>
<p>If the destination already exists but is not a directory, it may be
overwritten depending on os.rename() semantics.</p>
<p>If the destination is on our current filesystem, then rename() is used.
Otherwise, src is copied to the destination and then removed.
A lot more could be done here...  A look at a mv.c shows a lot of
the issues this implementation glosses over.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.mtime">
<tt class="descname">mtime</tt><a class="headerlink" href="#paver.deps.path3.path.mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Last-modified time of the file.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.name">
<tt class="descname">name</tt><a class="headerlink" href="#paver.deps.path3.path.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this file or directory without the full path.</p>
<p>For example, path(&#8216;/usr/local/lib/libpython.so&#8217;).name == &#8216;libpython.so&#8217;</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.namebase">
<tt class="descname">namebase</tt><a class="headerlink" href="#paver.deps.path3.path.namebase" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as path.name, but with one file extension stripped off.</p>
<p>For example, path(&#8216;/home/guido/python.tar.gz&#8217;).name     == &#8216;python.tar.gz&#8217;,
but          path(&#8216;/home/guido/python.tar.gz&#8217;).namebase == &#8216;python.tar&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.normcase">
<tt class="descname">normcase</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.normcase" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.normpath">
<tt class="descname">normpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.normpath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.open">
<tt class="descname">open</tt><big>(</big><em>mode='r'</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file.  Return a file object.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.owner">
<tt class="descname">owner</tt><a class="headerlink" href="#paver.deps.path3.path.owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the owner of this file or directory.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.parent">
<tt class="descname">parent</tt><a class="headerlink" href="#paver.deps.path3.path.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>This path&#8217;s parent directory, as a new path object.</p>
<p>For example, path(&#8216;/usr/local/lib/libpython.so&#8217;).parent == path(&#8216;/usr/local/lib&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.pathconf">
<tt class="descname">pathconf</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.pathconf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.read_hash">
<tt class="descname">read_hash</tt><big>(</big><em>hash_name</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.read_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate given hash for this file.</p>
<p>List of supported hashes can be obtained from hashlib package. This
reads the entire file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.read_hexhash">
<tt class="descname">read_hexhash</tt><big>(</big><em>hash_name</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.read_hexhash" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate given hash for this file, returning hexdigest.</p>
<p>List of supported hashes can be obtained from hashlib package. This
reads the entire file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.read_md5">
<tt class="descname">read_md5</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.read_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the md5 hash for this file.</p>
<p>This reads through the entire file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.readlink">
<tt class="descname">readlink</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.readlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result may be an absolute or a relative path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.readlinkabs">
<tt class="descname">readlinkabs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.readlinkabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result is always an absolute path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.realpath">
<tt class="descname">realpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.realpath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.relpath">
<tt class="descname">relpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.relpath" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this path as a relative path,
based from the current working directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.relpathto">
<tt class="descname">relpathto</tt><big>(</big><em>dest</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.relpathto" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a relative path from self to dest.</p>
<p>If there is no relative path from self to dest, for example if
they reside on different drives in Windows, then this returns
dest.abspath().</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.remove">
<tt class="descname">remove</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.remove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.remove_p">
<tt class="descname">remove_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.remove_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.removedirs">
<tt class="descname">removedirs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.removedirs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.removedirs_p">
<tt class="descname">removedirs_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.removedirs_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.rename">
<tt class="descname">rename</tt><big>(</big><em>new</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.rename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.renames">
<tt class="descname">renames</tt><big>(</big><em>new</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.renames" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.rmdir">
<tt class="descname">rmdir</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.rmdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.rmdir_p">
<tt class="descname">rmdir_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.rmdir_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.rmtree">
<tt class="descname">rmtree</tt><big>(</big><em>*args</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.rmtree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.rmtree_p">
<tt class="descname">rmtree_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.rmtree_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.samefile">
<tt class="descname">samefile</tt><big>(</big><em>otherfile</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.samefile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="paver.deps.path3.path.size">
<tt class="descname">size</tt><a class="headerlink" href="#paver.deps.path3.path.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of the file, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.splitall">
<tt class="descname">splitall</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.splitall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the path components in this path.</p>
<p>The first item in the list will be a path.  Its value will be
either os.curdir, os.pardir, empty, or the root directory of
this path (for example, &#8216;/&#8217; or &#8216;C:\&#8217;).  The other items in
the list will be strings.</p>
<p>path.path.joinpath(<a href="#id23"><span class="problematic" id="id24">*</span></a>result) will yield the original path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.splitdrive">
<tt class="descname">splitdrive</tt><big>(</big><big>)</big> &rarr; Return (p.drive, &lt;the rest of p&gt;).<a class="headerlink" href="#paver.deps.path3.path.splitdrive" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the drive specifier from this path.  If there is
no drive specifier, p.drive is empty, so the return value
is simply (path(&#8216;&#8217;), p).  This is always the case on Unix.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.splitext">
<tt class="descname">splitext</tt><big>(</big><big>)</big> &rarr; Return (p.stripext(), p.ext).<a class="headerlink" href="#paver.deps.path3.path.splitext" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the filename extension from this path and return
the two parts.  Either part may be empty.</p>
<p>The extension is everything from &#8216;.&#8217; to the end of the
last path segment.  This has the property that if
(a, b) == p.splitext(), then a + b == p.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.splitpath">
<tt class="descname">splitpath</tt><big>(</big><big>)</big> &rarr; Return (p.parent, p.name).<a class="headerlink" href="#paver.deps.path3.path.splitpath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.stat">
<tt class="descname">stat</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.stat" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a stat() system call on this path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.statvfs">
<tt class="descname">statvfs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.statvfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a statvfs() system call on this path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.stripext">
<tt class="descname">stripext</tt><big>(</big><big>)</big> &rarr; Remove one file extension from the path.<a class="headerlink" href="#paver.deps.path3.path.stripext" title="Permalink to this definition">¶</a></dt>
<dd><p>For example, path(&#8216;/home/guido/python.tar.gz&#8217;).stripext()
returns path(&#8216;/home/guido/python.tar&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.symlink">
<tt class="descname">symlink</tt><big>(</big><em>newlink</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a symbolic link at &#8216;newlink&#8217;, pointing here.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.text">
<tt class="descname">text</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read it in, return the content as a string.</p>
<p>This uses &#8216;U&#8217; mode in Python 2.3 and later, so &#8216;rn&#8217; and &#8216;r&#8217;
are automatically translated to &#8216;n&#8217;.</p>
<p>Optional arguments:</p>
<dl class="docutils">
<dt>encoding - The Unicode encoding (or character set) of</dt>
<dd>the file.  If present, the content of the file is
decoded and returned as a unicode object; otherwise
it is returned as an 8-bit str.</dd>
<dt>errors - How to handle Unicode errors; see help(str.decode)</dt>
<dd>for the options.  Default is &#8216;strict&#8217;.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.touch">
<tt class="descname">touch</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.touch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the access/modified times of this file to the current time.
Create the file if it does not exist.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.unlink">
<tt class="descname">unlink</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.unlink" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.unlink_p">
<tt class="descname">unlink_p</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.path3.path.unlink_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.utime">
<tt class="descname">utime</tt><big>(</big><em>times</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.utime" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the access and modified times of this file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.walk">
<tt class="descname">walk</tt><big>(</big><big>)</big> &rarr; iterator over files and subdirs, recursively.<a class="headerlink" href="#paver.deps.path3.path.walk" title="Permalink to this definition">¶</a></dt>
<dd><p>The iterator yields path objects naming each child item of
this directory and its descendants.  This requires that
D.isdir().</p>
<p>This performs a depth-first traversal of the directory tree.
Each directory is returned just before all its children.</p>
<p>The errors= keyword argument controls behavior when an
error occurs.  The default is &#8216;strict&#8217;, which causes an
exception.  The other allowed values are &#8216;warn&#8217;, which
reports the error via warnings.warn(), and &#8216;ignore&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.walkdirs">
<tt class="descname">walkdirs</tt><big>(</big><big>)</big> &rarr; iterator over subdirs, recursively.<a class="headerlink" href="#paver.deps.path3.path.walkdirs" title="Permalink to this definition">¶</a></dt>
<dd><p>With the optional &#8216;pattern&#8217; argument, this yields only
directories whose names match the given pattern.  For
example, mydir.walkdirs(&#8216;<a href="#id25"><span class="problematic" id="id26">*</span></a>test&#8217;) yields only directories
with names ending in &#8216;test&#8217;.</p>
<p>The errors= keyword argument controls behavior when an
error occurs.  The default is &#8216;strict&#8217;, which causes an
exception.  The other allowed values are &#8216;warn&#8217;, which
reports the error via warnings.warn(), and &#8216;ignore&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.walkfiles">
<tt class="descname">walkfiles</tt><big>(</big><big>)</big> &rarr; iterator over files in D, recursively.<a class="headerlink" href="#paver.deps.path3.path.walkfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>The optional argument, pattern, limits the results to files
with names that match the pattern.  For example,
mydir.walkfiles(&#8216;<a href="#id27"><span class="problematic" id="id28">*</span></a>.tmp&#8217;) yields only files with the .tmp
extension.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.write_bytes">
<tt class="descname">write_bytes</tt><big>(</big><em>bytes</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.write_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file and write the given bytes to it.</p>
<p>Default behavior is to overwrite any existing file.
Call p.write_bytes(bytes, append=True) to append instead.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.write_lines">
<tt class="descname">write_lines</tt><big>(</big><em>lines</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.write_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given lines of text to this file.</p>
<p>By default this overwrites any existing file at this path.</p>
<p>This puts a platform-specific newline sequence on every line.
See &#8216;linesep&#8217; below.</p>
<p>lines - A list of strings.</p>
<dl class="docutils">
<dt>encoding - A Unicode encoding to use.  This applies only if</dt>
<dd>&#8216;lines&#8217; contains any Unicode strings.</dd>
<dt>errors - How to handle errors in Unicode encoding.  This</dt>
<dd>also applies only to Unicode strings.</dd>
<dt>linesep - The desired line-ending.  This line-ending is</dt>
<dd>applied to every line.  If a line already has any
standard line ending (&#8216;r&#8217;, &#8216;n&#8217;, &#8216;rn&#8217;, u&#8217;x85&#8217;,
u&#8217;rx85&#8217;, u&#8217;u2028&#8217;), that will be stripped off and
this will be used instead.  The default is os.linesep,
which is platform-dependent (&#8216;rn&#8217; on Windows, &#8216;n&#8217; on
Unix, etc.)  Specify None to write the lines as-is,
like file.writelines().</dd>
</dl>
<p>Use the keyword argument append=True to append lines to the
file.  The default is to overwrite the file.  Warning:
When you use this with Unicode data, if the encoding of the
existing data in the file is different from the encoding
you specify with the encoding= parameter, the result is
mixed-encoding data, which can really confuse someone trying
to read the file later.</p>
</dd></dl>

<dl class="method">
<dt id="paver.deps.path3.path.write_text">
<tt class="descname">write_text</tt><big>(</big><em>text</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.deps.path3.path.write_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given text to this file.</p>
<p>The default behavior is to overwrite any existing file;
to append instead, use the &#8216;append=True&#8217; keyword argument.</p>
<p>There are two differences between path.write_text() and
path.write_bytes(): newline handling and Unicode handling.
See below.</p>
<p>Parameters:</p>
<blockquote>
<div><ul class="simple">
<li>text - str/unicode - The text to be written.</li>
<li>encoding - str - The Unicode encoding that will be used.
This is ignored if &#8216;text&#8217; isn&#8217;t a Unicode string.</li>
<li>errors - str - How to handle Unicode encoding errors.
Default is &#8216;strict&#8217;.  See help(unicode.encode) for the
options.  This is ignored if &#8216;text&#8217; isn&#8217;t a Unicode
string.</li>
<li>linesep - keyword argument - str/unicode - The sequence of
characters to be used to mark end-of-line.  The default is
os.linesep.  You can also specify None; this means to
leave all newlines as they are in &#8216;text&#8217;.</li>
<li>append - keyword argument - bool - Specifies what to do if
the file already exists (True: append to the end of it;
False: overwrite it.)  The default is False.</li>
</ul>
</div></blockquote>
<p>&#8212; Newline handling.</p>
<p>write_text() converts all standard end-of-line sequences
(&#8216;n&#8217;, &#8216;r&#8217;, and &#8216;rn&#8217;) to your platform&#8217;s default end-of-line
sequence (see os.linesep; on Windows, for example, the
end-of-line marker is &#8216;rn&#8217;).</p>
<p>If you don&#8217;t like your platform&#8217;s default, you can override it
using the &#8216;linesep=&#8217; keyword argument.  If you specifically want
write_text() to preserve the newlines as-is, use &#8216;linesep=None&#8217;.</p>
<p>This applies to Unicode text the same as to 8-bit text, except
there are three additional standard Unicode end-of-line sequences:
u&#8217;x85&#8217;, u&#8217;rx85&#8217;, and u&#8217;u2028&#8217;.</p>
<p>(This is slightly different from when you open a file for
writing with fopen(filename, &#8220;w&#8221;) in C or open(filename, &#8216;w&#8217;)
in Python.)</p>
<p>&#8212; Unicode</p>
<p>If &#8216;text&#8217; isn&#8217;t Unicode, then apart from newline handling, the
bytes are written verbatim to the file.  The &#8216;encoding&#8217; and
&#8216;errors&#8217; arguments are not used and must be omitted.</p>
<p>If &#8216;text&#8217; is Unicode, it is first converted to bytes using the
specified &#8216;encoding&#8217; (or the default encoding if &#8216;encoding&#8217;
isn&#8217;t specified).  The &#8216;errors&#8217; argument applies only to this
conversion.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-paver.deps.six">
<span id="paver-deps-six-module"></span><h2>paver.deps.six module<a class="headerlink" href="#module-paver.deps.six" title="Permalink to this headline">¶</a></h2>
<p>Utilities for writing code that runs on Python 2 and 3</p>
<dl class="class">
<dt id="paver.deps.six.Iterator">
<em class="property">class </em><tt class="descclassname">paver.deps.six.</tt><tt class="descname">Iterator</tt><a class="headerlink" href="#paver.deps.six.Iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="paver.deps.six.Iterator.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.deps.six.Iterator.next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="paver.deps.six.MovedAttribute">
<em class="property">class </em><tt class="descclassname">paver.deps.six.</tt><tt class="descname">MovedAttribute</tt><big>(</big><em>name</em>, <em>old_mod</em>, <em>new_mod</em>, <em>old_attr=None</em>, <em>new_attr=None</em><big>)</big><a class="headerlink" href="#paver.deps.six.MovedAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">paver.deps.six._LazyDescr</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="paver.deps.six.MovedModule">
<em class="property">class </em><tt class="descclassname">paver.deps.six.</tt><tt class="descname">MovedModule</tt><big>(</big><em>name</em>, <em>old</em>, <em>new=None</em><big>)</big><a class="headerlink" href="#paver.deps.six.MovedModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">paver.deps.six._LazyDescr</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.add_move">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">add_move</tt><big>(</big><em>move</em><big>)</big><a class="headerlink" href="#paver.deps.six.add_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to six.moves.</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.b">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">b</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#paver.deps.six.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Byte literal</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.exec_">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">exec_</tt><big>(</big><em>code</em>, <em>globs=None</em>, <em>locs=None</em><big>)</big><a class="headerlink" href="#paver.deps.six.exec_" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute code in a namespace.</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.get_unbound_function">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">get_unbound_function</tt><big>(</big><em>unbound</em><big>)</big><a class="headerlink" href="#paver.deps.six.get_unbound_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the function out of a possibly unbound function</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.iteritems">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">iteritems</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#paver.deps.six.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the (key, value) pairs of a dictionary.</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.iterkeys">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">iterkeys</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#paver.deps.six.iterkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the keys of a dictionary.</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.itervalues">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">itervalues</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#paver.deps.six.itervalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the values of a dictionary.</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.print_">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">print_</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#paver.deps.six.print_" title="Permalink to this definition">¶</a></dt>
<dd><p>The new-style print function.</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.remove_move">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">remove_move</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#paver.deps.six.remove_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove item from six.moves.</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.reraise">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">reraise</tt><big>(</big><em>tp</em>, <em>value</em>, <em>tb=None</em><big>)</big><a class="headerlink" href="#paver.deps.six.reraise" title="Permalink to this definition">¶</a></dt>
<dd><p>Reraise an exception.</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.u">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">u</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#paver.deps.six.u" title="Permalink to this definition">¶</a></dt>
<dd><p>Text literal</p>
</dd></dl>

<dl class="function">
<dt id="paver.deps.six.with_metaclass">
<tt class="descclassname">paver.deps.six.</tt><tt class="descname">with_metaclass</tt><big>(</big><em>meta</em>, <em>base=&lt;type 'object'&gt;</em><big>)</big><a class="headerlink" href="#paver.deps.six.with_metaclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a base class with a metaclass.</p>
</dd></dl>

</div>
<div class="section" id="module-paver.deps">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-paver.deps" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">paver.deps package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-paver.deps.path2">paver.deps.path2 module</a></li>
<li><a class="reference internal" href="#module-paver.deps.path3">paver.deps.path3 module</a></li>
<li><a class="reference internal" href="#module-paver.deps.six">paver.deps.six module</a></li>
<li><a class="reference internal" href="#module-paver.deps">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="paver.html"
                        title="previous chapter">paver package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="paver.tests.html"
                        title="next chapter">paver.tests package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/paver.deps.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="paver.tests.html" title="paver.tests package"
             >next</a> |</li>
        <li class="right" >
          <a href="paver.html" title="paver package"
             >previous</a> |</li>
        <li><a href="../index.html">Paver 1.2.3 documentation</a> &raquo;</li>
          <li><a href="../paverfullapi.html" >Complete API Reference</a> &raquo;</li>
          <li><a href="paver.html" >paver package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, SitePen, Inc..
      Last updated on Aug 10, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>