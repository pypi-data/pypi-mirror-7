/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "DataView.h"


#ifndef _MSC_VER
void asn1SccT_INTEGER_Initialize(asn1SccT_INTEGER* pVal)
{
    static asn1SccT_INTEGER ret = 
        0;
    *pVal = ret;
}
#endif

 
flag asn1SccT_INTEGER_IsConstraintValid(const asn1SccT_INTEGER* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 255);
	*pErrCode = ret ? 0 : ERR_asn1SccT_INTEGER;

	return ret;
}

flag asn1SccT_INTEGER_Equal(const asn1SccT_INTEGER* pVal1, const asn1SccT_INTEGER* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}
#ifndef _MSC_VER
void asn1SccT_SEQ_howareyou_Initialize(asn1SccT_SEQ_howareyou* pVal)
{
    static asn1SccT_SEQ_howareyou ret = 
        {
            .kind = choice_A_PRESENT,
            .u = { .choice_A = 0}
        };
    *pVal = ret;
}
#endif

 
flag asn1SccT_SEQ_howareyou_IsConstraintValid(const asn1SccT_SEQ_howareyou* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case choice_A_PRESENT :
	        ret = asn1SccT_INTEGER_IsConstraintValid(&pVal->u.choice_A, pErrCode);
	        break;
	    case choice_B_PRESENT :
	        ret = asn1SccT_INTEGER_IsConstraintValid(&pVal->u.choice_B, pErrCode);
	        break;
	    default:
		    *pErrCode = ERR_asn1SccT_SEQ_howareyou_unknown_choice_index;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag asn1SccT_SEQ_howareyou_Equal(const asn1SccT_SEQ_howareyou* pVal1, const asn1SccT_SEQ_howareyou* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->kind == pVal2->kind);
	if (ret) {
		switch(pVal1->kind) 
		{
		case choice_A_PRESENT:
			ret = asn1SccT_INTEGER_Equal(&pVal1->u.choice_A, &pVal2->u.choice_A);
			break;
		case choice_B_PRESENT:
			ret = asn1SccT_INTEGER_Equal(&pVal1->u.choice_B, &pVal2->u.choice_B);
			break;
		default:
			ret = FALSE;    //COVERAGE_IGNORE
		}
	}

	return ret;
}
#ifndef _MSC_VER
void asn1SccT_SEQ_world_Initialize(asn1SccT_SEQ_world* pVal)
{
    static asn1SccT_SEQ_world ret = 
        asn1Scchop;
    *pVal = ret;
}
#endif

 
flag asn1SccT_SEQ_world_IsConstraintValid(const asn1SccT_SEQ_world* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag asn1SccT_SEQ_world_Equal(const asn1SccT_SEQ_world* pVal1, const asn1SccT_SEQ_world* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}
#ifndef _MSC_VER
void asn1SccT_SEQ_hello_Initialize(asn1SccT_SEQ_hello* pVal)
{
    static asn1SccT_SEQ_hello ret = 
        0;
    *pVal = ret;
}
#endif

 
flag asn1SccT_SEQ_hello_IsConstraintValid(const asn1SccT_SEQ_hello* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 10);
	*pErrCode = ret ? 0 : ERR_asn1SccT_SEQ_hello;

	return ret;
}

flag asn1SccT_SEQ_hello_Equal(const asn1SccT_SEQ_hello* pVal1, const asn1SccT_SEQ_hello* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}
#ifndef _MSC_VER
void asn1SccT_SEQ_Initialize(asn1SccT_SEQ* pVal)
{
    static asn1SccT_SEQ ret = 
        {
            .hello = 0,
            .world = asn1Scchop,
            .howareyou = {
                .kind = choice_A_PRESENT,
                .u = { .choice_A = 0}
            }
        };
    *pVal = ret;
}
#endif

 
flag asn1SccT_SEQ_IsConstraintValid(const asn1SccT_SEQ* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_SEQ_hello_IsConstraintValid(&pVal->hello, pErrCode);
	if (ret) {
	    ret = asn1SccT_SEQ_world_IsConstraintValid(&pVal->world, pErrCode);
	    if (ret) {
	        ret = asn1SccT_SEQ_howareyou_IsConstraintValid(&pVal->howareyou, pErrCode);

	    }
	}

	return ret;
}

flag asn1SccT_SEQ_Equal(const asn1SccT_SEQ* pVal1, const asn1SccT_SEQ* pVal2)
{
	flag ret=TRUE;
	
	ret = asn1SccT_SEQ_hello_Equal(&pVal1->hello, &pVal2->hello);
	if (ret) {
	    ret = asn1SccT_SEQ_world_Equal(&pVal1->world, &pVal2->world);
	    if (ret) {
	        ret = asn1SccT_SEQ_howareyou_Equal(&pVal1->howareyou, &pVal2->howareyou);

	    }
	}

	return ret;
}
#ifndef _MSC_VER
void asn1SccT_POS_y_b_Initialize(asn1SccT_POS_y_b* pVal)
{
    static asn1SccT_POS_y_b ret = 
        {    .arr = 
            {
                FALSE,
                FALSE,
                FALSE        
            }
        };
    *pVal = ret;
}
#endif

 
flag asn1SccT_POS_y_b_IsConstraintValid(const asn1SccT_POS_y_b* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;
	int i1=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	i1 = 0;
	while (ret && (i1< 3)) {
	    ret = TRUE; *pErrCode = 0;
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccT_POS_y_b_Equal(const asn1SccT_POS_y_b* pVal1, const asn1SccT_POS_y_b* pVal2)
{
	flag ret=TRUE;
	int i1=0;
	
	for(i1 = 0; ret && i1<3; i1++) 
	{
		ret = ( (pVal1->arr[i1] && pVal2->arr[i1]) || (!pVal1->arr[i1] && !pVal2->arr[i1]));
	}

	return ret;
}
#ifndef _MSC_VER
void asn1SccT_POS_y_Initialize(asn1SccT_POS_y* pVal)
{
    static asn1SccT_POS_y ret = 
        {
            .a = FALSE,
            .b = {    .arr = 
                {
                    FALSE,
                    FALSE,
                    FALSE        
                }
            }
        };
    *pVal = ret;
}
#endif

 
flag asn1SccT_POS_y_IsConstraintValid(const asn1SccT_POS_y* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	if (ret) {
	    ret = asn1SccT_POS_y_b_IsConstraintValid(&pVal->b, pErrCode);

	}

	return ret;
}

flag asn1SccT_POS_y_Equal(const asn1SccT_POS_y* pVal1, const asn1SccT_POS_y* pVal2)
{
	flag ret=TRUE;
	
	ret = ( (pVal1->a && pVal2->a) || (!pVal1->a && !pVal2->a));
	if (ret) {
	    ret = asn1SccT_POS_y_b_Equal(&pVal1->b, &pVal2->b);

	}

	return ret;
}
#ifndef _MSC_VER
void asn1SccT_POS_Initialize(asn1SccT_POS* pVal)
{
    static asn1SccT_POS ret = 
        {
            .x = 0,
            .y = {
                .a = FALSE,
                .b = {    .arr = 
                    {
                        FALSE,
                        FALSE,
                        FALSE        
                    }
                }
            },
            .z = {
                .hello = 0,
                .world = asn1Scchop,
                .howareyou = {
                    .kind = choice_A_PRESENT,
                    .u = { .choice_A = 0}
                }
            }
        };
    *pVal = ret;
}
#endif

 
flag asn1SccT_POS_IsConstraintValid(const asn1SccT_POS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_INTEGER_IsConstraintValid(&pVal->x, pErrCode);
	if (ret) {
	    ret = asn1SccT_POS_y_IsConstraintValid(&pVal->y, pErrCode);
	    if (ret) {
	        ret = asn1SccT_SEQ_IsConstraintValid(&pVal->z, pErrCode);

	    }
	}

	return ret;
}

flag asn1SccT_POS_Equal(const asn1SccT_POS* pVal1, const asn1SccT_POS* pVal2)
{
	flag ret=TRUE;
	
	ret = asn1SccT_INTEGER_Equal(&pVal1->x, &pVal2->x);
	if (ret) {
	    ret = asn1SccT_POS_y_Equal(&pVal1->y, &pVal2->y);
	    if (ret) {
	        ret = asn1SccT_SEQ_Equal(&pVal1->z, &pVal2->z);

	    }
	}

	return ret;
}

asn1SccT_SEQ myVar = {
    .hello = 4,
    .world = asn1Scchop,
    .howareyou = {
        .kind = choice_B_PRESENT,
        .u = { .choice_B = 42}
    }
};
