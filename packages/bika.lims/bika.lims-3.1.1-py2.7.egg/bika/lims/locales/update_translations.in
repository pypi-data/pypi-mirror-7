#!/usr/bin/env python
"""

Buildout template for regenerating translations catalogs and keeping locale
folders up-to-date.

### Edit buildout.cfg:

    parts =
        ...
        update_translations
        i118ndude

    [update_translations]
    recipe = collective.recipe.template
    output = ${buildout:directory}/bin/update_translations
    input = ${buildout:directory}/src/bika.lims/bika/lims/locales/update_translations.in
    mode = 755
    domain_entries = \
        [
            # One dictionary added to this list for every POT file that must be updated and synced:
            #    "locales_path": The path of the source repository's locales folder, contains domain.pot
            #    "domain": The domain name to be updated
            #    "txresource": The transifex resource name for this project/domain
            #    "scan_path": The path of the top-level folder that i18ndude will search for this domain
            #    "extends_pot": Messages present inside this POT file, are filtered from the scanned results
            #    "overrides_pot": Translations in this POT file override all others and are always included
            { "locales_path": "${buildout:directory}/src/bika.lims/bika/lims/locales",
              "domain": "bika",
              "txresource": "bika-lims.bika",
              "scan_path": "${buildout:directory}/src/bika.lims",
              "extends_pot": "",
              "overrides_pot": "bika-manual.pot"},
            { "locales_path": "${buildout:directory}/src/bika.lims/bika/lims/locales",
              "domain": "plone",
              "txresource": "bika-lims.plone",
              "scan_path": "${buildout:directory}/src/bika.lims/bika/lims/profiles",
              "extends_pot": "${buildout:directory}/parts/omelette/plone/app/locales/locales/plone.pot",
              "overrides_pot": "plone-manual.pot"},
        ]

    [i18ndude]
    unzip = true
    recipe = zc.recipe.egg
    eggs = i18ndude

run bin/buildout after updating buildout.cfg

### Regenerate translations

    bin/update_translations

"""

from commands import getoutput
from glob import glob
from os.path import join as j, exists
import json
import os
import sys
import subprocess as subp

# Grab settings from buildout.cfg
domain_entries = ${domain_entries}

i18ndude = "${buildout:directory}/bin/i18ndude"

def call(cmd_str, prn_cmd=True, prn_out=True, pause=False, success_codes=[0,], trap_stdout=True):
    if prn_cmd:
        print(">>> " + cmd_str)
    if pause:
        raw_input()
    cmd = cmd_str.split()
    if trap_stdout:
        proc = subp.Popen(cmd, stdout=subp.PIPE)
    else:
        proc = subp.Popen(cmd)
    out = proc.communicate()[0]
    rc = proc.returncode
    if rc not in success_codes:
        raise Exception("Failure, return code %s"%rc)
    if trap_stdout:
        lines = out.rstrip().split('\n')
        l = [line for line in lines if line]
        if l and prn_out:
            print("\n".join(l))
        return (rc, "\n".join(lines))
    else:
        return (rc, "")

def which(executable):
    """
    Finds executable in PATH environment variable
    """
    for dirname in os.environ['PATH'].split(os.path.pathsep):
        trypath = os.path.join(dirname, executable)
        if os.path.isfile(trypath) and os.access(trypath, os.X_OK):
            return trypath

msgfmt = which('msgfmt')
if not msgfmt:
    raise Exception('msgfmt executable not found on your $PATH.  Install gettext.')
msgcat = which('msgcat')
if not msgcat:
    raise Exception('msgcat executable not found on your $PATH.  Install gettext.')

for domain_entry in domain_entries:

    locales_path = domain_entry["locales_path"]
    domain = domain_entry.get("domain")
    scan_path = domain_entry["scan_path"]
    extends_pot = domain_entry.get("extends_pot")
    overrides_pot = domain_entry.get("overrides_pot")
    txresource = domain_entry.get("txresource")
    txresource = " -r %s"%txresource if txresource else ""
    pot = domain + ".pot"
    i18ndude_pot = domain + "-i18ndude.pot"
    tmp_pot = domain + "-tmp.pot"

    print "---------- %s (%s)" % (locales_path, domain)
    os.chdir(locales_path)

    ### Transifex - pull
    # We assume the translations from transifex will always be
    # recent than translations done in local .po files.
    # At least, all the community is asked to translate the project
    # by using transifex, not .po files locally and by using git
    # we also assert that, without being able to do the tx pull, we can not proceed,
    # as this may remove translated entries from the transifex po files.
    call("tx pull -a -f%s" % txresource, trap_stdout=False)

    ### 1. Re-scan source for new strings (into *-i18ndude.pot)
    call("{i18ndude} rebuild-pot --pot {i18ndude_pot}  --exclude 'build' --create {domain} {scan_path}".format(**locals()))

    ### 2. Remove redundant (already translated) entries
    if extends_pot:
        lines = call("{i18ndude} filter {i18ndude_pot} {extends_pot}".format(**locals()), prn_out=False)[1]
        open(tmp_pot, "w").write(lines)
        os.remove(i18ndude_pot)
    else:
        print "No base POT file specified: rename %s -> %s" % (i18ndude_pot, tmp_pot)
        os.rename(i18ndude_pot, tmp_pot)

    ### 3. Forced overrides for this domain
    if overrides_pot:
        lines = call("{msgcat} --strict --use-first {overrides_pot} {tmp_pot}".format(**locals()), prn_out=False)[1]
        open(pot, "w").write(lines)
        os.remove(tmp_pot)
    else:
        print "No overrides POT file specified: rename %s -> %s" % (tmp_pot, pot)
        os.rename(tmp_pot, pot)

    ### 4. sync
    print ">>> running 'i18ndude sync' and 'msgfmt' for all languages"
    for lang in glob(j(locales_path, "*")):
        if exists(j(locales_path, lang, "LC_MESSAGES")):
            mo = j(lang, "LC_MESSAGES", domain + ".mo")
            po = j(lang, "LC_MESSAGES", domain + ".po")
            call("{i18ndude} sync --pot {pot} {po}".format(**locals()), prn_cmd=False)
            call("{msgfmt} -f -o {mo} {po}".format(**locals()), prn_cmd=False)

    ### Transifex - pull everything
    if exists(".tx"):
        print "Press Y<Enter> to push to Transifex.  Just press <Enter> to skip."
        if raw_input().strip().lower() == 'y':
            call("tx push -s -t%s"%txresource , trap_stdout=False)
