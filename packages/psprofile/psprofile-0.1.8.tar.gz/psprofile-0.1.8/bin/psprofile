#!/usr/bin/env python
import time
import os
import sys
import json
import subprocess as sp
from psprofile.main import main

from psprofile.util import which

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Profile resource usage of a command')
    parser.add_argument('-o', '--output_file', help='File to store output of profile to.')
    parser.add_argument('-i', '--poll_interval', type=int, default=1,
                        help='How often to poll the resource usage information in /proc, in seconds (default 1).')
    #parser.add_argument('command_script', help="path to a shell script to run")
    parser.add_argument('-w', '--wait', help="time to wait for executable to exist")
    parser.add_argument('-s','--shell', help="Shell to execute command with, default is /bin/bash", default='/bin/bash')
    parser.add_argument('command', nargs='+', help="The command to run.")
    args = parser.parse_args()

    start = time.time()
    bin = args.command[0].split(' ')[0]
    while not (os.path.exists(bin) or which(bin)):
        if time.time() - start > args.wait:
            raise IOError('`%s` does not exist!' % bin)
        time.sleep(.5)

    # Run Profile
    output = main(args.command, args.poll_interval, args.shell)

    # Write output
    output_json = json.dumps(output, indent=4)

    if args.output_file:
        # if os.path.exists(args.output_file):
        #     os.unlink(args.output_file)
        with open(args.output_file, 'w') as fh:
            fh.write(output_json)
    else:
        print >> sys.stdout, output_json

    sys.exit(output['exit_status'])