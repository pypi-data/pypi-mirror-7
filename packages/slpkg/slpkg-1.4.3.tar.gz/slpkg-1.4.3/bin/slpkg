#!/usr/bin/python
# -*- coding: utf-8 -*-



'''Utility to help package management in Slackware.
Slpkg is a terminal tool in order to easy use Slackware packages.


It's a quick and easy way to manage your packages in Slackware to a command.



usage: slpkg [-h] [-v] [-s script [source ...]] [-l all, sbo [all, sbo ...]]
             [-t] [-n] [-c] [-b] [-i  [...]] [-u  [...]] [-a  [...]]
             [-r  [...]] [-f  [...]] [-d  [...]]

Utility to help package management in Slackware

optional arguments:
  -h, --help            show this help message and exit
  -v, --verbose         print version and exit
  -s script [source ...]
                        auto build package
  -l all, sbo [all, sbo ...]
                        list of installed packages
  -t                    tracking dependencies
  -n                    find from SBo repositority
  -c                    check if your package is up to date
  -b                    download, build & install pkg from SBo
  -i  [ ...]            install binary packages
  -u  [ ...]            install-upgrade packages with new
  -a  [ ...]            reinstall the same packages
  -r  [ ...]            remove packages
  -f  [ ...]            find if packages installed
  -d  [ ...]            display the contents of the packages'''




import os
import re
import sys
import shutil
import tarfile
import getpass
import urllib2
import argparse
import subprocess



__author__ = "dslackw"
__version__ = "1.4.3"
__license__ = "GNU General Public License v3 (GPLv3)"
__email__ = "d.zlatanidis@gmail.com"


# grep computer architecture
uname = os.uname()
arch = (uname[4])


# SBo fietype packages
SBo_arch = "-" + arch + "-"
SBo_tag = "?_SBo"
SBo_filetype = ".tgz"


# create tmp directory
os.system("mkdir -p /tmp/slpkg/readme/")


# path file record
packages = "/var/log/packages/"
tmp = "/tmp/"


# create dependencies list
dep_results = []
dep_links_results = []


# SlackBuilds repository link
SBo_url = "http://slackbuilds.org/repository/14.1/"


# create repository list
repository = ("academic", "business", "games", "ham",
	      "misc", "office", "ruby", "accessibility",
	      "desktop", "gis", "haskell", "multimedia",
	      "perl", "system", "audio", "development",
	      "graphics", "libraries", "network", "python")



# print out colors class
class colors:
	RED = "\x1b[31m"
	GREEN = "\x1b[32m"
	YELLOW = "\x1b[33m"
	CYAN = "\x1b[36m"
	ENDC = "\x1b[0m"



# check if user is root
def s_user(user):
	if user == "root":
		pass
	else:
		print
		print ("{}Must have {}`root`{} privileges ...{}\n".format(colors.RED, 
			  colors.GREEN, colors.RED, colors.ENDC))
		sys.exit()



# remove unused chars
def rmv_unused(name):
	rmv = "><"
        for i in rmv:
		name = name.replace(i, "")

	return name

# get filename from links
def get_file(link, char):
	j = 0
	results = []
	for i in link:
        	j += 1
	        results.append(link[-j:])

        	for file in results:
                	if file.startswith(char):
                        	file = file
	                        break

	file = file.replace(char, "") # remove first char "/" from string
	file = file.strip(" ") # remove spaces from string

	return file



# this fuction return if the package exist
def find_package(find_pkg, directory):
	results = []

	for file in os.listdir(directory):
    		if file.startswith(find_pkg):
          		results.append(file)

	return results



# open url and read page
def url_read(name):
	f = urllib2.urlopen(name)
        read_page = f.read()
	
	return read_page



# read SBo README 
def read_readme(SBo_url, name, site):
	SBo_url = SBo_url + site
        SBo_url = SBo_url.replace("repository", "slackbuilds")
        readme = url_read(SBo_url)
	
	file = open("/tmp/slpkg/readme/" + name + "." + site, "w")
	file.write(readme)
	file.close()



# read SBo .info 
def read_info_slackbuild(SBo_url, name, site):
	SBo_url = SBo_url + name + site
        SBo_url = SBo_url.replace("repository", "slackbuilds")
        info = url_read(SBo_url)

        file = open("/tmp/slpkg/readme/" + name + site, "w")
        file.write(info)
        file.close()



# search and found slackbuilds packages links from http://slackbuilds.org
def SBo_search_pkg(name):
	i = 0
	search_name = re.escape(name) # escapes characters from names like `+`
	search_name = ">" + search_name + "<" # add special characters to name >< for clean searching result

	toolbar_width = len(repository)
	sys.stdout.write("Searching `" + name + "` from slackbuilds.org .%s " % (" " * toolbar_width))

	# setup toolbar
	sys.stdout.flush()
	sys.stdout.write("\b" * (toolbar_width+1))
	for i in repository:

	        # update the bar
		sys.stdout.write(".")
		sys.stdout.flush()
		SBo_url_sub = SBo_url + i + "/"
		find_SBo = re.findall(search_name, url_read(SBo_url_sub))

		find_SBo = " ".join(find_SBo) # convert list to string
		find_SBo = rmv_unused(find_SBo) # remove unused chars '> <'

		# find sub-category
		if name in find_SBo:
			name = SBo_url_sub + name + "/"
		
			return name



# find slackbuild download
def SBo_slackbuild_dwn(SBo_url, name):
        SBo_url = SBo_url.replace(name + "/", name + ".tar.gz")
	SBo_url = SBo_url.replace("repository", "slackbuilds")

        return SBo_url



# find source downloads
def SBo_source_dwn(SBo_url, name):
        SBo_url = SBo_url + name + ".info"
        SBo_url = SBo_url.replace("repository", "slackbuilds")
	read_info = url_read(SBo_url)

	# read lines from .info files grep download line and return source link
	if arch == "x86_64":
		for line in read_info.splitlines():
			if line.startswith('DOWNLOAD_x86_64='):
				arch_x86_64_len = len(line)
				if arch_x86_64_len > 18:
	                       		line = line[17:-1]

					return line
				else:
					for line in read_info.splitlines():
	        				if line.startswith('DOWNLOAD='):
			                        	line = line[10:-1]

							return line



# find extra source downloads
def SBo_extra_dwn(SBo_url, name):
	SBo_url = SBo_url + name + ".info"
	SBo_url = SBo_url.replace("repository", "slackbuilds")
	read_info = url_read(SBo_url)
	results = []

	for line in read_info.splitlines():
                if line.startswith(' '):
                        line = line[10:-1]
		if line.startswith('http'):
			results.append(line)
			
	return results



# search for package requirements
def SBo_requires_pkg(SBo_url, name):
	SBo_url = SBo_url + name + ".info"
	SBo_url = SBo_url.replace("repository", "slackbuilds")

	read_info = url_read(SBo_url)

	for line in read_info.splitlines():
		if line.startswith('REQUIRES="'):
			line = line[10:-1]	


			return line



# search for package dependencies
def SBo_dependencies_pkg(name):
        if name == "%README%": # avoid to search %README% as dependency
                pass
        else:
                SBo_url = SBo_search_pkg(name)
                if SBo_url == None:
                        print ("\n")
                        print ("{}The {}'{}'{} not found{}\n".format(colors.RED,
                                colors.CYAN, name, colors.RED, colors.ENDC))

                else:
                        SBo_req = SBo_requires_pkg(SBo_url, name)
                        dependencies = SBo_req.split() # convert string to list

                        if dependencies == []:
                                pass
                        else:
                                dep_results.append(dependencies)

                        for line in dependencies:
                                print
                                SBo_dependencies_pkg(line)
			
			return dep_results



# search for package dependencies
def SBo_dependencies_links_pkg(name):
	if name == "%README%": # avoid to search %README% as dependency
		pass
	else:

		SBo_url = SBo_search_pkg(name)

		if SBo_url == None:
	        	print ("\n")
	                print ("{}The {}'{}'{} not found{}\n".format(colors.RED,
              		        colors.CYAN, name, colors.RED, colors.ENDC))

		else:
			version = SBo_version_pkg(SBo_url, name).split()
			SBo_dwn = SBo_slackbuild_dwn(SBo_url, name).split()
	                source_dwn = SBo_source_dwn(SBo_url, name).split()
			extra_dwn = SBo_extra_dwn(SBo_url, name)
			SBo_req = SBo_requires_pkg(SBo_url, name).split()

			# create flag to know how much extra source there are
			if extra_dwn != []:
				flag = ("extra" + str(len(extra_dwn))).split()
				dep_links_results.append(flag)

			dep_links_results.append(extra_dwn)
			dep_links_results.append(version)
			dep_links_results.append(source_dwn)
	                dep_links_results.append(SBo_dwn)

			if SBo_req == []:
				pass
		
			else:
				dep_links_results.append(SBo_req)

				for line in SBo_req:
					print
					SBo_dependencies_links_pkg(line)


			return dep_links_results



# find from www.slackbuilds.org the version of the package
def SBo_version_pkg(SBo_url, name):
	SBo_url = SBo_url + name + ".info"
	SBo_url = SBo_url.replace("repository", "slackbuilds")
	read_info = url_read(SBo_url)

	for line in read_info.splitlines():
                if line.startswith('VERSION="'):
                        line = line[9:-1]

                        return line	



# auto build package from slackbuild script
def build_package(script, source):
	slack_script = script
        source_tar = source
 
       # remove file type from slackbuild script and store the name
        pkg_name = slack_script.replace(".tar.gz", "")

        path = subprocess.check_output(["pwd"], shell=True).replace("\n", "/")
	try:
		tar = tarfile.open(slack_script)
		tar.extractall()
		tar.close()
		shutil.copy2(source_tar, pkg_name)
	        os.chdir(path + pkg_name)
	       	os.system("sh {}{}{}".format(path, pkg_name + "/", pkg_name + ".SlackBuild"))	
		os.chdir(path)
	except (OSError, IOError):
		print
		print ("{}Wrong file name, Please try again...{}\n".format(colors.RED, 
			colors.ENDC))



# build package with extra source
def build_extra_pkg(script, source, extra):
	slack_script = script  
        source_tar = source  
	extra_source = extra 

       # remove file type from slackbuild script and store the name
        pkg_name = slack_script.replace(".tar.gz", "")

        path = subprocess.check_output(["pwd"], shell=True).replace("\n", "/")
	try:
		tar = tarfile.open(slack_script)
       		tar.extractall()
	        tar.close()
		shutil.copy2(source_tar, pkg_name)
		shutil.copy2(extra_source, pkg_name)
        	os.chdir(path + pkg_name)
	        os.system("sh {}{}{}".format(path, pkg_name + "/", pkg_name + ".SlackBuild"))
	except (OSError, IOError):
		print
                print ("{}Wrong file name, Please try again...{}\n".format(colors.RED,
                       colors.ENDC))



# build package with extra-extra sources
def build_extra2_pkg(script, source, extra, extra2):
        slack_script = script
        source_tar = source
        extra_source = extra
	extra2_source = extra2

       # remove file type from slackbuild script and store the name
        pkg_name = slack_script.replace(".tar.gz", "")

        path = subprocess.check_output(["pwd"], shell=True).replace("\n", "/")
        try:
                tar = tarfile.open(slack_script)
                tar.extractall()
                tar.close()
                shutil.copy2(source_tar, pkg_name)
                shutil.copy2(extra_source, pkg_name)
		shutil.copy2(extra2_source, pkg_name)
                os.chdir(path + pkg_name)
                os.system("sh {}{}{}".format(path, pkg_name + "/", pkg_name + ".SlackBuild"))
        except (OSError, IOError):
                print
                print ("{}Wrong file name, Please try again...{}\n".format(colors.RED,
                        colors.ENDC))



# print version
def pkg_version():
        print ("Version: {}".format(__version__))
        print ("Licence: {}".format(__license__))
        print ("Email  : {}".format(__email__))



# build packages 
def pkg_slackbuild(name):
	 s_user(getpass.getuser())	
	 if len(name) == 2:
        	 build_package(name[0], name[1])
         elif len(name) == 3:
                 build_extra_pkg(name[0],
                 name[1], name[2])
         elif len(name) == 4:
                 build_extra2_pkg(name[0], name[1],
                 name[2], name[3])
         elif len(name) > 4:
                 print
                 print ("{}Not supported with more than four arguments{}\n".format(colors.RED,
                 	colors.ENDC))
	 elif len(name) == 1:
		 print
	         print ("{}Must enter at least two arguments{}\n".format(colors.RED,
                        colors.ENDC))


# view list of installed packages
def pkg_list(name):
        if "all" in name:
                print
                os.chdir(packages)
                os.system("ls * | more")
                print

        if "sbo" in name:
                print
                os.chdir(packages)
                os.system("ls * | grep 'SBo' | more")
                print


# find all dependencies
def pkg_tracking(name):
	dependencies = SBo_dependencies_pkg(name)
	if dependencies == None:
		pass

	elif dependencies == []:
		print ("\n")
		print ("{}No dependencies\n{}".format(colors.GREEN, colors.ENDC))
	else:
	        print ("\n")
       		pkg_len = len(name) + 18
	        print ("+" + "=" * pkg_len)
	        print ("| {}`{}' {}dependencies :{}".format(colors.CYAN, name,
        		colors.YELLOW, colors.ENDC))
	        print ("+" + "=" * pkg_len)
	        dependencies.reverse()


		print (" |")
	        for i in range(len(dependencies)):
		        found = " --", str(len(dependencies[i])), " ".join(dependencies[i])
	                print (" |")
		        print " ".join(found)
	        print



# find from SBo repositority www.slackbuild.org
def SBo_network(name):
	SBo_url = SBo_search_pkg(name)
        if SBo_url == None:
        	print ("\n")
                print ("{}The {}'{}'{} not found{}\n".format(colors.RED,
                        colors.CYAN, name, colors.RED, colors.ENDC))
        else:
                # call sbo functions 
                SBo_req = SBo_requires_pkg(SBo_url, name)
                SBo_dwn = SBo_slackbuild_dwn(SBo_url, name)
                source_dwn = SBo_source_dwn(SBo_url, name)
                extra_dwn = "".join(SBo_extra_dwn(SBo_url, name))

                # caclulate the length of the link
                SBo_name_len = len(name)
                SBo_url_len = (len(SBo_url) + SBo_name_len + 21)
                print ("\n")
                print ("+" + "=" * SBo_url_len)
                print ("| {}The {}`{}`{} found in --> {}".format(colors.GREEN,
                        colors.CYAN, name, colors.GREEN,
                        colors.ENDC + SBo_url))
                print ("+" + "=" * SBo_url_len)
                print ("| {}Download SlackBuild : {}{}".format(colors.GREEN,
                        colors.ENDC, SBo_dwn))
                print ("| {}Source Downloads : {}{}".format(colors.GREEN,
                        colors.ENDC, source_dwn))
                print ("| {}Extra Downloads : {}{}".format(colors.GREEN,
                        colors.ENDC, extra_dwn))
                print ("| {}Package requirements : {}{}".format(colors.YELLOW,
                        colors.ENDC, SBo_req))
                print ("+" + "=" * SBo_url_len)
		print (" {}R{}EADME               View the README file".format(colors.RED, colors.ENDC))
		print (" {}S{}lackBuild           View the SlackBuild file".format(colors.RED, colors.ENDC))
                print (" {}I{}nfo                 View the Info file".format(colors.RED, colors.ENDC))
                print (" {}D{}ownload             Download this package".format(colors.RED, colors.ENDC))
		print (" {}B{}uild                Download and build this package".format(colors.RED, colors.ENDC))
		print
		while True:
			read = raw_input("_ ")
			if read == "D" or read == "d":
				print
				print ("{}Start -->{}\n".format(colors.GREEN, colors.ENDC))
				os.system("wget -nc " + SBo_dwn)
				os.system("wget -nc " + source_dwn)

				if extra_dwn == "":
					pass
				else:
					os.system("wget " + extra_dwn)
					

				print ("{}Use {}`slpkg -a`{} to build this package{}\n".format(colors.YELLOW,
					 colors.CYAN, colors.YELLOW, colors.ENDC))
				break

			elif read == "R" or read == "r":
				site = "README"
				read_readme(SBo_url, name, site)
				os.system("less /tmp/slpkg/readme/" + name + ".{}".format(site))

			elif read == "I" or read == "i":
				site = ".info"
				read_info_slackbuild(SBo_url, name, site)
                                os.system("less /tmp/slpkg/readme/" + name + "{}".format(site))

			elif read == "S" or read == "s":
				site = ".SlackBuild"
				read_info_slackbuild(SBo_url, name, site)
                                os.system("less /tmp/slpkg/readme/" + name + "{}".format(site))

			elif read == "B" or read == "b":
				s_user(getpass.getuser())
				script = get_file(SBo_dwn, "/")
				source = get_file(source_dwn, "/")
				print
                                print ("{}Start -->{}\n".format(colors.GREEN, colors.ENDC))
                                os.system("wget -nc " + SBo_dwn)
                                os.system("wget -nc " + source_dwn)

                                if extra_dwn == "":
                                        pass
                                else:
                                        os.system("wget -nc " + extra_dwn)
					extra_dwn = extra_dwn.split() # convert str to list
					if len(find_extra_dwn) == 1:
						extra = get_file(extra_dwn[0], "/")
						build_extra_pkg(script, source, extra)
						break

					elif len(extra_dwn) == 2:
						extra = get_file(extra_dwn[0], "/")
						extra2 = get_file(extra_dwn[1], "/")
						build_extra2_pkg(script, source, extra, extra2)
						break
					else:
						print
				                print ("{}Not supported with more than four arguments{}\n".format(colors.RED,
				                        colors.ENDC))
						break

				build_package(script, source)

                                break

			else:
				break



# check if packages from www.slackbuilds.org is up to date
def SBo_check(name):
	SBo_file = " ".join(find_package(name, packages))
        if SBo_file == "":
        	print
                print (" {}The package {}`{}`{} not found on your system{}\n".format(colors.RED,
                         colors.CYAN, name, colors.RED,  colors.ENDC))

        else:
       	        SBo_url = SBo_search_pkg(name)
                if SBo_url == None:
         	       print ("\n")
                       print ("{}The {}`{}`{} not found{}\n".format(colors.RED,
                               colors.CYAN, name, colors.RED, colors.ENDC))

                else:
                       SBo_version = SBo_version_pkg(SBo_url, name)
                       name_len = len(name)
                       arch_len = len(arch)
                       SBo_file = SBo_file[name_len+1:-arch_len-7]

                       if SBo_version > SBo_file:
	                       print ("\n")
                               print ("{} New version is available !!!{}".format(colors.YELLOW, colors.ENDC))
                               print ("+" + "=" * 50)
                               print ("| {} {}".format(name, SBo_version))
                               print ("+" + "=" * 50)
                               print

                       else:
                               print ("\n")
                               print ("{}Your package is up to date{}\n".format(colors.GREEN, colors.ENDC))
				


# find package and dependencies download, build and install
def SBo_build(name):
	s_user(getpass.getuser())
	dependencies_links = SBo_dependencies_links_pkg(name)	


	# crate one list for all
	if dependencies_links == None:
		sys.exit()
	
	elif dependencies_links != []:
		results = []	
		for i in range(len(dependencies_links)):
			for j in range(len(dependencies_links[i])):
				results.append(dependencies_links[i][j])


	# grep only links from list
	dwn_link = []
	for link in results:
               	if link.startswith('http'):
                       	dwn_link.append(link)


	# grep the version
	version = []
	for ver in results:
		for i in range(0, 10):
	                if ver.startswith(str(i)):
	                        version.append(ver)


	# upside-down lists
	version .reverse()
	dwn_link.reverse()


	# get tar archives from link	
	files = []
	for i in range(len(dwn_link)):
		files.append(get_file(dwn_link[i], "/"))
	

	# removes archive type and store the package name
	filename = []
        y = 0
        for i in range(len(files) / 2):
                if files[y].endswith("tar.gz"):
                        file = files[y]
                        file = file[:-7]
                        filename.append(file)
                        y += 2


	# link sbo filename with version to create package installation
	filename_version = []
	for i in range(len(filename)):
		filename_version.append(filename[i] + "-" + version[i])		



	# remove packages links if already installed
	i = 0
	for file in filename_version:
        	if find_package(file, packages) == []:
			i += 2
        	else:
                	for j in range(0, 2):
                                dwn_link.pop(i)
				files.pop(i)
			
	# create list with packages for install
	pkg_for_install = []
	i = 0
	for i in range(len(filename_version)):
		if find_package(filename_version[i], packages) == []:
			pkg_for_install.append(filename_version[i])
		else:
			pass

	dwn_link = set(dwn_link) # remove double links

	# dwonload links if not exist
	for link in dwn_link:
		print
       		print ("{}Start --> \n{}".format(colors.GREEN, colors.ENDC))	
		os.system("wget -nc {}".format(link))
	


	print ("\n")	
	# build packages and store slackware files in /tmp directory
	if results[0] == "extra1": # check for one (1) extra sources
		for i in range(len(files) / 2):
			if len(files) < 4:
	                        script = files[0]
       	                        source = files[1]
               	                extra = files[2]
                       	        build_extra_pkg(script, source, extra)

				install_pkg = tmp + pkg_for_install[i] + SBo_arch + SBo_tag + SBo_filetype
                                os.system("upgradepkg --install-new {}".format(install_pkg))
       	                        break

			else:

				script = files[0]
				source = files[1]		
				build_package(script, source)
	
				install_pkg = tmp + pkg_for_install[i] + SBo_arch + SBo_tag + SBo_filetype
                       		os.system("upgradepkg --install-new {}".format(install_pkg))

				for j in range(0, 2):
					files.pop(0)


	elif results[0] == "extra2": # check for two (2) extra sources
	
		for i in range(len(files) / 2):
			if len(files) < 5:
	        		script = files[0]
       	                        source = files[1]
               	                extra = files[2]
                       	        extra2 = files[3]
                               	build_extra2_pkg(script, source, extra, extra2)

				install_pkg = tmp + pkg_for_install[i] + SBo_arch + SBo_tag + SBo_filetype
       	                        os.system("upgradepkg --install-new {}".format(install_pkg))
                                break

			else:

	                	script = files[0]
       		                source = files[1]
               		        build_package(script, source)

				install_pkg = tmp + pkg_for_install[i] + SBo_arch + SBo_tag + SBo_filetype
                        	os.system("upgradepkg --install-new {}".format(install_pkg))

	                        for j in range(0, 2):
        	                       	files.pop(0)
	elif  results[0] > "extra2":
		print
	        print ("{}Not supported with more than four arguments{}\n".format(colors.RED,
        	        colors.ENDC))
		sys.exit()
	else:

		for i in range(len(files) / 2):
                        script = files[0]
       	                source = files[1]
			build_package(script, source)
			
 			install_pkg = tmp + pkg_for_install[i] + SBo_arch + SBo_tag + SBo_filetype
			os.system("upgradepkg --install-new {}".format(install_pkg))

			for j in range(0, 2):
	                        files.pop(0)


	for pkg in pkg_for_install:
		if find_package(pkg, packages) != []:
			print ("{}The package {}`{}`{} was installed{}".format(colors.GREEN,
        			colors.CYAN, pkg, colors.GREEN, colors.ENDC))
	print




# install binary package
def pkg_install(name):
	s_user(getpass.getuser())
        for i in range(len(name)):
        	os.system("installpkg {}".format(name[i]))



# upgrade package with new
def pkg_upgrade(name):
        s_user(getpass.getuser())
        for i in range(len(name)):
                os.system("upgradepkg --install-new {}".format(name[i]))



# upgrade package with the same
def pkg_reinstall(name):
        s_user(getpass.getuser())
        for i in range(len(name)):
                os.system("upgradepkg --reinstall {}".format(name[i]))



# uninstall package
def pkg_remove(name):
	s_user(getpass.getuser())
        print ("{}!!! WARNING !!!{}".format(colors.YELLOW, colors.ENDC))
        remove_pkg = raw_input("Are you sure to remove this package(s) [y/n] ")
	print
        if remove_pkg == "y" or remove_pkg == "Y":
        	for i in range(len(name)):
                	if find_package(name[i], packages) == []:
                        	print ("{}The package {}`{}`{} not found{}".format(colors.RED,
                                	colors.CYAN, name[i], colors.RED, colors.ENDC))

                        else:
                                os.system("removepkg {}".format(name[i]))
				if find_package(name[i], packages) == []:
					print
					print ("{}The package {}`{}`{} removed{}".format(colors.YELLOW,
                                        colors.CYAN, name[i], colors.YELLOW, colors.ENDC))
        print



# print find if package installed on your system
def pkg_find(name):
	print
	for i in range(len(name)):
        	if find_package(name[i], packages) == []:
                	print ("{}The package {}`{}`{} not found{}".format(colors.RED,
                        	colors.CYAN, name[i], colors.RED,  colors.ENDC))

                else:
                        print (colors.GREEN + "found --> " + colors.ENDC + "\n".join(find_package(name[i], packages)))
        print         



# print the package contents
def pkg_display(name):
	print
	for i in range(len(name)):
        	if find_package(name[i], packages) == []:
                	print ("{}The package {}`{}`{} not found{}".format(colors.RED,
                        	colors.CYAN, name[i], colors.RED, colors.ENDC))

                else:
                        os.system("cat {}{}".format(packages, "\n".join(find_package(name[i], packages))))
	print




#  main function
def main():
	description = "Utility to help package management in Slackware"
	parser = argparse.ArgumentParser(description=description)

	parser.add_argument("-v", "--verbose", help="print version and exit",
			    action="store_true")

	parser.add_argument("-a", help="auto build package",
                            type=str, nargs="+", metavar=('script','source'))

	parser.add_argument("-l", help="list of installed packages",
                            nargs="+", choices="all sbo".split(), metavar=('all, sbo'))

	parser.add_argument("-t", help="tracking dependencies",
                            type=str, metavar=(''))

	parser.add_argument("-n", help="find from SBo repositority",
			    type=str, metavar=(''))

	parser.add_argument("-c", help="check if your package is up to date",
			    type=str, metavar=(''))

	parser.add_argument("-s", help="download, build & install pkg from SBo",
			    type=str, metavar=(''))

	parser.add_argument("-i", help="install binary packages",
                            type=str, nargs="+", metavar=(''))

	parser.add_argument("-u", help="install-upgrade packages with new",
			    type=str, nargs="+", metavar=(''))

	parser.add_argument("-o", help="reinstall the same packages",
			    type=str, nargs="+", metavar=(''))

	parser.add_argument("-r", help="remove packages",
			    type=str, nargs="+", metavar=(''))

	parser.add_argument("-f", help="find if packages installed",
			    type=str, nargs="+", metavar=(''))

	parser.add_argument("-d", help="display the contents of the packages",
			    type=str, nargs="+", metavar=(''))

	args = parser.parse_args()


	if args.verbose:
		pkg_version()
		

	if args.a:
		pkg_slackbuild(args.a)


	if args.l:
		pkg_list(args.l)


	if args.t:
		pkg_tracking(args.t)


	if args.n:
		SBo_network(args.n)


	if args.c:
		SBo_check(args.c)


	if args.s:
		SBo_build(args.s)
		

	if args.i:
		pkg_install(args.i)
		
   
	if args.u:
		pkg_upgrade(args.u)


	if args.o:
		pkg_reinstall(args.o)


	if args.r:
		pkg_remove(args.r)

		
	if args.f:
		pkg_find(args.f)
	

	if args.d:
		pkg_display(args.d)


	if not any([args.verbose, args.s, args.t, args.c, args.n, args.o, args.i, args.u, args.a,
		    args.r, args.l, args.f, args.d]):
                    os.system("slpkg -h")



if __name__ == "__main__":
    main()
