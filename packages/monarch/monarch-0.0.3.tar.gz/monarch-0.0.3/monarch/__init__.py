# Core Imports
from datetime import datetime
import re
import os
import sys
import errno
import inspect
from importlib import import_module
from glob import glob
import collections

# 3rd Party Imports
import click
from click import echo

# Conditional Imports
# Conditionals
try:
    import mongoengine
    from mongoengine.connection import _get_db as _get_db
except ImportError:
    mongoengine = None
    _get_db = None


try:
    import sqlalchemy
    from sqlalchemy.orm import sessionmaker
except ImportError:
    sqlalchemy = None
    sessionmaker = None

from .core import Migration
from persistance.mongo import MongoMigrationHistory, MongoBackedMigration, copy_db as copy_mongo_db, drop as drop_mongo_db

MIGRATION_TEMPLATE = '''
from monarch import {base_class}

class {migration_class_name}({base_class}):

    def run(self):
        """Write the code here that will migrate the database from one state to the next
            No Need to handle exceptions -- we will take care of that for you
        """
        raise NotImplementedError
'''

CONFIG_TEMPLATE = """
# monarch settings file, generated by monarch init
# feal free to edit it with your application specific settings

ENVIRONMENTS = {
    'production': {
        'host': 'your-host',
        'port': 12345,
        'db_name': 'your-db-name',
        'username': 'asdf',
        'password': 'asdfdf'
    },
    'development': {
        'host': 'your-host',
        'port': 12345,
        'db_name': 'your-db-name',
        'username': 'asdf',
        'password': 'asdfdf'
    },
}

"""

CAMEL_PAT = re.compile(r'([A-Z])')
UNDER_PAT = re.compile(r'_([a-z])')


class Config(object):

    def __init__(self):
        self.migration_directory = None
        self.config_directory = None

    def configure_from_settings_file(self):
        settings = import_module('migrations.settings')

        if not hasattr(settings, 'ENVIRONMENTS'):
            echo()
            echo('Configuration file should have a ENVIRONMENTS method set')
            echo()
            exit()
        else:
            self.environments = settings.ENVIRONMENTS


def establish_datastore_connection(environment):
    mongo_name = environment['db_name']
    mongo_port = int(environment['port'])
    mongoengine.connect(mongo_name, port=mongo_port)


pass_config = click.make_pass_decorator(Config, ensure=True)


@click.group()
@click.option('--migration-directory', '-m',
              type=click.Path(), help='Where migration files will be stored and looked for')
@click.option('--config-directory', '-c', type=click.Path(), help='Point to the configuration file to use')
@pass_config
@click.pass_context
def cli(ctx, config, migration_directory, config_directory):
    """ Your friendly migration manager

        To get help on a specific function you may append --help to the function
        i.e.
        monarch generate --help
    """
    if migration_directory is None:
        migration_directory = './migrations'
    config.migration_directory = migration_directory

    if config_directory is None:
        config_directory = os.path.join(config.migration_directory, 'settings.py')
    config.config_directory = config_directory

    if ctx.invoked_subcommand != 'init':
        config.configure_from_settings_file()


@cli.command()
@click.argument('name')
@pass_config
def generate(config, name):
    """
    Generates a migration file.  pass it a name.  execute like so:

    monarch generate [migration_name]

    i.e.

    monarch generate add_indexes_to_user_collection

    """
    create_migration_directory_if_necessary(config.migration_directory)
    migration_name = generate_migration_name(config.migration_directory, name)
    class_name = "{}Migration".format(underscore_to_camel(name))
    output = MIGRATION_TEMPLATE.format(migration_class_name=class_name, base_class='MongoBackedMigration')
    with open(migration_name, 'w') as f:
        f.write(output)
    click.echo("Generated Migration Template: [{}]".format(migration_name))


@cli.command(name='list')
@click.argument('environment')
@pass_config
def lizt(config, environment):
    """ Lists the migrations and the status against the specified environemnt

    """
    if environment not in config.environments:
        echo()
        echo("Environment not described in settings.py")
        echo()
        exit()

    migrations_on_file_system = find_migrations(config)

    establish_datastore_connection(config.environments[environment])

    if migrations_on_file_system:
        click.echo("Here are the migrations:")
        echo("{:50} {}".format('MIGRATIONS', 'STATUS'))
        for migration_name in migrations_on_file_system:
            migration_meta = MongoMigrationHistory.find_by_key(migration_name)
            if migration_meta:
                echo("{:50} {}".format(migration_name, migration_meta.state))
            else:
                echo("{:50} NOT RUN".format(migration_name))

    else:
        click.echo("No pending migrations")


@cli.command()
@click.argument('environment')
@pass_config
def migrate(config, environment):
    """
    Runs all migrations that have yet to have run.
    :return:
    """
    if environment not in config.environments:
        echo()
        echo("Environment not described in settings.py")
        echo()
        exit()

    # 1) Find all migrations in the migrations/ directory
    # key = name, value = MigrationClass
    migrations = find_migrations(config)
    if migrations:
        establish_datastore_connection(config.environments[environment])
        for k, migration_class in migrations.iteritems():
            migration_instance = migration_class()

            # 3) Run the migration -- it will only run if it has not yet been run yet
            migration_instance.process()
    else:
        click.echo("No migrations exist")


@cli.command()
@pass_config
def init(config):
    """ Generates a default setting file.

        It will it in ./migrations and will create the package if it does not exist

    """
    create_migration_directory_if_necessary(config.migration_directory)
    settings_file = os.path.join(os.path.abspath(config.migration_directory), 'settings.py')
    with open(settings_file, 'w') as f:
        f.write(CONFIG_TEMPLATE)

    msg = """We just created a shinny new configuration file for you.  You can find it here:

    {}

    You are encouraged to open it up and modify it for your needs
    """.format(settings_file)

    echo(msg)


# @cli.command()
# @pass_config
# def initialize_sql_database():
#     engine = sqlalchemy.create_engine('sqlite:///:memory:', echo=False)


@cli.command()
@click.argument('from_to')
@pass_config
def copy_db(config, from_to):
    """ Copys a database and imports into another database

        Example

        monarch import_db production:local
        monarch import_db staging:local

    """
    if ':' not in from_to:
        echo("Expecting from:to syntax like production:local")
        exit()

    from_db, to_db = from_to.split(':')

    if config.environments is None:
        echo('Configuration file should have a ENVIRONMENTS set')
        exit()

    if from_db not in config.environments:
        echo('Environemnts does not have a specification for {}'.format(from_db))
        exit()

    if to_db not in config.environments:
        echo('Environemnts does not have a specification for {}'.format(to_db))
        exit()

    if click.confirm('Are you SURE you want to copy data from {} into {}?'.format(from_db, to_db)):
        echo()
        echo("Okay, you asked for it ...")
        echo()
        copy_mongo_db(config.environments[from_db], config.environments[to_db])

@cli.command()
@click.argument('environment')
@pass_config
def drop_db(config, environment):
    """ drops the database -- ARE YOU SURE YOU WANT TO DO THIS
    """
    drop_mongo_db(config.environments[environment])



def find_migrations(config):
    migrations = {}
    click.echo("fm 1 cwd: {}".format(os.getcwd()))
    for file in glob('{}/*_migration.py'.format(config.migration_directory)):
        migration_name = os.path.splitext(os.path.basename(file))[0]
        migration_module = import_module("migrations.{}".format(migration_name))
        for name, obj in inspect.getmembers(migration_module):
            if inspect.isclass(obj) and re.search('Migration$', name) and name not in ['BaseMigration',
                                                                                       'MongoBackedMigration']:
                migrations[migration_name] = obj

    # 2) Ensure that the are ordered
    ordered = collections.OrderedDict(sorted(migrations.items()))
    return ordered


def camel_to_underscore(name):
    return CAMEL_PAT.sub(lambda x: '_' + x.group(1).lower(), name)


def underscore_to_camel(name):
    return UNDER_PAT.sub(lambda x: x.group(1).upper(), name.capitalize())


def generate_migration_name(folder, name):
    # Can not start with a number so starting with a underscore
    rel_path = "{folder}/_{timestamp}_{name}_migration.py".format(
        folder=folder,
        timestamp=datetime.utcnow().strftime('%Y%m%d%H%M'),
        name=name
    )
    return os.path.abspath(rel_path)


def create_migration_directory_if_necessary(dir):
    try:
        os.makedirs(dir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise

    try:
        with open(os.path.join(os.path.abspath(dir), '__init__.py'), 'w') as f:
            f.write('# this file makes migrations a package')
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
