# Core Imports
import re
import os
import errno
import shutil
import inspect
import zipfile
import collections
from glob import glob
from tempfile import mkdtemp
from datetime import datetime
from importlib import import_module

# 3rd Party Imports
import boto
import click
from click import echo
from boto.s3.key import Key

# Local Imports
from .models import Migration
from .utils import temp_directory, camel_to_underscore, underscore_to_camel, sizeof_fmt
from .mongo import drop as drop_mongo_db
from .mongo import copy_db as copy_mongo_db
from .mongo import MongoMigrationHistory, MongoBackedMigration
from .mongo import dump_db, restore as restore_mongo_db
from .mongo import establish_datastore_connection


MIGRATION_TEMPLATE = '''
from monarch import {base_class}

class {migration_class_name}({base_class}):

    def run(self):
        """Write the code here that will migrate the database from one state to the next
            No Need to handle exceptions -- we will take care of that for you
        """
        raise NotImplementedError
'''

CONFIG_TEMPLATE = """
# monarch settings file, generated by monarch init
# feal free to edit it with your application specific settings

ENVIRONMENTS = {
    'production': {
        'host': 'your-host',
        'port': 12345,
        'db_name': 'your-db-name',
        'username': 'asdf',
        'password': 'asdfdf'
    },
    'development': {
        'host': 'your-host',
        'port': 12345,
        'db_name': 'your-db-name',
        'username': 'asdf',
        'password': 'asdfdf'
    },
}


# If you want to use the backups feature uncomment and fill out the following:
# BACKUPS = {
#     'S3': {
#         'bucket_name': 'your_bucket_name',
#         'aws_access_key_id': 'aws_access_key_id',
#         'aws_secret_access_key': 'aws_secret_access_key',
#     }
# }

# OR

# BACKUPS = {
#     'LOCAL': {
#         'backup_dir': 'path_to_backups',
#     }
# }


"""


class Config(object):

    def __init__(self):
        self.migration_directory = './migrations'
        self.config_directory = None

    def configure_from_settings_file(self):
        settings = import_module('migrations.settings')

        if not hasattr(settings, 'ENVIRONMENTS'):
            exit_with_message('Configuration file should have a ENVIRONMENTS method set')
        else:
            self.environments = settings.ENVIRONMENTS

        if hasattr(settings, 'BACKUPS'):
            self.backups = settings.BACKUPS

            if 'S3' in self.backups and 'LOCAL' in self.backups:
                exit_with_message('BACKUPS Setting has both LOCAL and S3 config -- choose one')
            elif 'S3' not in self.backups and 'LOCAL' not in self.backups:
                exit_with_message('BACKUPS are configured, but S3 or LOCAL is not defined -- please define one')
            elif 'S3' in self.backups:
                s3_config = self.backups['S3']

                required_config = ['bucket_name', 'aws_access_key_id', 'aws_secret_access_key']

                missing_config = []

                for item in required_config:
                    if item not in s3_config:
                        missing_config.append(item)

                if missing_config:
                    msg = "Missing [] items in S3 section of your settings.py".format(", ".join(missing_config))
                    exit_with_message(msg)

pass_config = click.make_pass_decorator(Config, ensure=True)


@click.group()
@pass_config
@click.pass_context
def cli(ctx, config):
    """ Your friendly migration manager

        To get help on a specific function you may append --help to the function
        i.e.
        monarch generate --help
    """
    if ctx.invoked_subcommand != 'init':
        config.configure_from_settings_file()


@cli.command()
@click.argument('name')
@pass_config
def generate(config, name):
    """
    Generates a migration file.  pass it a name.  execute like so:

    monarch generate [migration_name]

    i.e.

    monarch generate add_indexes_to_user_collection

    """
    create_migration_directory_if_necessary(config.migration_directory)
    migration_name = generate_migration_name(config.migration_directory, name)
    class_name = "{}Migration".format(underscore_to_camel(name))
    output = MIGRATION_TEMPLATE.format(migration_class_name=class_name, base_class='MongoBackedMigration')
    with open(migration_name, 'w') as f:
        f.write(output)
    click.echo("Generated Migration Template: [{}]".format(migration_name))


@cli.command(name='list_migrations')
@click.argument('environment')
@pass_config
def lizt(config, environment):
    """ Lists the migrations and the status against the specified environemnt

    """
    if environment not in config.environments:
        exit_with_message("Environment not described in settings.py")

    migrations_on_file_system = find_migrations(config)

    establish_datastore_connection(config.environments[environment])

    if migrations_on_file_system:
        click.echo("Here are the migrations:")
        echo("{:50} {}".format('MIGRATIONS', 'STATUS'))
        for migration_name in migrations_on_file_system:
            migration_meta = MongoMigrationHistory.find_by_key(migration_name)
            if migration_meta:
                echo("{:50} {}".format(migration_name, migration_meta.state))
            else:
                echo("{:50} NOT RUN".format(migration_name))

    else:
        click.echo("No pending migrations")


@cli.command()
@click.argument('environment')
@pass_config
def migrate(config, environment):
    """
    Runs all migrations that have yet to have run.
    :return:
    """
    if environment not in config.environments:
        exit_with_message("Environment not described in settings.py")

    # 1) Find all migrations in the migrations/ directory
    # key = name, value = MigrationClass
    migrations = find_migrations(config)
    if migrations:
        establish_datastore_connection(config.environments[environment])
        for k, migration_class in migrations.iteritems():
            migration_instance = migration_class()

            # 3) Run the migration -- it will only run if it has not yet been run yet
            migration_instance.process()
    else:
        click.echo("No migrations exist")


@cli.command()
@click.option('--migration-directory', default='./migrations', help='path to where you want to store your migrations')
def init(migration_directory):
    """ Generates a default setting file.

        It will it in ./migrations and will create the package if it does not exist

    """

    create_migration_directory_if_necessary(migration_directory)
    settings_file = os.path.join(os.path.abspath(migration_directory), 'settings.py')

    if os.path.exists(settings_file):
        click.confirm("A settings file already exists.  Are you sure you want to overwrite it?", abort=True)

    with open(settings_file, 'w') as f:
        f.write(CONFIG_TEMPLATE)

    msg = """We just created a shinny new configuration file for you.  You can find it here:

    {}

    You are encouraged to open it up and modify it for your needs
    """.format(settings_file)

    echo(msg)


@cli.command()
@click.argument('from_to')
@pass_config
def copy_db(config, from_to):
    """ Copys a database and imports into another database

        Example

        monarch import_db production:local
        monarch import_db staging:local

    """
    if ':' not in from_to:
        exit_with_message("Expecting from:to syntax like production:local")

    from_db, to_db = from_to.split(':')

    if config.environments is None:
        exit_with_message('Configuration file should have a ENVIRONMENTS set')

    if from_db not in config.environments:
        exit_with_message('Environemnts does not have a specification for {}'.format(from_db))

    if to_db not in config.environments:
        exit_with_message('Environemnts does not have a specification for {}'.format(to_db))

    if click.confirm('Are you SURE you want to copy data from {} into {}?'.format(from_db, to_db)):
        echo()
        echo("Okay, you asked for it ...")
        echo()
        copy_mongo_db(config.environments[from_db], config.environments[to_db])


@cli.command()
@click.argument('environment')
@pass_config
def drop_db(config, environment):
    """ drops the database -- ARE YOU SURE YOU WANT TO DO THIS
    """
    drop_mongo_db(config.environments[environment])


@cli.command()
@click.argument('environment')
@pass_config
def backup(config, environment):
    """ Backs up a given datastore
        It is configured in the BACKUPS section of settings
        You can back up locally or to S3
    """
    env_name = environment

    if not hasattr(config, 'backups'):
        exit_with_message('BACKUPS not configured, exiting')

    environment = confirm_environment(config, env_name)

    if 'LOCAL' in config.backups:
        backup_localy(environment, config.backups['LOCAL'])
    elif 'S3' in config.backups:
        backup_to_s3(environment, config.backups['S3'])
    else:
        exit_with_message('BACKUPS not configured, exiting')


@cli.command()
@pass_config
def list_backups(config):
    """ Lists available backups
    """
    if config.backups is None:
        exit_with_message('BACKUPS not configured, exiting')

    if 'LOCAL' in config.backups:
        list_local_backups(config.backups['LOCAL'])
    elif 'S3' in config.backups:
        list_s3_backups(config.backups['S3'])
    else:
        exit_with_message('BACKUPS not configured, exiting')


@cli.command()
@pass_config
def list_environments(config):
    """ Lists Configured Environments
    """
    if config.environments:
        for env in config.environments:
            echo("{:40}: {}".format(env, config.environments[env]))
    else:
        echo()
        echo("Yikes you have no environemnts set up -- you should set some up.  Maybe rerun monarch init")
        echo()



@cli.command()
@click.argument('from_to')
@pass_config
def restore(config, from_to):
    """ Restores a backup into a destination database.  Provide a dump name that you can get from

        monarch list_backups

        Example

        monarch restore adid-development__2014_06_18.dmp.zip:development

    """
    if ':' not in from_to:
        exit_with_message("Expecting from:to syntax like production:local")

    backup, to_db = from_to.split(':')

    if config.environments is None:
        exit_with_message('Configuration file should have a ENVIRONMENTS set')

    if to_db not in config.environments:
        exit_with_message('Environemnts does not have a specification for {}'.format(to_db))

    if backup not in backups(config):
        exit_with_message('Can not find backup {}, run monarch list_backups to see your options'.format(backup))

    msg = 'Are you SURE you want to retore backup into into {}? It will delete the database first'.format(to_db)
    if click.confirm(msg):
        echo()
        echo("Okay, you asked for it ...")
        echo()
        restore_db(config, backups(config)[backup], config.environments[to_db])


def find_migrations(config):
    migrations = {}
    click.echo("fm 1 cwd: {}".format(os.getcwd()))
    for file in glob('{}/*_migration.py'.format(config.migration_directory)):
        migration_name = os.path.splitext(os.path.basename(file))[0]
        migration_module = import_module("migrations.{}".format(migration_name))
        for name, obj in inspect.getmembers(migration_module):
            if inspect.isclass(obj) and re.search('Migration$', name) and name not in ['BaseMigration',
                                                                                       'MongoBackedMigration']:
                migrations[migration_name] = obj

    # 2) Ensure that the are ordered
    ordered = collections.OrderedDict(sorted(migrations.items()))
    return ordered


def exit_with_message(message):
    echo()
    echo(message)
    echo()
    exit()


def confirm_environment(config, env_name):
    if env_name not in config.environments:
        exit_with_message("{} is not in settings.  Exiting ...".format(env_name))
    else:
        return config.environments[env_name]


def list_local_backups(local_config):

    _local_backups = local_backups(local_config)
    if _local_backups:
        for backup in _local_backups:
            echo("{:50} {}".format(backup, sizeof_fmt(os.path.getsize(_local_backups[backup]))))
    else:
        echo()
        echo('You have not backups yet -- make some?  monarch backup <env_name>')
        echo()


def list_s3_backups(s3_settings):
    _s3_backups = s3_backups(s3_settings)
    if _s3_backups:
        for backup in _s3_backups:
            echo("{:50} {}".format(backup, sizeof_fmt(_s3_backups[backup].size)))
    else:
        echo()
        echo('You have not backups yet -- make some?  monarch backup <env_name>')
        echo()


def get_s3_bucket(s3_settings):
    conn = boto.connect_s3(s3_settings['aws_access_key_id'], s3_settings['aws_secret_access_key'])
    bucket = conn.get_bucket(s3_settings['bucket_name'])
    return bucket


def backup_to_s3(environment, s3_settings):

    zipf = dump_and_zip(environment)

    key = generate_uniqueish_key(s3_settings, environment)

    bytes_written = key.set_contents_from_filename(zipf.filename)

    # 4) print out the name of the bucket
    echo("Wrote {} btyes to s3".format(bytes_written))


def dump_and_zip(from_env):
    # 1) dump db locally to temp file
    temp_dir = mkdtemp()
    dump_path = dump_db(from_env, temp_dir)
    echo("Zipping File")
    # 2) compress file
    def zipdir(path, zip):
        for root, dirs, files in os.walk(path):
            for file in files:
                zip.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), root))

    zipf = zipfile.ZipFile('MongoDump.zip', 'w')
    zipdir(dump_path, zipf)
    zipf.close()
    return zipf


def generate_uniqueish_key(s3_settings, environment):
    bucket = get_s3_bucket(s3_settings)

    name_attempt = "{}__{}.dmp.zip".format(environment['db_name'], datetime.utcnow().strftime("%Y_%m_%d"))

    key = bucket.get_key(name_attempt)

    if not key:
        key = Key(bucket)
        key.key = name_attempt
        return key
    else:
        counter = 1
        while True:
            counter += 1
            name_attempt = "{}__{}_{}.dmp.zip".format(environment['db_name'],
                                                      datetime.utcnow().strftime("%Y_%m_%d"), counter)

            if bucket.get_key(name_attempt):
                continue
            else:
                key = Key(bucket)
                key.key = name_attempt
                return key


def backup_localy(enviornment, local_settings):

    if 'backup_dir' not in local_settings:
        exit_with_message('Local Settings not configured correctly, expecting "backup_dir"')

    backup_dir = local_settings['backup_dir']

    if not os.path.isdir(backup_dir):
        exit_with_message('Directory [{}] does not exist.  Exiting ...'.format(backup_dir))

    zipf = dump_and_zip(enviornment)

    unique_file_path = generate_unique_name(backup_dir, enviornment)

    shutil.move(zipf.filename, unique_file_path)


def local_restore(zip_path, to_environment):
    zip = zipfile.ZipFile(zip_path)
    with temp_directory() as temp_dir:
        zip.extractall(path=temp_dir)
        restore_mongo_db(temp_dir, to_environment)


def s3_restore(key, to_enviornment):

    with temp_directory() as temp_dir:
        zip_path = os.path.join(temp_dir, 'MongoDump.zip')
        key.get_contents_to_filename(zip_path)
        local_restore(zip_path, to_enviornment)


def restore_db(config, path_or_key, to_environment):
    """unzips the file then runs a restore"""

    if config.backups is None:
        exit_with_message('BACKUPS not configured, exiting')

    if 'LOCAL' in config.backups:
        return local_restore(path_or_key, to_environment)
    elif 'S3' in config.backups:
        return s3_restore(path_or_key, to_environment)
    else:
        exit_with_message('BACKUPS not configured, exiting')

    echo()
    echo("Rock and roll that seemed to go well -- Nice work")
    echo()


def backups(config):
    """returns a dictionary of {backup_name: backup_path}"""
    if config.backups is None:
        exit_with_message('BACKUPS not configured, exiting')

    if 'LOCAL' in config.backups:
        return local_backups(config.backups['LOCAL'])
    elif 'S3' in config.backups:
        return s3_backups(config.backups['S3'])
    else:
        exit_with_message('BACKUPS not configured, exiting')


def local_backups(local_config):
    if 'backup_dir' not in local_config:
        exit_with_message('Local Settings not configured correctly, expecting "backup_dir"')

    backup_dir = local_config['backup_dir']

    if not os.path.isdir(backup_dir):
        exit_with_message('Directory [{}] does not exist.  Exiting ...'.format(backup_dir))

    backups = {}
    for item in os.listdir(backup_dir):
        backups[item] = os.path.join(backup_dir, item)

    return backups


def s3_backups(s3_config):
    """ a dict of key.name: key
    """
    bucket = get_s3_bucket(s3_config)

    buckets = {}
    for key in bucket.get_all_keys():
        buckets[key.name] = key

    return buckets


def generate_unique_name(backup_dir, environemnt):
    # generate_file_name
    # database_name__2013_03_01.dmp.zip
    # or if that exists
    # database_name__2013_03_01(2).dmp.zip
    name_attempt = "{}__{}.dmp.zip".format(environemnt['db_name'], datetime.utcnow().strftime("%Y_%m_%d"))

    # check if file exists
    name_attemp_full_path = os.path.join(backup_dir, name_attempt)

    if not os.path.exists(name_attemp_full_path):
        return name_attemp_full_path
    else:
        counter = 1
        while True:
            counter += 1
            name_attempt = "{}__{}_{}.dmp.zip".format(environemnt['db_name'],
                                                      datetime.utcnow().strftime("%Y_%m_%d"), counter)
            name_attempt_full_path = os.path.join(backup_dir, name_attempt)
            if os.path.exists(name_attempt_full_path):
                continue
            else:
                return name_attempt_full_path


def generate_migration_name(folder, name):
    # Can not start with a number so starting with a underscore
    rel_path = "{folder}/_{timestamp}_{name}_migration.py".format(
        folder=folder,
        timestamp=datetime.utcnow().strftime('%Y%m%d%H%M'),
        name=name
    )
    return os.path.abspath(rel_path)


def create_migration_directory_if_necessary(dir):
    try:
        os.makedirs(dir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise

    try:
        with open(os.path.join(os.path.abspath(dir), '__init__.py'), 'w') as f:
            f.write('# this file makes migrations a package')
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
